// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Assert = require("assert");
var Vscode = require("vscode");
var Log$AgdaModeVscode = require("../../../src/State/Log.bs.js");
var Chan$AgdaModeVscode = require("../../../src/Util/Chan.bs.js");
var Config$AgdaModeVscode = require("../../../src/Config.bs.js");
var Desktop$AgdaModeVscode = require("../../../src/Main/Desktop.bs.js");
var Memento$AgdaModeVscode = require("../../../src/Memento.bs.js");
var Connection$AgdaModeVscode = require("../../../src/Connection/Connection.bs.js");
var Test__Util$AgdaModeVscode = require("../Test__Util.bs.js");

describe("Config.Connection paths", (function () {
        var userAgda = {
          contents: ""
        };
        var systemAgda = {
          contents: ""
        };
        var brokenAgda = {
          contents: "/broken/agda"
        };
        var alternativeAgda = {
          contents: ""
        };
        var logChannel = Chan$AgdaModeVscode.make();
        before(async function () {
              userAgda.contents = await Test__Util$AgdaModeVscode.Endpoint.Agda.mock("2.7.0.1", "agda-mock-user");
              systemAgda.contents = await Test__Util$AgdaModeVscode.Endpoint.Agda.mock("2.7.0.1", "agda-mock-system");
              alternativeAgda.contents = await Test__Util$AgdaModeVscode.Endpoint.Agda.mock("2.7.0.1", "agda-mock-alt");
            });
        after(async function () {
              await Test__Util$AgdaModeVscode.Endpoint.Agda.destroy(userAgda.contents);
              await Test__Util$AgdaModeVscode.Endpoint.Agda.destroy(systemAgda.contents);
              return await Test__Util$AgdaModeVscode.Endpoint.Agda.destroy(alternativeAgda.contents);
            });
        var findCommand = function (_command, _timeoutOpt) {
          return Promise.resolve({
                      TAG: "Ok",
                      _0: systemAgda.contents
                    });
        };
        var platformWithDiscovery_determinePlatform = Desktop$AgdaModeVscode.Desktop.determinePlatform;
        var platformWithDiscovery_alreadyDownloaded = Desktop$AgdaModeVscode.Desktop.alreadyDownloaded;
        var platformWithDiscovery_downloadLatestALS = Desktop$AgdaModeVscode.Desktop.downloadLatestALS;
        var platformWithDiscovery_getInstalledEndpointsAndPersistThem = Desktop$AgdaModeVscode.Desktop.getInstalledEndpointsAndPersistThem;
        var platformWithDiscovery_askUserAboutDownloadPolicy = Desktop$AgdaModeVscode.Desktop.askUserAboutDownloadPolicy;
        var platformWithDiscovery = {
          determinePlatform: platformWithDiscovery_determinePlatform,
          findCommand: findCommand,
          alreadyDownloaded: platformWithDiscovery_alreadyDownloaded,
          downloadLatestALS: platformWithDiscovery_downloadLatestALS,
          getInstalledEndpointsAndPersistThem: platformWithDiscovery_getInstalledEndpointsAndPersistThem,
          askUserAboutDownloadPolicy: platformWithDiscovery_askUserAboutDownloadPolicy
        };
        var findCommand$1 = function (_command, _timeoutOpt) {
          return Promise.resolve({
                      TAG: "Error",
                      _0: "NotFound"
                    });
        };
        var platformNoDiscovery_determinePlatform = Desktop$AgdaModeVscode.Desktop.determinePlatform;
        var platformNoDiscovery_alreadyDownloaded = Desktop$AgdaModeVscode.Desktop.alreadyDownloaded;
        var platformNoDiscovery_downloadLatestALS = Desktop$AgdaModeVscode.Desktop.downloadLatestALS;
        var platformNoDiscovery_getInstalledEndpointsAndPersistThem = Desktop$AgdaModeVscode.Desktop.getInstalledEndpointsAndPersistThem;
        var platformNoDiscovery_askUserAboutDownloadPolicy = Desktop$AgdaModeVscode.Desktop.askUserAboutDownloadPolicy;
        var platformNoDiscovery = {
          determinePlatform: platformNoDiscovery_determinePlatform,
          findCommand: findCommand$1,
          alreadyDownloaded: platformNoDiscovery_alreadyDownloaded,
          downloadLatestALS: platformNoDiscovery_downloadLatestALS,
          getInstalledEndpointsAndPersistThem: platformNoDiscovery_getInstalledEndpointsAndPersistThem,
          askUserAboutDownloadPolicy: platformNoDiscovery_askUserAboutDownloadPolicy
        };
        var makeConnection = async function (configPaths, platform) {
          var memento = Memento$AgdaModeVscode.make(undefined);
          await Config$AgdaModeVscode.Connection.setAgdaPaths(logChannel, configPaths);
          return await Connection$AgdaModeVscode.make(platform, memento, Vscode.Uri.file("/tmp/test"), configPaths, ["agda"], logChannel);
        };
        describe("Working config paths", (function () {
                it("should not modify config with single working path", (async function () {
                        var configPaths = [userAgda.contents];
                        var listener = Log$AgdaModeVscode.collect(logChannel);
                        var result = await makeConnection(configPaths, platformWithDiscovery);
                        var logs = listener(Log$AgdaModeVscode.isConfig);
                        Curry._3(Assert.deepStrictEqual, logs, [], undefined);
                        Curry._3(Assert.deepStrictEqual, Config$AgdaModeVscode.Connection.getAgdaPaths(), configPaths, undefined);
                        if (result.TAG === "Ok") {
                          return Curry._3(Assert.deepStrictEqual, Connection$AgdaModeVscode.getPath(result._0), userAgda.contents, undefined);
                        }
                        Assert.fail("Connection should succeed");
                      }));
                it("should not modify config with multiple working paths", (async function () {
                        var configPaths = [
                          userAgda.contents,
                          alternativeAgda.contents
                        ];
                        var listener = Log$AgdaModeVscode.collect(logChannel);
                        var result = await makeConnection(configPaths, platformWithDiscovery);
                        var logs = listener(Log$AgdaModeVscode.isConfig);
                        Curry._3(Assert.deepStrictEqual, logs, [], undefined);
                        Curry._3(Assert.deepStrictEqual, Config$AgdaModeVscode.Connection.getAgdaPaths(), configPaths, undefined);
                        if (result.TAG === "Ok") {
                          return Curry._3(Assert.deepStrictEqual, Connection$AgdaModeVscode.getPath(result._0), userAgda.contents, undefined);
                        }
                        Assert.fail("Connection should succeed");
                      }));
                it("should not modify config with mixed working/broken paths", (async function () {
                        var configPaths = [
                          brokenAgda.contents,
                          userAgda.contents,
                          "/another/broken"
                        ];
                        var listener = Log$AgdaModeVscode.collect(logChannel);
                        var result = await makeConnection(configPaths, platformWithDiscovery);
                        var logs = listener(Log$AgdaModeVscode.isConfig);
                        Curry._3(Assert.deepStrictEqual, logs, [], undefined);
                        Curry._3(Assert.deepStrictEqual, Config$AgdaModeVscode.Connection.getAgdaPaths(), configPaths, undefined);
                        if (result.TAG === "Ok") {
                          return Curry._3(Assert.deepStrictEqual, Connection$AgdaModeVscode.getPath(result._0), userAgda.contents, undefined);
                        }
                        Assert.fail("Connection should succeed");
                      }));
              }));
        describe("Broken config paths", (function () {
                it("should add discovered path when all config paths are broken and auto discovery succeeds", (async function () {
                        var configPaths = [
                          brokenAgda.contents,
                          "/another/broken"
                        ];
                        var listener = Log$AgdaModeVscode.collect(logChannel);
                        var result = await makeConnection(configPaths, platformWithDiscovery);
                        var logs = listener(Log$AgdaModeVscode.isConfig);
                        var expectedConfig = configPaths.concat([systemAgda.contents]);
                        Curry._3(Assert.deepStrictEqual, logs, [{
                                TAG: "Config",
                                _0: {
                                  TAG: "Changed",
                                  _0: configPaths,
                                  _1: expectedConfig
                                }
                              }], undefined);
                        Curry._3(Assert.deepStrictEqual, Config$AgdaModeVscode.Connection.getAgdaPaths(), expectedConfig, undefined);
                        if (result.TAG === "Ok") {
                          return Curry._3(Assert.deepStrictEqual, Connection$AgdaModeVscode.getPath(result._0), systemAgda.contents, undefined);
                        }
                        Assert.fail("Connection should succeed");
                      }));
                it("should fail without modifying config when all config paths are broken and auto discovery fails", (async function () {
                        var configPaths = [
                          brokenAgda.contents,
                          "/another/broken"
                        ];
                        var listener = Log$AgdaModeVscode.collect(logChannel);
                        var result = await makeConnection(configPaths, platformNoDiscovery);
                        var logs = listener(Log$AgdaModeVscode.isConfig);
                        Curry._3(Assert.deepStrictEqual, logs, [], undefined);
                        Curry._3(Assert.deepStrictEqual, Config$AgdaModeVscode.Connection.getAgdaPaths(), configPaths, undefined);
                        if (result.TAG !== "Ok") {
                          return ;
                        }
                        Assert.fail("Connection should fail when all paths are broken and no discovery");
                      }));
              }));
        describe("Empty config paths", (function () {
                it("should add discovered path when config is empty and auto discovery succeeds", (async function () {
                        var configPaths = [];
                        var listener = Log$AgdaModeVscode.collect(logChannel);
                        var result = await makeConnection(configPaths, platformWithDiscovery);
                        var logs = listener(Log$AgdaModeVscode.isConfig);
                        var expectedConfig = [systemAgda.contents];
                        Curry._3(Assert.deepStrictEqual, logs, [{
                                TAG: "Config",
                                _0: {
                                  TAG: "Changed",
                                  _0: [],
                                  _1: expectedConfig
                                }
                              }], undefined);
                        Curry._3(Assert.deepStrictEqual, Config$AgdaModeVscode.Connection.getAgdaPaths(), expectedConfig, undefined);
                        if (result.TAG === "Ok") {
                          return Curry._3(Assert.deepStrictEqual, Connection$AgdaModeVscode.getPath(result._0), systemAgda.contents, undefined);
                        }
                        Assert.fail("Connection should succeed");
                      }));
                it("should fail without modifying config when config is empty and auto discovery fails", (async function () {
                        var configPaths = [];
                        var listener = Log$AgdaModeVscode.collect(logChannel);
                        var result = await makeConnection(configPaths, platformNoDiscovery);
                        var logs = listener(Log$AgdaModeVscode.isConfig);
                        Curry._3(Assert.deepStrictEqual, logs, [], undefined);
                        Curry._3(Assert.deepStrictEqual, Config$AgdaModeVscode.Connection.getAgdaPaths(), configPaths, undefined);
                        if (result.TAG !== "Ok") {
                          return ;
                        }
                        Assert.fail("Connection should fail when config is empty and no discovery");
                      }));
              }));
        describe("UI-triggered additions", (function () {
                it("should add selected path when user chooses from switch version UI", (async function () {
                        Assert.ok(true);
                      }));
              }));
      }));

/*  Not a pure module */
