// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Assert = require("assert");
var Vscode = require("vscode");
var Log$AgdaModeVscode = require("../../../src/State/Log.bs.js");
var Chan$AgdaModeVscode = require("../../../src/Util/Chan.bs.js");
var Mock$AgdaModeVscode = require("../../../src/Main/Mock.bs.js");
var State$AgdaModeVscode = require("../../../src/State/State.bs.js");
var Config$AgdaModeVscode = require("../../../src/Config.bs.js");
var Desktop$AgdaModeVscode = require("../../../src/Main/Desktop.bs.js");
var Memento$AgdaModeVscode = require("../../../src/Memento.bs.js");
var Connection$AgdaModeVscode = require("../../../src/Connection/Connection.bs.js");
var Test__Util$AgdaModeVscode = require("../Test__Util.bs.js");
var State__SwitchVersion$AgdaModeVscode = require("../../../src/State/State__SwitchVersion.bs.js");

describe("Config.Connection paths", (function () {
        var userAgda = {
          contents: ""
        };
        var systemAgda = {
          contents: ""
        };
        var brokenAgda = {
          contents: "/broken/agda"
        };
        var alternativeAgda = {
          contents: ""
        };
        var downloadedALS = {
          contents: ""
        };
        var logChannel = Chan$AgdaModeVscode.make();
        before(async function () {
              userAgda.contents = await Test__Util$AgdaModeVscode.Endpoint.Agda.mock("2.7.0.1", "agda-mock-user");
              systemAgda.contents = await Test__Util$AgdaModeVscode.Endpoint.Agda.mock("2.7.0.1", "agda-mock-system");
              alternativeAgda.contents = await Test__Util$AgdaModeVscode.Endpoint.Agda.mock("2.7.0.1", "agda-mock-alt");
              downloadedALS.contents = await Test__Util$AgdaModeVscode.Endpoint.ALS.mock("1.3.1", "2.6.3", "als-make-mock");
            });
        after(async function () {
              await Test__Util$AgdaModeVscode.Endpoint.Agda.destroy(userAgda.contents);
              await Test__Util$AgdaModeVscode.Endpoint.Agda.destroy(systemAgda.contents);
              await Test__Util$AgdaModeVscode.Endpoint.Agda.destroy(alternativeAgda.contents);
              return await Test__Util$AgdaModeVscode.Endpoint.ALS.destroy(downloadedALS.contents);
            });
        var findCommand = function (_command, _timeoutOpt) {
          return Promise.resolve({
                      TAG: "Ok",
                      _0: systemAgda.contents
                    });
        };
        var platformWithDiscovery_determinePlatform = Desktop$AgdaModeVscode.Desktop.determinePlatform;
        var platformWithDiscovery_alreadyDownloaded = Desktop$AgdaModeVscode.Desktop.alreadyDownloaded;
        var platformWithDiscovery_getDownloadDescriptorOfDevALS = Desktop$AgdaModeVscode.Desktop.getDownloadDescriptorOfDevALS;
        var platformWithDiscovery_getDownloadDescriptorOfDevWASMALS = Desktop$AgdaModeVscode.Desktop.getDownloadDescriptorOfDevWASMALS;
        var platformWithDiscovery_getDownloadDescriptorOfLatestALS = Desktop$AgdaModeVscode.Desktop.getDownloadDescriptorOfLatestALS;
        var platformWithDiscovery_download = Desktop$AgdaModeVscode.Desktop.download;
        var platformWithDiscovery_askUserAboutDownloadPolicy = Desktop$AgdaModeVscode.Desktop.askUserAboutDownloadPolicy;
        var platformWithDiscovery_openFolder = Desktop$AgdaModeVscode.Desktop.openFolder;
        var platformWithDiscovery = {
          determinePlatform: platformWithDiscovery_determinePlatform,
          findCommand: findCommand,
          alreadyDownloaded: platformWithDiscovery_alreadyDownloaded,
          getDownloadDescriptorOfDevALS: platformWithDiscovery_getDownloadDescriptorOfDevALS,
          getDownloadDescriptorOfDevWASMALS: platformWithDiscovery_getDownloadDescriptorOfDevWASMALS,
          getDownloadDescriptorOfLatestALS: platformWithDiscovery_getDownloadDescriptorOfLatestALS,
          download: platformWithDiscovery_download,
          askUserAboutDownloadPolicy: platformWithDiscovery_askUserAboutDownloadPolicy,
          openFolder: platformWithDiscovery_openFolder
        };
        var findCommand$1 = function (_command, _timeoutOpt) {
          return Promise.resolve({
                      TAG: "Error",
                      _0: "NotFound"
                    });
        };
        var platformNoDiscovery_determinePlatform = Desktop$AgdaModeVscode.Desktop.determinePlatform;
        var platformNoDiscovery_alreadyDownloaded = Desktop$AgdaModeVscode.Desktop.alreadyDownloaded;
        var platformNoDiscovery_getDownloadDescriptorOfDevALS = Desktop$AgdaModeVscode.Desktop.getDownloadDescriptorOfDevALS;
        var platformNoDiscovery_getDownloadDescriptorOfDevWASMALS = Desktop$AgdaModeVscode.Desktop.getDownloadDescriptorOfDevWASMALS;
        var platformNoDiscovery_getDownloadDescriptorOfLatestALS = Desktop$AgdaModeVscode.Desktop.getDownloadDescriptorOfLatestALS;
        var platformNoDiscovery_download = Desktop$AgdaModeVscode.Desktop.download;
        var platformNoDiscovery_askUserAboutDownloadPolicy = Desktop$AgdaModeVscode.Desktop.askUserAboutDownloadPolicy;
        var platformNoDiscovery_openFolder = Desktop$AgdaModeVscode.Desktop.openFolder;
        var platformNoDiscovery = {
          determinePlatform: platformNoDiscovery_determinePlatform,
          findCommand: findCommand$1,
          alreadyDownloaded: platformNoDiscovery_alreadyDownloaded,
          getDownloadDescriptorOfDevALS: platformNoDiscovery_getDownloadDescriptorOfDevALS,
          getDownloadDescriptorOfDevWASMALS: platformNoDiscovery_getDownloadDescriptorOfDevWASMALS,
          getDownloadDescriptorOfLatestALS: platformNoDiscovery_getDownloadDescriptorOfLatestALS,
          download: platformNoDiscovery_download,
          askUserAboutDownloadPolicy: platformNoDiscovery_askUserAboutDownloadPolicy,
          openFolder: platformNoDiscovery_openFolder
        };
        var makeConnection = async function (configPaths, platform) {
          var memento = Memento$AgdaModeVscode.make(undefined);
          await Config$AgdaModeVscode.Connection.setAgdaPaths(logChannel, configPaths);
          var listener = Log$AgdaModeVscode.collect(logChannel);
          var result = await Connection$AgdaModeVscode.makeWithFallback(platform, memento, Vscode.Uri.file("/tmp/test"), configPaths, ["agda"], logChannel);
          var logs = listener(Log$AgdaModeVscode.isConfig);
          return [
                  logs,
                  result
                ];
        };
        describe("Working config paths", (function () {
                it("should not modify config with single working path", (async function () {
                        var configPaths = [userAgda.contents];
                        var match = await makeConnection(configPaths, platformWithDiscovery);
                        var result = match[1];
                        Curry._3(Assert.deepStrictEqual, match[0], [], undefined);
                        Curry._3(Assert.deepStrictEqual, Config$AgdaModeVscode.Connection.getAgdaPaths(), configPaths, undefined);
                        if (result.TAG === "Ok") {
                          return Curry._3(Assert.deepStrictEqual, Connection$AgdaModeVscode.getPath(result._0), userAgda.contents, undefined);
                        }
                        Assert.fail("Connection should succeed");
                      }));
                it("should not modify config with multiple working paths", (async function () {
                        var configPaths = [
                          userAgda.contents,
                          alternativeAgda.contents
                        ];
                        var match = await makeConnection(configPaths, platformWithDiscovery);
                        var result = match[1];
                        Curry._3(Assert.deepStrictEqual, match[0], [], undefined);
                        Curry._3(Assert.deepStrictEqual, Config$AgdaModeVscode.Connection.getAgdaPaths(), configPaths, undefined);
                        if (result.TAG === "Ok") {
                          return Curry._3(Assert.deepStrictEqual, Connection$AgdaModeVscode.getPath(result._0), userAgda.contents, undefined);
                        }
                        Assert.fail("Connection should succeed");
                      }));
                it("should not modify config with mixed working/broken paths", (async function () {
                        var configPaths = [
                          brokenAgda.contents,
                          userAgda.contents,
                          "/another/broken"
                        ];
                        var match = await makeConnection(configPaths, platformWithDiscovery);
                        var result = match[1];
                        Curry._3(Assert.deepStrictEqual, match[0], [], undefined);
                        Curry._3(Assert.deepStrictEqual, Config$AgdaModeVscode.Connection.getAgdaPaths(), configPaths, undefined);
                        if (result.TAG === "Ok") {
                          return Curry._3(Assert.deepStrictEqual, Connection$AgdaModeVscode.getPath(result._0), userAgda.contents, undefined);
                        }
                        Assert.fail("Connection should succeed");
                      }));
              }));
        describe("Broken config paths", (function () {
                it("should add discovered path when all config paths are broken and auto discovery succeeds", (async function () {
                        var configPaths = [
                          brokenAgda.contents,
                          "/another/broken"
                        ];
                        var match = await makeConnection(configPaths, platformWithDiscovery);
                        var result = match[1];
                        var expectedConfig = configPaths.concat([systemAgda.contents]);
                        Curry._3(Assert.deepStrictEqual, match[0], [{
                                TAG: "Config",
                                _0: {
                                  TAG: "Changed",
                                  _0: configPaths,
                                  _1: expectedConfig
                                }
                              }], undefined);
                        Curry._3(Assert.deepStrictEqual, Config$AgdaModeVscode.Connection.getAgdaPaths(), expectedConfig, undefined);
                        if (result.TAG === "Ok") {
                          return Curry._3(Assert.deepStrictEqual, Connection$AgdaModeVscode.getPath(result._0), systemAgda.contents, undefined);
                        }
                        Assert.fail("Connection should succeed");
                      }));
                it("should fail without modifying config when all config paths are broken and auto discovery fails", (async function () {
                        await Config$AgdaModeVscode.Connection.DownloadPolicy.set("No");
                        var configPaths = [
                          brokenAgda.contents,
                          "/another/broken"
                        ];
                        var match = await makeConnection(configPaths, platformNoDiscovery);
                        Curry._3(Assert.deepStrictEqual, match[0], [], undefined);
                        Curry._3(Assert.deepStrictEqual, Config$AgdaModeVscode.Connection.getAgdaPaths(), configPaths, undefined);
                        if (match[1].TAG !== "Ok") {
                          return ;
                        }
                        Assert.fail("Connection should fail when all paths are broken and no discovery");
                      }));
              }));
        describe("Empty config paths", (function () {
                it("should add discovered path when config is empty and auto discovery succeeds", (async function () {
                        var configPaths = [];
                        var match = await makeConnection(configPaths, platformWithDiscovery);
                        var result = match[1];
                        var expectedConfig = [systemAgda.contents];
                        Curry._3(Assert.deepStrictEqual, match[0], [{
                                TAG: "Config",
                                _0: {
                                  TAG: "Changed",
                                  _0: [],
                                  _1: expectedConfig
                                }
                              }], undefined);
                        Curry._3(Assert.deepStrictEqual, Config$AgdaModeVscode.Connection.getAgdaPaths(), expectedConfig, undefined);
                        if (result.TAG === "Ok") {
                          return Curry._3(Assert.deepStrictEqual, Connection$AgdaModeVscode.getPath(result._0), systemAgda.contents, undefined);
                        }
                        Assert.fail("Connection should succeed");
                      }));
                it("should fail without modifying config when config is empty and auto discovery fails", (async function () {
                        await Config$AgdaModeVscode.Connection.DownloadPolicy.set("No");
                        var configPaths = [];
                        var match = await makeConnection(configPaths, platformNoDiscovery);
                        Curry._3(Assert.deepStrictEqual, match[0], [], undefined);
                        Curry._3(Assert.deepStrictEqual, Config$AgdaModeVscode.Connection.getAgdaPaths(), configPaths, undefined);
                        if (match[1].TAG !== "Ok") {
                          return ;
                        }
                        Assert.fail("Connection should fail when config is empty and no discovery");
                      }));
              }));
        describe("UI-triggered additions", (function () {
                var createTestState = function () {
                  var channels_inputMethod = Chan$AgdaModeVscode.make();
                  var channels_responseHandled = Chan$AgdaModeVscode.make();
                  var channels_commandHandled = Chan$AgdaModeVscode.make();
                  var channels = {
                    inputMethod: channels_inputMethod,
                    responseHandled: channels_responseHandled,
                    commandHandled: channels_commandHandled,
                    log: logChannel
                  };
                  var mockEditor = {
        document: { fileName: "test.agda" }
      };
                  var mockUri = Vscode.Uri.file("/test/path");
                  return State$AgdaModeVscode.make(platformWithDiscovery, channels, mockUri, mockUri, Memento$AgdaModeVscode.make(undefined), mockEditor, undefined);
                };
                var setupUITest = async function (initialConfig) {
                  await Config$AgdaModeVscode.Connection.setAgdaPaths(logChannel, initialConfig);
                  var listener = Log$AgdaModeVscode.collect(logChannel);
                  var mockState = createTestState();
                  return [
                          listener,
                          mockState
                        ];
                };
                var executeUITest = async function (mockState, platform, mockSelectedItem) {
                  var view = State__SwitchVersion$AgdaModeVscode.View.make(logChannel);
                  var manager = State__SwitchVersion$AgdaModeVscode.SwitchVersionManager.make(mockState);
                  var onOperationComplete = Log$AgdaModeVscode.on(logChannel, (function (log) {
                          if (log.TAG !== "SwitchVersionUI") {
                            return false;
                          }
                          var tmp = log._0;
                          if (typeof tmp !== "object" && tmp === "SelectionCompleted") {
                            return true;
                          } else {
                            return false;
                          }
                        }));
                  State__SwitchVersion$AgdaModeVscode.Handler.onSelection(mockState, platform, manager, (function (_downloadInfo) {
                          return Promise.resolve();
                        }), view, [mockSelectedItem]);
                  await onOperationComplete;
                  return State__SwitchVersion$AgdaModeVscode.View.destroy(view);
                };
                var simulatePathSelection = async function (initialConfig, selectedPath, descriptionOpt) {
                  var description = descriptionOpt !== undefined ? descriptionOpt : "";
                  var match = await setupUITest(initialConfig);
                  var mockState = match[1];
                  var discoveredEndpoints = {};
                  discoveredEndpoints[selectedPath] = {
                    TAG: "Agda",
                    _0: "2.7.0.1"
                  };
                  await Memento$AgdaModeVscode.Module.Endpoints.syncWithPaths(mockState.memento, discoveredEndpoints);
                  var mockSelectedItem_description = description;
                  var mockSelectedItem_detail = selectedPath;
                  var mockSelectedItem = {
                    description: mockSelectedItem_description,
                    detail: mockSelectedItem_detail,
                    label: "Agda v2.7.0.1"
                  };
                  await executeUITest(mockState, platformWithDiscovery, mockSelectedItem);
                  var logs = match[0](Log$AgdaModeVscode.isConfig);
                  var finalConfig = Config$AgdaModeVscode.Connection.getAgdaPaths();
                  return [
                          logs,
                          finalConfig
                        ];
                };
                var simulateDownloadAction = async function (initialConfig, isAlreadyDownloadedOpt) {
                  var isAlreadyDownloaded = isAlreadyDownloadedOpt !== undefined ? isAlreadyDownloadedOpt : false;
                  var match = await setupUITest(initialConfig);
                  var mockSelectedItem_description = isAlreadyDownloaded ? "Downloaded and installed" : "";
                  var mockSelectedItem_detail = "ALS v0.2.10, Agda v2.7.0.1";
                  var mockSelectedItem = {
                    description: mockSelectedItem_description,
                    detail: mockSelectedItem_detail,
                    label: "$(cloud-download)  Download the latest Agda Language Server"
                  };
                  await executeUITest(match[1], Mock$AgdaModeVscode.Platform.makeWithSuccessfulDownload(downloadedALS.contents), mockSelectedItem);
                  var logs = match[0](Log$AgdaModeVscode.isConfig);
                  var finalConfig = Config$AgdaModeVscode.Connection.getAgdaPaths();
                  return [
                          logs,
                          finalConfig
                        ];
                };
                var simulateOpenFolderAction = async function (initialConfig) {
                  var match = await setupUITest(initialConfig);
                  await executeUITest(match[1], Mock$AgdaModeVscode.Platform.makeBasic(), {
                        description: "Where the language servers are downloaded to",
                        detail: "/tmp/test",
                        label: "$(folder-opened)  Open download folder"
                      });
                  var logs = match[0](Log$AgdaModeVscode.isConfig);
                  var finalConfig = Config$AgdaModeVscode.Connection.getAgdaPaths();
                  return [
                          logs,
                          finalConfig
                        ];
                };
                var simulateEmptySelection = async function (initialConfig) {
                  var match = await setupUITest(initialConfig);
                  var mockState = match[1];
                  var view = State__SwitchVersion$AgdaModeVscode.View.make(logChannel);
                  var manager = State__SwitchVersion$AgdaModeVscode.SwitchVersionManager.make(mockState);
                  var onOperationComplete = Log$AgdaModeVscode.on(logChannel, (function (log) {
                          if (log.TAG !== "SwitchVersionUI") {
                            return false;
                          }
                          var tmp = log._0;
                          if (typeof tmp !== "object" && tmp === "SelectionCompleted") {
                            return true;
                          } else {
                            return false;
                          }
                        }));
                  State__SwitchVersion$AgdaModeVscode.Handler.onSelection(mockState, platformWithDiscovery, manager, (function (_downloadInfo) {
                          return Promise.resolve();
                        }), view, []);
                  await onOperationComplete;
                  State__SwitchVersion$AgdaModeVscode.View.destroy(view);
                  var logs = match[0](Log$AgdaModeVscode.isConfig);
                  var finalConfig = Config$AgdaModeVscode.Connection.getAgdaPaths();
                  return [
                          logs,
                          finalConfig
                        ];
                };
                describe("Switch version UI selection", (function () {
                        it("should add path to config when user selects existing path not in config", (async function () {
                                var initialConfig = [userAgda.contents];
                                var selectedPath = alternativeAgda.contents;
                                var match = await simulatePathSelection(initialConfig, selectedPath, "");
                                var expectedConfig = initialConfig.concat([selectedPath]);
                                Curry._3(Assert.deepStrictEqual, match[0], [{
                                        TAG: "Config",
                                        _0: {
                                          TAG: "Changed",
                                          _0: initialConfig,
                                          _1: expectedConfig
                                        }
                                      }], undefined);
                                return Curry._3(Assert.deepStrictEqual, match[1], expectedConfig, undefined);
                              }));
                        it("should not modify config when user selects path already in config", (async function () {
                                var initialConfig = [
                                  userAgda.contents,
                                  alternativeAgda.contents
                                ];
                                var selectedPath = userAgda.contents;
                                var match = await simulatePathSelection(initialConfig, selectedPath, "Selected");
                                Curry._3(Assert.deepStrictEqual, match[0], [], undefined);
                                return Curry._3(Assert.deepStrictEqual, match[1], initialConfig, undefined);
                              }));
                        it("should add new path to config when user selects different path", (async function () {
                                var initialConfig = [userAgda.contents];
                                var selectedPath = alternativeAgda.contents;
                                var match = await simulatePathSelection(initialConfig, selectedPath, "");
                                var expectedConfig = initialConfig.concat([selectedPath]);
                                Curry._3(Assert.deepStrictEqual, match[0], [{
                                        TAG: "Config",
                                        _0: {
                                          TAG: "Changed",
                                          _0: initialConfig,
                                          _1: expectedConfig
                                        }
                                      }], undefined);
                                return Curry._3(Assert.deepStrictEqual, match[1], expectedConfig, undefined);
                              }));
                      }));
                describe("Download action selection", (function () {
                        it("should add downloaded path to config when user downloads new ALS", (async function () {
                                var initialConfig = [userAgda.contents];
                                var match = await simulateDownloadAction(initialConfig, false);
                                var expectedConfig = initialConfig.concat([downloadedALS.contents]);
                                Curry._3(Assert.deepStrictEqual, match[0], [{
                                        TAG: "Config",
                                        _0: {
                                          TAG: "Changed",
                                          _0: initialConfig,
                                          _1: expectedConfig
                                        }
                                      }], undefined);
                                return Curry._3(Assert.deepStrictEqual, match[1], expectedConfig, undefined);
                              }));
                        it("should add already downloaded path to config when user selects already downloaded ALS", (async function () {
                                var initialConfig = [userAgda.contents];
                                var match = await simulateDownloadAction(initialConfig, true);
                                var expectedConfig = initialConfig.concat([downloadedALS.contents]);
                                Curry._3(Assert.deepStrictEqual, match[0], [{
                                        TAG: "Config",
                                        _0: {
                                          TAG: "Changed",
                                          _0: initialConfig,
                                          _1: expectedConfig
                                        }
                                      }], undefined);
                                return Curry._3(Assert.deepStrictEqual, match[1], expectedConfig, undefined);
                              }));
                      }));
                describe("Non-endpoint selections", (function () {
                        it("should not modify config when user selects open folder action", (async function () {
                                var initialConfig = [userAgda.contents];
                                var match = await simulateOpenFolderAction(initialConfig);
                                Curry._3(Assert.deepStrictEqual, match[0], [], undefined);
                                return Curry._3(Assert.deepStrictEqual, match[1], initialConfig, undefined);
                              }));
                        it("should handle empty selection correctly", (async function () {
                                var initialConfig = [userAgda.contents];
                                var match = await simulateEmptySelection(initialConfig);
                                Curry._3(Assert.deepStrictEqual, match[0], [], undefined);
                                return Curry._3(Assert.deepStrictEqual, match[1], initialConfig, undefined);
                              }));
                      }));
              }));
      }));

/*  Not a pure module */
