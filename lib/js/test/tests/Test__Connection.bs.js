// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Caml = require("rescript/lib/js/caml.js");
var Curry = require("rescript/lib/js/curry.js");
var Assert = require("assert");
var Vscode = require("vscode");
var Js_dict = require("rescript/lib/js/js_dict.js");
var Nodefs = require("node:fs");
var Nodeos = require("node:os");
var Nodepath = require("node:path");
var PervasivesU = require("rescript/lib/js/pervasivesU.js");
var Core__Option = require("@rescript/core/lib/js/src/Core__Option.bs.js");
var OS$AgdaModeVscode = require("../../src/Util/OS.bs.js");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");
var Log$AgdaModeVscode = require("../../src/State/Log.bs.js");
var Chan$AgdaModeVscode = require("../../src/Util/Chan.bs.js");
var Mock$AgdaModeVscode = require("../../src/Main/Mock.bs.js");
var Config$AgdaModeVscode = require("../../src/Config.bs.js");
var Desktop$AgdaModeVscode = require("../../src/Main/Desktop.bs.js");
var Memento$AgdaModeVscode = require("../../src/Memento.bs.js");
var Connection$AgdaModeVscode = require("../../src/Connection/Connection.bs.js");
var Test__Util$AgdaModeVscode = require("./Test__Util.bs.js");
var Connection__URI$AgdaModeVscode = require("../../src/Connection/Shared/Connection__URI.bs.js");
var Connection__Error$AgdaModeVscode = require("../../src/Connection/Shared/Connection__Error.bs.js");
var Connection__Command$AgdaModeVscode = require("../../src/Connection/Resolver/Connection__Command.bs.js");

async function getAgdaTarget() {
  var platformDeps = Desktop$AgdaModeVscode.make();
  var connection = await Connection$AgdaModeVscode.fromCommands(platformDeps, ["agda"]);
  if (connection.TAG === "Ok") {
    return connection._0;
  } else {
    return PervasivesU.failwith("expected to find `agda`");
  }
}

describe("Connection", (function () {
        this.timeout(10000);
        describe("Target", (function () {
                var agdaMockPath = {
                  contents: ""
                };
                var agdaMockEndpoint = {
                  contents: undefined
                };
                before(async function () {
                      agdaMockPath.contents = await Test__Util$AgdaModeVscode.Endpoint.Agda.mock("2.7.0.1", "agda-mock");
                      agdaMockEndpoint.contents = agdaMockPath.contents;
                    });
                after(async function () {
                      var target = agdaMockEndpoint.contents;
                      if (target !== undefined) {
                        await Test__Util$AgdaModeVscode.Endpoint.Agda.destroy(target);
                        agdaMockEndpoint.contents = undefined;
                        return ;
                      }
                      
                    });
              }));
        describe("Command searching", (function () {
                it("should return an error when the command is not found", (async function () {
                        var _output = await Connection__Command$AgdaModeVscode.search("non-existent-command", undefined);
                        if (_output.TAG === "Ok") {
                          return PervasivesU.failwith("expected to not find `non-existent-command`");
                        }
                        
                      }));
              }));
        describe("checkForPrebuiltDataDirectory", (function () {
                it("should return asset path when data directory exists", (async function () {
                        var tempDir = Nodepath.join(Nodeos.tmpdir(), "agda-test-" + String(Date.now() | 0));
                        var execPath = Nodepath.join(tempDir, "bin", "agda-language-server");
                        var dataDir = Nodepath.join(tempDir, "bin", "data");
                        await Nodefs.promises.mkdir(Nodepath.join(tempDir, "bin"), {
                              recursive: true,
                              mode: 511
                            });
                        await Nodefs.promises.mkdir(dataDir, {
                              recursive: true,
                              mode: 511
                            });
                        var result = await Connection$AgdaModeVscode.checkForPrebuiltDataDirectory(execPath);
                        var expectedAssetPath = Nodepath.join(execPath, "..", "data");
                        Curry._3(Assert.deepStrictEqual, result, expectedAssetPath, undefined);
                        Nodefs.rmdirSync(dataDir);
                        Nodefs.rmdirSync(Nodepath.join(tempDir, "bin"));
                        Nodefs.rmdirSync(tempDir);
                      }));
                it("should return None when data directory does not exist", (async function () {
                        var tempDir = Nodepath.join(Nodeos.tmpdir(), "agda-test-" + String(Date.now() | 0));
                        var execPath = Nodepath.join(tempDir, "bin", "agda-language-server");
                        await Nodefs.promises.mkdir(Nodepath.join(tempDir, "bin"), {
                              recursive: true,
                              mode: 511
                            });
                        var result = await Connection$AgdaModeVscode.checkForPrebuiltDataDirectory(execPath);
                        Curry._3(Assert.deepStrictEqual, result, undefined, undefined);
                        Nodefs.rmdirSync(Nodepath.join(tempDir, "bin"));
                        Nodefs.rmdirSync(tempDir);
                      }));
              }));
        describe("`probeFilepath`", (function () {
                var agdaMockPath = {
                  contents: ""
                };
                var alsMockPath = {
                  contents: ""
                };
                before(async function () {
                      agdaMockPath.contents = await Test__Util$AgdaModeVscode.Endpoint.Agda.mock("2.6.4.1", "agda-probe-mock");
                      alsMockPath.contents = await Test__Util$AgdaModeVscode.Endpoint.ALS.mock("1.2.3", "2.6.4", "als-probe-mock");
                    });
                after(async function () {
                      if (agdaMockPath.contents !== "") {
                        await Test__Util$AgdaModeVscode.Endpoint.Agda.destroy(agdaMockPath.contents);
                      }
                      if (alsMockPath.contents !== "") {
                        return await Test__Util$AgdaModeVscode.Endpoint.ALS.destroy(alsMockPath.contents);
                      }
                      
                    });
                it("should correctly identify Agda executable", (async function () {
                        var result = await Connection$AgdaModeVscode.probeFilepath(agdaMockPath.contents);
                        if (result.TAG === "Ok") {
                          var match = result._0;
                          var version = match[1];
                          switch (version.TAG) {
                            case "IsAgda" :
                                Curry._3(Assert.deepStrictEqual, match[0], agdaMockPath.contents, undefined);
                                return Curry._3(Assert.deepStrictEqual, version._0, "2.6.4.1", undefined);
                            case "IsALS" :
                            case "IsALSOfUnknownVersion" :
                                Assert.fail("Expected Agda result, got ALS");
                                return ;
                            
                          }
                        } else {
                          Assert.fail("Expected successful probe of Agda mock");
                          return ;
                        }
                      }));
                it("should correctly identify ALS executable", (async function () {
                        var result = await Connection$AgdaModeVscode.probeFilepath(alsMockPath.contents);
                        if (result.TAG === "Ok") {
                          var match = result._0;
                          var match$1 = match[1];
                          switch (match$1.TAG) {
                            case "IsAgda" :
                                Assert.fail("Expected ALS result, got Agda");
                                return ;
                            case "IsALS" :
                                Curry._3(Assert.deepStrictEqual, match[0], alsMockPath.contents, undefined);
                                Curry._3(Assert.deepStrictEqual, match$1._0, "1.2.3", undefined);
                                Curry._3(Assert.deepStrictEqual, match$1._1, "2.6.4", undefined);
                                return Curry._3(Assert.deepStrictEqual, match$1._2, undefined, undefined);
                            case "IsALSOfUnknownVersion" :
                                Assert.fail("Expected ALS with known versions");
                                return ;
                            
                          }
                        } else {
                          Assert.fail("Expected successful probe of ALS mock");
                          return ;
                        }
                      }));
                it("should return NotAgdaOrALS error for unrecognized executable", (async function () {
                        var mockOutput = "Some other program version 1.0";
                        var mockPath;
                        if (OS$AgdaModeVscode.onUnix) {
                          var content = "#!/bin/sh\necho '" + mockOutput + "'\nexit 0";
                          var tempFile = Nodepath.join(Nodeos.tmpdir(), "unrecognized-mock");
                          Nodefs.writeFileSync(tempFile, Buffer.from(content));
                          await Nodefs.promises.chmod(tempFile, 493);
                          mockPath = tempFile;
                        } else {
                          var content$1 = "@echo " + mockOutput;
                          var tempFile$1 = Nodepath.join(Nodeos.tmpdir(), "unrecognized-mock.bat");
                          Nodefs.writeFileSync(tempFile$1, Buffer.from(content$1));
                          mockPath = tempFile$1;
                        }
                        var result = await Connection$AgdaModeVscode.probeFilepath(mockPath);
                        if (result.TAG === "Ok") {
                          Assert.fail("Expected NotAgdaOrALS error");
                        } else {
                          var output = result._0;
                          if (typeof output !== "object" || output.TAG !== "NotAgdaOrALS") {
                            Assert.fail("Expected NotAgdaOrALS error, got different error");
                          } else {
                            Curry._3(Assert.deepStrictEqual, output._0.trim(), mockOutput, undefined);
                          }
                        }
                        try {
                          Nodefs.unlinkSync(mockPath);
                          return ;
                        }
                        catch (exn){
                          return ;
                        }
                      }));
                it("should return CannotDetermineAgdaOrALS error for non-executable file", (async function () {
                        var nonExecutablePath = Nodepath.join(Nodeos.tmpdir(), "non-executable.txt");
                        Nodefs.writeFileSync(nonExecutablePath, Buffer.from("not executable"));
                        var result = await Connection$AgdaModeVscode.probeFilepath(nonExecutablePath);
                        if (result.TAG === "Ok") {
                          Assert.fail("Expected CannotDetermineAgdaOrALS error");
                        } else {
                          var tmp = result._0;
                          if (typeof tmp !== "object" || tmp.TAG !== "CannotDetermineAgdaOrALS") {
                            Assert.fail("Expected CannotDetermineAgdaOrALS error, got different error");
                          }
                          
                        }
                        try {
                          Nodefs.unlinkSync(nonExecutablePath);
                          return ;
                        }
                        catch (exn){
                          return ;
                        }
                      }));
                it("should return CannotDetermineAgdaOrALS error for non-existent file", (async function () {
                        var result = await Connection$AgdaModeVscode.probeFilepath("/path/that/does/not/exist/executable");
                        if (result.TAG === "Ok") {
                          Assert.fail("Expected CannotDetermineAgdaOrALS error");
                          return ;
                        }
                        var tmp = result._0;
                        if (typeof tmp !== "object") {
                          Assert.fail("Expected CannotDetermineAgdaOrALS error, got different error");
                          return ;
                        }
                        if (tmp.TAG === "CannotDetermineAgdaOrALS") {
                          return ;
                        }
                        Assert.fail("Expected CannotDetermineAgdaOrALS error, got different error");
                      }));
                it("should detect prebuilt data directory for ALS with LSP options", (async function () {
                        var tempDir = Nodepath.join(Nodeos.tmpdir(), "als-data-test-" + String(Date.now() | 0));
                        var binDir = Nodepath.join(tempDir, "bin");
                        var dataDir = Nodepath.join(binDir, "data");
                        var alsPath = Nodepath.join(binDir, "als-with-data");
                        await Nodefs.promises.mkdir(binDir, {
                              recursive: true,
                              mode: 511
                            });
                        await Nodefs.promises.mkdir(dataDir, {
                              recursive: true,
                              mode: 511
                            });
                        var alsOutput = "Agda v2.6.4 Language Server v1.2.3";
                        var match = OS$AgdaModeVscode.onUnix ? [
                            alsPath,
                            "#!/bin/sh\necho '" + alsOutput + "'\nexit 0"
                          ] : [
                            alsPath + ".bat",
                            "@echo " + alsOutput
                          ];
                        var fileName = match[0];
                        Nodefs.writeFileSync(fileName, Buffer.from(match[1]));
                        if (OS$AgdaModeVscode.onUnix) {
                          await Nodefs.promises.chmod(fileName, 493);
                        }
                        var result = await Connection$AgdaModeVscode.probeFilepath(fileName);
                        var match$1 = Connection__URI$AgdaModeVscode.parse(fileName);
                        var normalizedFileName;
                        normalizedFileName = match$1.TAG === "FileURI" ? match$1._1.fsPath : fileName;
                        if (result.TAG === "Ok") {
                          var match$2 = result._0;
                          var match$3 = match$2[1];
                          switch (match$3.TAG) {
                            case "IsAgda" :
                                Assert.fail("Expected ALS result, got Agda");
                                break;
                            case "IsALS" :
                                var lspOptions = match$3._2;
                                if (lspOptions !== undefined) {
                                  Curry._3(Assert.deepStrictEqual, match$2[0], normalizedFileName, undefined);
                                  Curry._3(Assert.deepStrictEqual, match$3._0, "1.2.3", undefined);
                                  Curry._3(Assert.deepStrictEqual, match$3._1, "2.6.4", undefined);
                                  var dataDirPath = Core__Option.flatMap(lspOptions.env, (function (__x) {
                                          return Js_dict.get(__x, "Agda_datadir");
                                        }));
                                  if (dataDirPath !== undefined) {
                                    Assert.ok(dataDirPath.includes("data"));
                                  } else {
                                    Assert.fail("Expected Agda_datadir in LSP options");
                                  }
                                } else {
                                  Assert.fail("Expected LSP options with data directory");
                                }
                                break;
                            case "IsALSOfUnknownVersion" :
                                Assert.fail("Expected ALS with known versions");
                                break;
                            
                          }
                        } else {
                          Assert.fail("Expected successful probe of ALS with data directory");
                        }
                        try {
                          Nodefs.unlinkSync(fileName);
                          Nodefs.rmdirSync(dataDir);
                          Nodefs.rmdirSync(binDir);
                          Nodefs.rmdirSync(tempDir);
                          return ;
                        }
                        catch (exn){
                          return ;
                        }
                      }));
              }));
        describe("`make`", (function () {
                var agdaMockPath = {
                  contents: ""
                };
                var alsMockPath = {
                  contents: ""
                };
                before(async function () {
                      agdaMockPath.contents = await Test__Util$AgdaModeVscode.Endpoint.Agda.mock("2.6.3", "agda-make-mock");
                      alsMockPath.contents = await Test__Util$AgdaModeVscode.Endpoint.ALS.mock("1.3.1", "2.6.3", "als-make-mock");
                    });
                after(async function () {
                      if (agdaMockPath.contents !== "") {
                        await Test__Util$AgdaModeVscode.Endpoint.Agda.destroy(agdaMockPath.contents);
                      }
                      if (alsMockPath.contents !== "") {
                        return await Test__Util$AgdaModeVscode.Endpoint.ALS.destroy(alsMockPath.contents);
                      }
                      
                    });
                it("should successfully create Agda connection from valid Agda path", (async function () {
                        var result = await Connection$AgdaModeVscode.make(agdaMockPath.contents);
                        if (result.TAG === "Ok") {
                          var connection = result._0;
                          if (connection.TAG === "Agda") {
                            Curry._3(Assert.deepStrictEqual, connection._1, agdaMockPath.contents, undefined);
                            return Curry._3(Assert.deepStrictEqual, connection._2, "2.6.3", undefined);
                          }
                          Assert.fail("Expected Agda connection, got ALS");
                          return ;
                        }
                        Assert.fail("Expected successful connection creation");
                      }));
                it("should handle ALS executable probing (without full connection)", (async function () {
                        var result = await Connection$AgdaModeVscode.probeFilepath(alsMockPath.contents);
                        if (result.TAG === "Ok") {
                          var match = result._0;
                          var match$1 = match[1];
                          switch (match$1.TAG) {
                            case "IsAgda" :
                                Assert.fail("Expected ALS result, got Agda");
                                return ;
                            case "IsALS" :
                                Curry._3(Assert.deepStrictEqual, match[0], alsMockPath.contents, undefined);
                                Curry._3(Assert.deepStrictEqual, match$1._0, "1.3.1", undefined);
                                Curry._3(Assert.deepStrictEqual, match$1._1, "2.6.3", undefined);
                                return Curry._3(Assert.deepStrictEqual, match$1._2, undefined, undefined);
                            case "IsALSOfUnknownVersion" :
                                Assert.fail("Expected ALS with known versions");
                                return ;
                            
                          }
                        } else {
                          Assert.fail("Expected successful probe");
                          return ;
                        }
                      }));
                it("should return Establish error for non-existent path", (async function () {
                        var nonExistentPath = "/path/that/does/not/exist/agda";
                        var result = await Connection$AgdaModeVscode.make(nonExistentPath);
                        if (result.TAG === "Ok") {
                          Assert.fail("Expected error for non-existent path");
                          return ;
                        }
                        var error = result._0.probes[nonExistentPath];
                        if (error !== undefined) {
                          if (typeof error !== "object") {
                            Assert.fail("Expected CannotDetermineAgdaOrALS error");
                            return ;
                          }
                          if (error.TAG === "CannotDetermineAgdaOrALS") {
                            return ;
                          }
                          Assert.fail("Expected CannotDetermineAgdaOrALS error");
                          return ;
                        } else {
                          Assert.fail("Expected probe error for non-existent path");
                          return ;
                        }
                      }));
                it("should return Establish error for unrecognized executable", (async function () {
                        var mockOutput = "Unknown Program v1.0.0";
                        var mockPath;
                        if (OS$AgdaModeVscode.onUnix) {
                          var content = "#!/bin/sh\necho '" + mockOutput + "'\nexit 0";
                          var tempFile = Nodepath.join(Nodeos.tmpdir(), "unrecognized-make-mock");
                          Nodefs.writeFileSync(tempFile, Buffer.from(content));
                          await Nodefs.promises.chmod(tempFile, 493);
                          mockPath = tempFile;
                        } else {
                          var content$1 = "@echo " + mockOutput;
                          var tempFile$1 = Nodepath.join(Nodeos.tmpdir(), "unrecognized-make-mock.bat");
                          Nodefs.writeFileSync(tempFile$1, Buffer.from(content$1));
                          mockPath = tempFile$1;
                        }
                        var result = await Connection$AgdaModeVscode.make(mockPath);
                        if (result.TAG === "Ok") {
                          Assert.fail("Expected error for unrecognized executable");
                        } else {
                          var error = result._0.probes[mockPath];
                          if (error !== undefined) {
                            if (typeof error !== "object" || error.TAG !== "NotAgdaOrALS") {
                              Assert.fail("Expected NotAgdaOrALS error");
                            } else {
                              Curry._3(Assert.deepStrictEqual, error._0.trim(), mockOutput, undefined);
                            }
                          } else {
                            Assert.fail("Expected probe error for unrecognized executable");
                          }
                        }
                        try {
                          Nodefs.unlinkSync(mockPath);
                          return ;
                        }
                        catch (exn){
                          return ;
                        }
                      }));
                it("should detect prebuilt data directory correctly in probing phase", (async function () {
                        var tempDir = Nodepath.join(Nodeos.tmpdir(), "als-probe-data-test-" + String(Date.now() | 0));
                        var binDir = Nodepath.join(tempDir, "bin");
                        var dataDir = Nodepath.join(binDir, "data");
                        var alsPath = Nodepath.join(binDir, "als-with-data-probe-test");
                        await Nodefs.promises.mkdir(binDir, {
                              recursive: true,
                              mode: 511
                            });
                        await Nodefs.promises.mkdir(dataDir, {
                              recursive: true,
                              mode: 511
                            });
                        var alsOutput = "Agda v2.6.3 Language Server v1.3.1";
                        var match = OS$AgdaModeVscode.onUnix ? [
                            alsPath,
                            "#!/bin/sh\necho '" + alsOutput + "'\nexit 0"
                          ] : [
                            alsPath + ".bat",
                            "@echo " + alsOutput
                          ];
                        var fileName = match[0];
                        Nodefs.writeFileSync(fileName, Buffer.from(match[1]));
                        if (OS$AgdaModeVscode.onUnix) {
                          await Nodefs.promises.chmod(fileName, 493);
                        }
                        var result = await Connection$AgdaModeVscode.probeFilepath(fileName);
                        var match$1 = Connection__URI$AgdaModeVscode.parse(fileName);
                        var normalizedFileName;
                        normalizedFileName = match$1.TAG === "FileURI" ? match$1._1.fsPath : fileName;
                        if (result.TAG === "Ok") {
                          var match$2 = result._0;
                          var match$3 = match$2[1];
                          switch (match$3.TAG) {
                            case "IsAgda" :
                                Assert.fail("Expected ALS result, got Agda");
                                break;
                            case "IsALS" :
                                var lspOptions = match$3._2;
                                if (lspOptions !== undefined) {
                                  Curry._3(Assert.deepStrictEqual, match$2[0], normalizedFileName, undefined);
                                  Curry._3(Assert.deepStrictEqual, match$3._0, "1.3.1", undefined);
                                  Curry._3(Assert.deepStrictEqual, match$3._1, "2.6.3", undefined);
                                  var dataDirPath = Core__Option.flatMap(lspOptions.env, (function (__x) {
                                          return Js_dict.get(__x, "Agda_datadir");
                                        }));
                                  if (dataDirPath !== undefined) {
                                    Assert.ok(dataDirPath.includes("data"));
                                  } else {
                                    Assert.fail("Expected Agda_datadir in LSP options");
                                  }
                                } else {
                                  Assert.fail("Expected LSP options with data directory");
                                }
                                break;
                            case "IsALSOfUnknownVersion" :
                                Assert.fail("Expected ALS with known versions");
                                break;
                            
                          }
                        } else {
                          Assert.fail("Expected successful probe with data directory");
                        }
                        try {
                          Nodefs.unlinkSync(fileName);
                          Nodefs.rmdirSync(dataDir);
                          Nodefs.rmdirSync(binDir);
                          Nodefs.rmdirSync(tempDir);
                          return ;
                        }
                        catch (exn){
                          return ;
                        }
                      }));
                it("should handle error construction correctly for probe errors", (async function () {
                        var invalidPath = "/definitely/does/not/exist/agda";
                        var result = await Connection$AgdaModeVscode.make(invalidPath);
                        if (result.TAG === "Ok") {
                          Assert.fail("Expected construction error");
                          return ;
                        }
                        var errors = result._0;
                        Curry._3(Assert.deepStrictEqual, Object.entries(errors.probes).length, 1, undefined);
                        Curry._3(Assert.deepStrictEqual, Object.entries(errors.commands).length, 0, undefined);
                        Curry._3(Assert.deepStrictEqual, errors.download, undefined, undefined);
                        var match = errors.probes[invalidPath];
                        if (match !== undefined) {
                          if (typeof match !== "object") {
                            Assert.fail("Expected CannotDetermineAgdaOrALS error");
                            return ;
                          }
                          if (match.TAG === "CannotDetermineAgdaOrALS") {
                            return ;
                          }
                          Assert.fail("Expected CannotDetermineAgdaOrALS error");
                          return ;
                        } else {
                          Assert.fail("Expected probe error to be present");
                          return ;
                        }
                      }));
              }));
        describe("`fromDownloads`", (function () {
                var agdaMockEndpoint = {
                  contents: undefined
                };
                before(async function () {
                      try {
                        var path = await Test__Util$AgdaModeVscode.Endpoint.Agda.mock("2.7.0.1", "agda-mock-2");
                        agdaMockEndpoint.contents = path;
                        return ;
                      }
                      catch (raw_msg){
                        var msg = Caml_js_exceptions.internalToOCamlException(raw_msg);
                        if (msg.RE_EXN_ID === "Failure") {
                          return PervasivesU.failwith(msg._1);
                        } else {
                          return PervasivesU.failwith("Got error when trying to construct target from mock Agda: unknown error");
                        }
                      }
                    });
                after(async function () {
                      await Config$AgdaModeVscode.Connection.setAgdaPaths(Chan$AgdaModeVscode.make(), []);
                      await Memento$AgdaModeVscode.Module.PickedConnection.set(Memento$AgdaModeVscode.make(undefined), undefined);
                      var target = agdaMockEndpoint.contents;
                      if (target !== undefined) {
                        await Test__Util$AgdaModeVscode.Endpoint.Agda.destroy(target);
                        agdaMockEndpoint.contents = undefined;
                        return ;
                      }
                      
                    });
                it("should throw the `PlatformNotSupported` error when the platform is not supported", (async function () {
                        var platform = {
                          os: "non-existent-os",
                          dist: "non-existent-dist",
                          codename: "non-existent-codename",
                          release: "non-existent-release"
                        };
                        var mockPlatformDeps = Mock$AgdaModeVscode.Platform.makeWithPlatformError(platform);
                        var memento = Memento$AgdaModeVscode.make(undefined);
                        var globalStorageUri = Vscode.Uri.file("/tmp/test-storage");
                        var actual = await Connection$AgdaModeVscode.fromDownloads(mockPlatformDeps, memento, globalStorageUri);
                        var expected = Connection__Error$AgdaModeVscode.Establish.fromDownloadError({
                              TAG: "PlatformNotSupported",
                              _0: platform
                            });
                        return Curry._3(Assert.deepStrictEqual, actual, {
                                    TAG: "Error",
                                    _0: expected
                                  }, undefined);
                      }));
                it("should throw the `NoDownloadALS` error when the initial download policy is `No`", (async function () {
                        await Config$AgdaModeVscode.Connection.DownloadPolicy.set("No");
                        var getDownloadPolicyCount = {
                          contents: 0
                        };
                        var mockPlatformDeps = Mock$AgdaModeVscode.Platform.makeWithDownloadPolicyCounter("No", getDownloadPolicyCount);
                        var memento = Memento$AgdaModeVscode.make(undefined);
                        var globalStorageUri = Vscode.Uri.file("/tmp/test-storage");
                        var result = await Connection$AgdaModeVscode.fromDownloads(mockPlatformDeps, memento, globalStorageUri);
                        Curry._3(Assert.deepStrictEqual, result, {
                              TAG: "Error",
                              _0: Connection__Error$AgdaModeVscode.Establish.fromDownloadError("OptedNotToDownload")
                            }, undefined);
                        var policy = Config$AgdaModeVscode.Connection.DownloadPolicy.get();
                        Curry._3(Assert.deepStrictEqual, policy, "No", undefined);
                        return Curry._3(Assert.deepStrictEqual, getDownloadPolicyCount.contents, 0, undefined);
                      }));
                it("should throw the `NoDownloadALS` error when the user clicked `cancel` on the download dialog", (async function () {
                        await Config$AgdaModeVscode.Connection.DownloadPolicy.set("Undecided");
                        var getDownloadPolicyCount = {
                          contents: 0
                        };
                        var mockPlatformDeps = Mock$AgdaModeVscode.Platform.makeWithDownloadPolicyCounter("Undecided", getDownloadPolicyCount);
                        var memento = Memento$AgdaModeVscode.make(undefined);
                        var globalStorageUri = Vscode.Uri.file("/tmp/test-storage");
                        var result = await Connection$AgdaModeVscode.fromDownloads(mockPlatformDeps, memento, globalStorageUri);
                        Curry._3(Assert.deepStrictEqual, result, {
                              TAG: "Error",
                              _0: Connection__Error$AgdaModeVscode.Establish.fromDownloadError("OptedNotToDownload")
                            }, undefined);
                        var policy = Config$AgdaModeVscode.Connection.DownloadPolicy.get();
                        Curry._3(Assert.deepStrictEqual, policy, "No", undefined);
                        return Curry._3(Assert.deepStrictEqual, getDownloadPolicyCount.contents, 1, undefined);
                      }));
                it("should check if the latest ALS is already downloaded when the download policy is `Yes`", (async function () {
                        var endpoint = agdaMockEndpoint.contents;
                        var mockEndpoint = endpoint !== undefined ? endpoint : PervasivesU.failwith("Unable to access the Agda mock endpoint");
                        await Config$AgdaModeVscode.Connection.DownloadPolicy.set("Undecided");
                        var checkedCache = {
                          contents: false
                        };
                        var mockPlatformDeps = Mock$AgdaModeVscode.Platform.makeWithCachedDownloadAndFlag(mockEndpoint, checkedCache);
                        var memento = Memento$AgdaModeVscode.make(undefined);
                        var globalStorageUri = Vscode.Uri.file("/tmp/test-storage");
                        var result = await Connection$AgdaModeVscode.fromDownloads(mockPlatformDeps, memento, globalStorageUri);
                        Curry._3(Assert.deepStrictEqual, checkedCache.contents, true, undefined);
                        if (result.TAG === "Ok") {
                          var connection = result._0;
                          if (connection.TAG === "Agda") {
                            Curry._3(Assert.deepStrictEqual, connection._2, "2.7.0.1", undefined);
                            Curry._3(Assert.deepStrictEqual, connection._1, mockEndpoint, undefined);
                          } else {
                            Assert.fail("Expected Agda connection");
                          }
                        } else {
                          Assert.fail("Expected successful cached download");
                        }
                        var policy = Config$AgdaModeVscode.Connection.DownloadPolicy.get();
                        return Curry._3(Assert.deepStrictEqual, policy, "Yes", undefined);
                      }));
                it("should throw the `DownloadALS` error when the download policy is `Yes` but the download fails", (async function () {
                        await Config$AgdaModeVscode.Connection.DownloadPolicy.set("Undecided");
                        var checkedCache = {
                          contents: false
                        };
                        var checkedDownload = {
                          contents: false
                        };
                        var mockPlatformDeps = Mock$AgdaModeVscode.Platform.makeWithDownloadFailureAndFlags(checkedCache, checkedDownload);
                        var memento = Memento$AgdaModeVscode.make(undefined);
                        var globalStorageUri = Vscode.Uri.file("/tmp/test-storage");
                        var result = await Connection$AgdaModeVscode.fromDownloads(mockPlatformDeps, memento, globalStorageUri);
                        Curry._3(Assert.deepStrictEqual, checkedCache.contents, true, undefined);
                        Curry._3(Assert.deepStrictEqual, checkedDownload.contents, true, undefined);
                        var expected = Connection__Error$AgdaModeVscode.Establish.fromDownloadError("CannotFindCompatibleALSRelease");
                        Curry._3(Assert.deepStrictEqual, result, {
                              TAG: "Error",
                              _0: expected
                            }, undefined);
                        var policy = Config$AgdaModeVscode.Connection.DownloadPolicy.get();
                        return Curry._3(Assert.deepStrictEqual, policy, "Yes", undefined);
                      }));
              }));
        describe("`fromPaths`", (function () {
                var agdaMockEndpoint = {
                  contents: undefined
                };
                before(async function () {
                      try {
                        var path = await Test__Util$AgdaModeVscode.Endpoint.Agda.mock("2.7.0.1", "agda-mock-paths");
                        agdaMockEndpoint.contents = path;
                        return ;
                      }
                      catch (raw_error){
                        var error = Caml_js_exceptions.internalToOCamlException(raw_error);
                        return PervasivesU.failwith("Failed to create Agda mock: " + String(error));
                      }
                    });
                after(async function () {
                      var path = agdaMockEndpoint.contents;
                      if (path === undefined) {
                        return ;
                      }
                      try {
                        Nodefs.unlinkSync(path);
                        return ;
                      }
                      catch (exn){
                        return ;
                      }
                    });
                it("should connect successfully with valid path", (async function () {
                        var path = agdaMockEndpoint.contents;
                        var mockPath = path !== undefined ? path : PervasivesU.failwith("Mock endpoint not available");
                        var platformDeps = Mock$AgdaModeVscode.Platform.makeBasic();
                        var paths = [mockPath];
                        var result = await Connection$AgdaModeVscode.fromPaths(platformDeps, paths);
                        if (result.TAG === "Ok") {
                          var connection = result._0;
                          if (connection.TAG === "Agda") {
                            Curry._3(Assert.deepStrictEqual, connection._1, mockPath, undefined);
                            return Curry._3(Assert.deepStrictEqual, connection._2, "2.7.0.1", undefined);
                          }
                          Assert.fail("Expected Agda connection");
                          return ;
                        }
                        Assert.fail("Expected successful connection");
                      }));
                it("should try multiple paths and use first valid one", (async function () {
                        var path = agdaMockEndpoint.contents;
                        var mockPath = path !== undefined ? path : PervasivesU.failwith("Mock endpoint not available");
                        var platformDeps = Mock$AgdaModeVscode.Platform.makeBasic();
                        var paths = [
                          "invalid/path/1",
                          "invalid/path/2",
                          mockPath,
                          "invalid/path/3"
                        ];
                        var result = await Connection$AgdaModeVscode.fromPaths(platformDeps, paths);
                        if (result.TAG === "Ok") {
                          var connection = result._0;
                          if (connection.TAG === "Agda") {
                            Curry._3(Assert.deepStrictEqual, connection._1, mockPath, undefined);
                            return Curry._3(Assert.deepStrictEqual, connection._2, "2.7.0.1", undefined);
                          }
                          Assert.fail("Expected Agda connection");
                          return ;
                        }
                        Assert.fail("Expected successful connection to first valid path");
                      }));
                it("should return Construction error when all paths are invalid", (async function () {
                        var platformDeps = Mock$AgdaModeVscode.Platform.makeBasic();
                        var paths = [
                          "invalid/path/1",
                          "invalid/path/2",
                          "invalid/path/3"
                        ];
                        var result = await Connection$AgdaModeVscode.fromPaths(platformDeps, paths);
                        if (result.TAG === "Ok") {
                          Assert.fail("Expected error with invalid paths");
                          return ;
                        }
                        var errors = result._0;
                        var probeErrors = Object.entries(errors.probes);
                        Curry._3(Assert.deepStrictEqual, probeErrors.length, 3, undefined);
                        var commandErrors = Object.entries(errors.commands);
                        Curry._3(Assert.deepStrictEqual, commandErrors.length, 0, undefined);
                        return Curry._3(Assert.deepStrictEqual, errors.download, undefined, undefined);
                      }));
                it("should return empty error when no paths provided", (async function () {
                        var platformDeps = Mock$AgdaModeVscode.Platform.makeBasic();
                        var paths = [];
                        var result = await Connection$AgdaModeVscode.fromPaths(platformDeps, paths);
                        if (result.TAG === "Ok") {
                          Assert.fail("Expected error with empty paths");
                          return ;
                        }
                        var errors = result._0;
                        var probeErrors = Object.entries(errors.probes);
                        Curry._3(Assert.deepStrictEqual, probeErrors.length, 0, undefined);
                        var commandErrors = Object.entries(errors.commands);
                        Curry._3(Assert.deepStrictEqual, commandErrors.length, 0, undefined);
                        return Curry._3(Assert.deepStrictEqual, errors.download, undefined, undefined);
                      }));
              }));
        describe("`fromCommands`", (function () {
                it("should connect successfully with valid command", (async function () {
                        var platformDeps = Desktop$AgdaModeVscode.make();
                        var commands = [
                          "agda",
                          "als"
                        ];
                        var result = await Connection$AgdaModeVscode.fromCommands(platformDeps, commands);
                        if (result.TAG === "Ok") {
                          return ;
                        }
                        Assert.fail("Expected successful connection via command");
                      }));
                it("should try multiple commands and use first valid one", (async function () {
                        var platformDeps = Desktop$AgdaModeVscode.make();
                        var commands = [
                          "non-existent-cmd",
                          "agda",
                          "als"
                        ];
                        var result = await Connection$AgdaModeVscode.fromCommands(platformDeps, commands);
                        if (result.TAG === "Ok") {
                          return ;
                        }
                        Assert.fail("Expected successful connection to valid command");
                      }));
                it("should return Construction error when all commands are invalid", (async function () {
                        var platformDeps = Desktop$AgdaModeVscode.make();
                        var commands = [
                          "non-existent-cmd-1",
                          "non-existent-cmd-2",
                          "non-existent-cmd-3"
                        ];
                        var result = await Connection$AgdaModeVscode.fromCommands(platformDeps, commands);
                        if (result.TAG === "Ok") {
                          Assert.fail("Expected error with invalid commands");
                          return ;
                        }
                        var errors = result._0;
                        var probeErrors = Object.entries(errors.probes);
                        Curry._3(Assert.deepStrictEqual, probeErrors.length, 0, undefined);
                        var commandErrors = Object.entries(errors.commands);
                        Curry._3(Assert.deepStrictEqual, commandErrors.length, 3, undefined);
                        var commandNames = commandErrors.map(function (param) {
                                return param[0];
                              }).toSorted(Caml.string_compare);
                        Curry._3(Assert.deepStrictEqual, commandNames, [
                              "non-existent-cmd-1",
                              "non-existent-cmd-2",
                              "non-existent-cmd-3"
                            ], undefined);
                        return Curry._3(Assert.deepStrictEqual, errors.download, undefined, undefined);
                      }));
                it("should return empty error when no commands provided", (async function () {
                        var platformDeps = Desktop$AgdaModeVscode.make();
                        var commands = [];
                        var result = await Connection$AgdaModeVscode.fromCommands(platformDeps, commands);
                        if (result.TAG === "Ok") {
                          Assert.fail("Expected error with empty commands");
                          return ;
                        }
                        var errors = result._0;
                        var probeErrors = Object.entries(errors.probes);
                        Curry._3(Assert.deepStrictEqual, probeErrors.length, 0, undefined);
                        var commandErrors = Object.entries(errors.commands);
                        Curry._3(Assert.deepStrictEqual, commandErrors.length, 0, undefined);
                        return Curry._3(Assert.deepStrictEqual, errors.download, undefined, undefined);
                      }));
              }));
        describe("make with logging", (function () {
                it("should log ConnectedToAgda when Agda connection succeeds", (async function () {
                        var loggedEvents = [];
                        var logChannel = Chan$AgdaModeVscode.make();
                        Chan$AgdaModeVscode.on(logChannel, (function (logEvent) {
                                loggedEvents.push(logEvent);
                              }));
                        var agdaMockPath = await Test__Util$AgdaModeVscode.Endpoint.Agda.mock("2.6.4", "agda-mock-for-make");
                        var memento = Memento$AgdaModeVscode.make(undefined);
                        var platformDeps = Desktop$AgdaModeVscode.make();
                        var globalStorageUri = Vscode.Uri.file("/tmp/test-storage");
                        var connection = await Connection$AgdaModeVscode.makeWithFallback(platformDeps, memento, globalStorageUri, [agdaMockPath], [], logChannel);
                        if (connection.TAG === "Ok") {
                          var connection$1 = connection._0;
                          Curry._3(Assert.deepStrictEqual, loggedEvents, [{
                                  TAG: "Connection",
                                  _0: {
                                    TAG: "ConnectedToAgda",
                                    _0: agdaMockPath,
                                    _1: "2.6.4"
                                  }
                                }], undefined);
                          if (connection$1.TAG === "Agda") {
                            Curry._3(Assert.deepStrictEqual, connection$1._1, agdaMockPath, undefined);
                            Curry._3(Assert.deepStrictEqual, connection$1._2, "2.6.4", undefined);
                          } else {
                            Assert.fail("Expected Agda connection");
                          }
                        } else {
                          Assert.fail("Expected connection to succeed");
                        }
                        try {
                          Nodefs.unlinkSync(agdaMockPath);
                          return ;
                        }
                        catch (exn){
                          return ;
                        }
                      }));
                it("should log connection events when using real agda command", (async function () {
                        var logChannel = Chan$AgdaModeVscode.make();
                        var listener = Log$AgdaModeVscode.collect(logChannel);
                        var memento = Memento$AgdaModeVscode.make(undefined);
                        var platformDeps = Desktop$AgdaModeVscode.make();
                        var globalStorageUri = Vscode.Uri.file("/tmp/test-storage");
                        var result = await Connection$AgdaModeVscode.makeWithFallback(platformDeps, memento, globalStorageUri, [], ["agda"], logChannel);
                        var loggedEvents = listener(Log$AgdaModeVscode.isConnection);
                        if (result.TAG !== "Ok") {
                          return Curry._3(Assert.deepStrictEqual, loggedEvents, [], undefined);
                        }
                        var connection = result._0;
                        if (connection.TAG === "Agda") {
                          return Curry._3(Assert.deepStrictEqual, loggedEvents, [{
                                        TAG: "Connection",
                                        _0: {
                                          TAG: "ConnectedToAgda",
                                          _0: connection._1,
                                          _1: connection._2
                                        }
                                      }], undefined);
                        }
                        var match = connection._2;
                        var path = connection._1;
                        if (match !== undefined) {
                          return Curry._3(Assert.deepStrictEqual, loggedEvents, [{
                                        TAG: "Connection",
                                        _0: {
                                          TAG: "ConnectedToALS",
                                          _0: path,
                                          _1: [
                                            match[0],
                                            match[1]
                                          ]
                                        }
                                      }], undefined);
                        } else {
                          return Curry._3(Assert.deepStrictEqual, loggedEvents, [{
                                        TAG: "Connection",
                                        _0: {
                                          TAG: "ConnectedToALS",
                                          _0: path,
                                          _1: undefined
                                        }
                                      }], undefined);
                        }
                      }));
                it("should not log connection events when connection fails", (async function () {
                        var loggedEvents = [];
                        var logChannel = Chan$AgdaModeVscode.make();
                        Chan$AgdaModeVscode.on(logChannel, (function (logEvent) {
                                loggedEvents.push(logEvent);
                              }));
                        var memento = Memento$AgdaModeVscode.make(undefined);
                        var platformDeps = Mock$AgdaModeVscode.Platform.makeBasic();
                        var globalStorageUri = Vscode.Uri.file("/tmp/test-storage");
                        var match = await Connection$AgdaModeVscode.makeWithFallback(platformDeps, memento, globalStorageUri, ["/nonexistent/path"], ["nonexistent-command"], logChannel);
                        if (match.TAG !== "Ok") {
                          return Curry._3(Assert.deepStrictEqual, loggedEvents, [], undefined);
                        }
                        Assert.fail("Expected connection to fail");
                      }));
                it.skip("should log connection events even when falling back to downloads", (async function () {
                        var loggedEvents = [];
                        var logChannel = Chan$AgdaModeVscode.make();
                        Chan$AgdaModeVscode.on(logChannel, (function (logEvent) {
                                loggedEvents.push(logEvent);
                              }));
                        var memento = Memento$AgdaModeVscode.make(undefined);
                        var platformDeps = Desktop$AgdaModeVscode.make();
                        var globalStorageUri = Vscode.Uri.file("/tmp/test-storage");
                        var match = await Connection$AgdaModeVscode.makeWithFallback(platformDeps, memento, globalStorageUri, ["/invalid/path"], ["invalid-command"], logChannel);
                        if (match.TAG !== "Ok") {
                          return Curry._3(Assert.deepStrictEqual, loggedEvents, [], undefined);
                        }
                        var len = loggedEvents.length;
                        if (len !== 1) {
                          if (len !== 0) {
                            Assert.fail("Expected exactly one connection event");
                          } else {
                            Assert.fail("Expected connection event to be logged");
                          }
                          return ;
                        }
                        var match$1 = loggedEvents[0];
                        if (match$1.TAG === "Connection") {
                          switch (match$1._0.TAG) {
                            case "ConnectedToAgda" :
                            case "ConnectedToALS" :
                                return ;
                            case "Disconnected" :
                                Assert.fail("Expected exactly one connection event");
                                return ;
                            
                          }
                        } else {
                          Assert.fail("Expected exactly one connection event");
                          return ;
                        }
                      }));
              }));
        describe("make fromPathsAndCommands scenarios", (function () {
                it("should find commands when no paths are given", (async function () {
                        var logChannel = Chan$AgdaModeVscode.make();
                        var listener = Log$AgdaModeVscode.collect(logChannel);
                        var memento = Memento$AgdaModeVscode.make(undefined);
                        var platformDeps = Desktop$AgdaModeVscode.make();
                        var globalStorageUri = Vscode.Uri.file("/tmp/test-storage");
                        var result = await Connection$AgdaModeVscode.makeWithFallback(platformDeps, memento, globalStorageUri, [], [
                              "agda",
                              "als"
                            ], logChannel);
                        var loggedEvents = listener(Log$AgdaModeVscode.isConnection);
                        if (result.TAG === "Ok") {
                          var len = loggedEvents.length;
                          if (len !== 1) {
                            if (len !== 0) {
                              Assert.fail("Expected exactly one connection event");
                            } else {
                              Assert.fail("Expected connection event to be logged");
                            }
                            return ;
                          }
                          var match = loggedEvents[0];
                          if (match.TAG === "Connection") {
                            switch (match._0.TAG) {
                              case "ConnectedToAgda" :
                              case "ConnectedToALS" :
                                  return ;
                              case "Disconnected" :
                                  Assert.fail("Expected exactly one connection event");
                                  return ;
                              
                            }
                          } else {
                            Assert.fail("Expected exactly one connection event");
                            return ;
                          }
                        } else {
                          Assert.fail("Expected to find agda or als");
                          return ;
                        }
                      }));
                it("should find commands even if all paths given are wrong", (async function () {
                        var logChannel = Chan$AgdaModeVscode.make();
                        var listener = Log$AgdaModeVscode.collect(logChannel);
                        var memento = Memento$AgdaModeVscode.make(undefined);
                        var platformDeps = Desktop$AgdaModeVscode.make();
                        var globalStorageUri = Vscode.Uri.file("/tmp/test-storage");
                        var result = await Connection$AgdaModeVscode.makeWithFallback(platformDeps, memento, globalStorageUri, ["/some/invalid/path"], [
                              "agda",
                              "als"
                            ], logChannel);
                        var loggedEvents = listener(Log$AgdaModeVscode.isConnection);
                        if (result.TAG === "Ok") {
                          var len = loggedEvents.length;
                          if (len !== 1) {
                            if (len !== 0) {
                              Assert.fail("Expected exactly one connection event");
                            } else {
                              Assert.fail("Expected connection event to be logged");
                            }
                            return ;
                          }
                          var match = loggedEvents[0];
                          if (match.TAG === "Connection") {
                            switch (match._0.TAG) {
                              case "ConnectedToAgda" :
                              case "ConnectedToALS" :
                                  return ;
                              case "Disconnected" :
                                  Assert.fail("Expected exactly one connection event");
                                  return ;
                              
                            }
                          } else {
                            Assert.fail("Expected exactly one connection event");
                            return ;
                          }
                        } else {
                          Assert.fail("Expected to find agda or als via commands");
                          return ;
                        }
                      }));
                it("should prioritize valid paths over commands", (async function () {
                        var logChannel = Chan$AgdaModeVscode.make();
                        var listener = Log$AgdaModeVscode.collect(logChannel);
                        var agdaMockPath = await Test__Util$AgdaModeVscode.Endpoint.Agda.mock("2.6.4", "agda-mock-for-path-priority");
                        var memento = Memento$AgdaModeVscode.make(undefined);
                        var platformDeps = Desktop$AgdaModeVscode.make();
                        var globalStorageUri = Vscode.Uri.file("/tmp/test-storage");
                        var result = await Connection$AgdaModeVscode.makeWithFallback(platformDeps, memento, globalStorageUri, [agdaMockPath], ["invalid-command"], logChannel);
                        var loggedEvents = listener(Log$AgdaModeVscode.isConnection);
                        if (result.TAG === "Ok") {
                          var connection = result._0;
                          Curry._3(Assert.deepStrictEqual, loggedEvents, [{
                                  TAG: "Connection",
                                  _0: {
                                    TAG: "ConnectedToAgda",
                                    _0: agdaMockPath,
                                    _1: "2.6.4"
                                  }
                                }], undefined);
                          if (connection.TAG === "Agda") {
                            Curry._3(Assert.deepStrictEqual, connection._1, agdaMockPath, undefined);
                            Curry._3(Assert.deepStrictEqual, connection._2, "2.6.4", undefined);
                          } else {
                            Assert.fail("Expected Agda connection");
                          }
                        } else {
                          Assert.fail("Expected connection to mock Agda path");
                        }
                        try {
                          Nodefs.unlinkSync(agdaMockPath);
                          return ;
                        }
                        catch (exn){
                          return ;
                        }
                      }));
              }));
        describe("make fromDownloads scenarios", (function () {
                it("should handle platform not supported error with logging", (async function () {
                        var logChannel = Chan$AgdaModeVscode.make();
                        var listener = Log$AgdaModeVscode.collect(logChannel);
                        var platform = {
                          os: "unsupported-os",
                          dist: "unsupported-dist",
                          codename: "unsupported-codename",
                          release: "unsupported-release"
                        };
                        var mockPlatformDeps = Mock$AgdaModeVscode.Platform.makeWithPlatformError(platform);
                        var memento = Memento$AgdaModeVscode.make(undefined);
                        var globalStorageUri = Vscode.Uri.file("/tmp/test-storage");
                        var result = await Connection$AgdaModeVscode.makeWithFallback(mockPlatformDeps, memento, globalStorageUri, ["/invalid/path"], ["invalid-command"], logChannel);
                        var loggedEvents = listener(Log$AgdaModeVscode.isConnection);
                        if (result.TAG === "Ok") {
                          Assert.fail("Expected platform error");
                          return ;
                        }
                        var error = result._0;
                        switch (error.TAG) {
                          case "Establish" :
                              var match = error._0.download;
                              if (!(match !== undefined && !(typeof match !== "object" || match.TAG !== "PlatformNotSupported"))) {
                                Assert.fail("Expected PlatformNotSupported download error");
                              }
                              break;
                          case "CommWithAgda" :
                          case "CommWithALS" :
                              Assert.fail("Expected Establish error");
                              break;
                          
                        }
                        return Curry._3(Assert.deepStrictEqual, loggedEvents, [], undefined);
                      }));
                it("should handle download policy No with logging", (async function () {
                        var logChannel = Chan$AgdaModeVscode.make();
                        var listener = Log$AgdaModeVscode.collect(logChannel);
                        await Config$AgdaModeVscode.Connection.DownloadPolicy.set("No");
                        var getDownloadPolicyCount = {
                          contents: 0
                        };
                        var mockPlatformDeps = Mock$AgdaModeVscode.Platform.makeWithDownloadPolicyCounter("No", getDownloadPolicyCount);
                        var memento = Memento$AgdaModeVscode.make(undefined);
                        var globalStorageUri = Vscode.Uri.file("/tmp/test-storage");
                        var result = await Connection$AgdaModeVscode.makeWithFallback(mockPlatformDeps, memento, globalStorageUri, ["/invalid/path"], ["invalid-command"], logChannel);
                        var loggedEvents = listener(Log$AgdaModeVscode.isConnection);
                        if (result.TAG === "Ok") {
                          Assert.fail("Expected error due to No download policy");
                          return ;
                        }
                        switch (result._0.TAG) {
                          case "Establish" :
                              break;
                          case "CommWithAgda" :
                          case "CommWithALS" :
                              Assert.fail("Expected Establish error");
                              break;
                          
                        }
                        Curry._3(Assert.deepStrictEqual, getDownloadPolicyCount.contents, 0, undefined);
                        return Curry._3(Assert.deepStrictEqual, loggedEvents, [], undefined);
                      }));
                it("should handle download policy Undecided (user cancelled) with logging", (async function () {
                        var logChannel = Chan$AgdaModeVscode.make();
                        var listener = Log$AgdaModeVscode.collect(logChannel);
                        await Config$AgdaModeVscode.Connection.DownloadPolicy.set("Undecided");
                        var getDownloadPolicyCount = {
                          contents: 0
                        };
                        var mockPlatformDeps = Mock$AgdaModeVscode.Platform.makeWithDownloadPolicyCounter("Undecided", getDownloadPolicyCount);
                        var memento = Memento$AgdaModeVscode.make(undefined);
                        var globalStorageUri = Vscode.Uri.file("/tmp/test-storage");
                        var result = await Connection$AgdaModeVscode.makeWithFallback(mockPlatformDeps, memento, globalStorageUri, ["/invalid/path"], ["invalid-command"], logChannel);
                        var loggedEvents = listener(Log$AgdaModeVscode.isConnection);
                        if (result.TAG === "Ok") {
                          Assert.fail("Expected error due to user cancelling download");
                          return ;
                        }
                        switch (result._0.TAG) {
                          case "Establish" :
                              break;
                          case "CommWithAgda" :
                          case "CommWithALS" :
                              Assert.fail("Expected Establish error");
                              break;
                          
                        }
                        Curry._3(Assert.deepStrictEqual, getDownloadPolicyCount.contents, 1, undefined);
                        var policy = Config$AgdaModeVscode.Connection.DownloadPolicy.get();
                        Curry._3(Assert.deepStrictEqual, policy, "No", undefined);
                        return Curry._3(Assert.deepStrictEqual, loggedEvents, [], undefined);
                      }));
                it("should handle cached ALS download with logging", (async function () {
                        var logChannel = Chan$AgdaModeVscode.make();
                        var listener = Log$AgdaModeVscode.collect(logChannel);
                        var agdaMockPath = await Test__Util$AgdaModeVscode.Endpoint.Agda.mock("2.7.0.1", "agda-mock-cached");
                        await Config$AgdaModeVscode.Connection.DownloadPolicy.set("Undecided");
                        var checkedCache = {
                          contents: false
                        };
                        var mockPlatformDeps = Mock$AgdaModeVscode.Platform.makeWithCachedDownloadAndFlag(agdaMockPath, checkedCache);
                        var memento = Memento$AgdaModeVscode.make(undefined);
                        var globalStorageUri = Vscode.Uri.file("/tmp/test-storage");
                        var result = await Connection$AgdaModeVscode.makeWithFallback(mockPlatformDeps, memento, globalStorageUri, ["/invalid/path"], ["invalid-command"], logChannel);
                        var loggedEvents = listener(Log$AgdaModeVscode.isConnection);
                        if (result.TAG === "Ok") {
                          var connection = result._0;
                          Curry._3(Assert.deepStrictEqual, checkedCache.contents, true, undefined);
                          if (loggedEvents.length !== 1) {
                            Assert.fail("Expected exactly one ConnectedToAgda event");
                          } else {
                            var match = loggedEvents[0];
                            if (match.TAG === "Connection") {
                              var match$1 = match._0;
                              switch (match$1.TAG) {
                                case "ConnectedToAgda" :
                                    Curry._3(Assert.deepStrictEqual, match$1._1, "2.7.0.1", undefined);
                                    break;
                                case "ConnectedToALS" :
                                case "Disconnected" :
                                    Assert.fail("Expected exactly one ConnectedToAgda event");
                                    break;
                                
                              }
                            } else {
                              Assert.fail("Expected exactly one ConnectedToAgda event");
                            }
                          }
                          if (connection.TAG === "Agda") {
                            Curry._3(Assert.deepStrictEqual, connection._1, agdaMockPath, undefined);
                            Curry._3(Assert.deepStrictEqual, connection._2, "2.7.0.1", undefined);
                          } else {
                            Assert.fail("Expected Agda connection");
                          }
                          var policy = Config$AgdaModeVscode.Connection.DownloadPolicy.get();
                          Curry._3(Assert.deepStrictEqual, policy, "Yes", undefined);
                        } else {
                          Assert.fail("Expected successful cached download");
                        }
                        try {
                          Nodefs.unlinkSync(agdaMockPath);
                          return ;
                        }
                        catch (exn){
                          return ;
                        }
                      }));
                it("should handle fresh ALS download with logging", (async function () {
                        var logChannel = Chan$AgdaModeVscode.make();
                        var listener = Log$AgdaModeVscode.collect(logChannel);
                        var agdaMockPath = await Test__Util$AgdaModeVscode.Endpoint.Agda.mock("2.7.0.1", "agda-mock-fresh-download");
                        await Config$AgdaModeVscode.Connection.DownloadPolicy.set("Undecided");
                        var checkedCache = {
                          contents: false
                        };
                        var checkedDownload = {
                          contents: false
                        };
                        var mockPlatformDeps = Mock$AgdaModeVscode.Platform.makeWithSuccessfulDownloadAndFlags(agdaMockPath, checkedCache, checkedDownload);
                        var memento = Memento$AgdaModeVscode.make(undefined);
                        var globalStorageUri = Vscode.Uri.file("/tmp/test-storage");
                        var result = await Connection$AgdaModeVscode.makeWithFallback(mockPlatformDeps, memento, globalStorageUri, ["/invalid/path"], ["invalid-command"], logChannel);
                        var loggedEvents = listener(Log$AgdaModeVscode.isConnection);
                        if (result.TAG === "Ok") {
                          var connection = result._0;
                          Curry._3(Assert.deepStrictEqual, checkedCache.contents, true, undefined);
                          Curry._3(Assert.deepStrictEqual, checkedDownload.contents, true, undefined);
                          if (loggedEvents.length !== 1) {
                            Assert.fail("Expected exactly one ConnectedToAgda event");
                          } else {
                            var match = loggedEvents[0];
                            if (match.TAG === "Connection") {
                              var match$1 = match._0;
                              switch (match$1.TAG) {
                                case "ConnectedToAgda" :
                                    Curry._3(Assert.deepStrictEqual, match$1._1, "2.7.0.1", undefined);
                                    break;
                                case "ConnectedToALS" :
                                case "Disconnected" :
                                    Assert.fail("Expected exactly one ConnectedToAgda event");
                                    break;
                                
                              }
                            } else {
                              Assert.fail("Expected exactly one ConnectedToAgda event");
                            }
                          }
                          if (connection.TAG === "Agda") {
                            var path = connection._1;
                            Curry._3(Assert.deepStrictEqual, path, agdaMockPath, undefined);
                            Curry._3(Assert.deepStrictEqual, connection._2, "2.7.0.1", undefined);
                            Curry._3(Assert.deepStrictEqual, path, agdaMockPath, undefined);
                          } else {
                            Assert.fail("Expected Agda connection");
                          }
                          var policy = Config$AgdaModeVscode.Connection.DownloadPolicy.get();
                          Curry._3(Assert.deepStrictEqual, policy, "Yes", undefined);
                        } else {
                          Assert.fail("Expected successful fresh download");
                        }
                        try {
                          Nodefs.unlinkSync(agdaMockPath);
                          return ;
                        }
                        catch (exn){
                          return ;
                        }
                      }));
                it("should handle download failure with logging", (async function () {
                        var logChannel = Chan$AgdaModeVscode.make();
                        var listener = Log$AgdaModeVscode.collect(logChannel);
                        await Config$AgdaModeVscode.Connection.DownloadPolicy.set("Undecided");
                        var checkedCache = {
                          contents: false
                        };
                        var checkedDownload = {
                          contents: false
                        };
                        var mockPlatformDeps = Mock$AgdaModeVscode.Platform.makeWithDownloadFailureAndFlags(checkedCache, checkedDownload);
                        var memento = Memento$AgdaModeVscode.make(undefined);
                        var globalStorageUri = Vscode.Uri.file("/tmp/test-storage");
                        var result = await Connection$AgdaModeVscode.makeWithFallback(mockPlatformDeps, memento, globalStorageUri, ["/invalid/path"], ["invalid-command"], logChannel);
                        var loggedEvents = listener(Log$AgdaModeVscode.isConnection);
                        if (result.TAG === "Ok") {
                          Assert.fail("Expected download failure");
                          return ;
                        }
                        var error = result._0;
                        Curry._3(Assert.deepStrictEqual, checkedCache.contents, true, undefined);
                        Curry._3(Assert.deepStrictEqual, checkedDownload.contents, true, undefined);
                        switch (error.TAG) {
                          case "Establish" :
                              var match = error._0.download;
                              if (!(match !== undefined && typeof match !== "object" && match === "CannotFindCompatibleALSRelease")) {
                                Assert.fail("Expected CannotFindCompatibleALSRelease download error");
                              }
                              break;
                          case "CommWithAgda" :
                          case "CommWithALS" :
                              Assert.fail("Expected Establish error");
                              break;
                          
                        }
                        var policy = Config$AgdaModeVscode.Connection.DownloadPolicy.get();
                        Curry._3(Assert.deepStrictEqual, policy, "Yes", undefined);
                        return Curry._3(Assert.deepStrictEqual, loggedEvents, [], undefined);
                      }));
              }));
      }));

exports.getAgdaTarget = getAgdaTarget;
/*  Not a pure module */
