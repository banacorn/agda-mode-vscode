// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Assert = require("assert");
var Vscode = require("vscode");
var Nodefs = require("node:fs");
var Nodeos = require("node:os");
var Nodeurl = require("node:url");
var Nodepath = require("node:path");
var PervasivesU = require("rescript/lib/js/pervasivesU.js");
var OS$AgdaModeVscode = require("../../src/Util/OS.bs.js");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");
var Util$AgdaModeVscode = require("../../src/Util/Util.bs.js");
var Config$AgdaModeVscode = require("../../src/Config.bs.js");
var Desktop$AgdaModeVscode = require("../../src/Main/Desktop.bs.js");
var Connection$AgdaModeVscode = require("../../src/Connection/Connection.bs.js");
var Test__Util$AgdaModeVscode = require("./Test__Util.bs.js");
var State__Memento$AgdaModeVscode = require("../../src/State/State__Memento.bs.js");
var Connection__URI$AgdaModeVscode = require("../../src/Connection/Shared/Connection__URI.bs.js");
var Connection__Command$AgdaModeVscode = require("../../src/Connection/Resolver/Connection__Command.bs.js");
var Connection__Endpoint$AgdaModeVscode = require("../../src/Connection/Endpoint/Connection__Endpoint.bs.js");

async function getAgdaTarget() {
  var platformDeps = Desktop$AgdaModeVscode.make();
  var target = await Connection$AgdaModeVscode.findCommands(platformDeps, ["agda"]);
  if (target.TAG === "Ok") {
    return target._0;
  } else {
    return PervasivesU.failwith("expected to find `agda`");
  }
}

describe("Connection", (function () {
        this.timeout(10000);
        describe("URI.parse", (function () {
                it("should be able to parse URIs with lsp: as the protocol", (async function () {
                        var actual = Connection__URI$AgdaModeVscode.parse("lsp://path/to/als");
                        var expected = {
                          TAG: "URL",
                          _0: new Nodeurl.URL("lsp://path/to/als")
                        };
                        return Curry._3(Assert.deepStrictEqual, actual, expected, undefined);
                      }));
                it("should be able to parse file paths", (async function () {
                        var actual = Connection__URI$AgdaModeVscode.parse("path/to/als");
                        var expected = OS$AgdaModeVscode.onUnix ? ({
                              TAG: "Filepath",
                              _0: "path/to/als"
                            }) : ({
                              TAG: "Filepath",
                              _0: "path\\to\\als"
                            });
                        return Curry._3(Assert.deepStrictEqual, actual, expected, undefined);
                      }));
                it("should be able to parse convert \"/c/path/to/agda\" to \"c:/path/to/agda\" on Windows", (async function () {
                        var actual = Connection__URI$AgdaModeVscode.parse("/c/path/to/agda");
                        var expected = OS$AgdaModeVscode.onUnix ? ({
                              TAG: "Filepath",
                              _0: "/c/path/to/agda"
                            }) : ({
                              TAG: "Filepath",
                              _0: "c:\\path\\to\\agda"
                            });
                        Curry._3(Assert.deepStrictEqual, actual, expected, undefined);
                        var actual$1 = Connection__URI$AgdaModeVscode.parse("/d/path/to/agda");
                        var expected$1 = OS$AgdaModeVscode.onUnix ? ({
                              TAG: "Filepath",
                              _0: "/d/path/to/agda"
                            }) : ({
                              TAG: "Filepath",
                              _0: "d:\\path\\to\\agda"
                            });
                        return Curry._3(Assert.deepStrictEqual, actual$1, expected$1, undefined);
                      }));
              }));
        describe("Target", (function () {
                var agdaMockPath = {
                  contents: ""
                };
                var agdaMockEndpoint = {
                  contents: undefined
                };
                before(async function () {
                      agdaMockPath.contents = await Test__Util$AgdaModeVscode.Endpoint.Agda.mock("2.7.0.1", "agda-mock");
                      var target = await Connection__Endpoint$AgdaModeVscode.fromRawPath(agdaMockPath.contents);
                      if (target.TAG === "Ok") {
                        agdaMockEndpoint.contents = target._0;
                        return ;
                      }
                      var errorMessage = Connection__Endpoint$AgdaModeVscode.$$Error.toString(target._0);
                      return PervasivesU.failwith("Got error when trying to construct target from mock Agda path:\n" + errorMessage);
                    });
                it("should return the previously picked connection", (async function () {
                        var target = agdaMockEndpoint.contents;
                        var agdaMockEndpoint$1 = target !== undefined ? target : PervasivesU.failwith("Unable to access the Agda mock target");
                        var memento = State__Memento$AgdaModeVscode.make(undefined);
                        await Connection__Endpoint$AgdaModeVscode.setPicked(memento, agdaMockEndpoint$1);
                        var paths = [
                            agdaMockPath.contents,
                            "path/to/als"
                          ].map(Connection__URI$AgdaModeVscode.parse);
                        var actual = await Connection__Endpoint$AgdaModeVscode.getPicked(memento, paths);
                        var expected = {
                          TAG: "Ok",
                          _0: agdaMockEndpoint$1
                        };
                        return Curry._3(Assert.deepStrictEqual, actual, expected, undefined);
                      }));
                it("should return nothing when there's no previously picked connection", (async function () {
                        var memento = State__Memento$AgdaModeVscode.make(undefined);
                        var paths = [
                            "path/to/agda",
                            "path/to/als"
                          ].map(Connection__URI$AgdaModeVscode.parse);
                        var actual = await Connection__Endpoint$AgdaModeVscode.getPicked(memento, paths);
                        if (OS$AgdaModeVscode.onUnix) {
                          var expected = {
                            TAG: "Error",
                            _0: [
                              {
                                TAG: "SomethingWentWrong",
                                _0: Connection__URI$AgdaModeVscode.parse("path/to/agda"),
                                _1: {
                                  TAG: "NotFound",
                                  _0: "path/to/agda"
                                }
                              },
                              {
                                TAG: "SomethingWentWrong",
                                _0: Connection__URI$AgdaModeVscode.parse("path/to/als"),
                                _1: {
                                  TAG: "NotFound",
                                  _0: "path/to/als"
                                }
                              }
                            ]
                          };
                          return Curry._3(Assert.deepStrictEqual, actual, expected, undefined);
                        }
                        if (actual.TAG === "Ok") {
                          Assert.fail("expected an error, got Ok");
                          return ;
                        }
                        var match = actual._0;
                        if (match.length !== 2) {
                          Assert.fail("expected an error, got something else");
                          return ;
                        }
                        var match$1 = match[0];
                        switch (match$1.TAG) {
                          case "SomethingWentWrong" :
                              var match$2 = match[1];
                              switch (match$2.TAG) {
                                case "SomethingWentWrong" :
                                    Assert.ok(true);
                                    return ;
                                case "NotAgdaOrALS" :
                                case "CannotHandleURLsATM" :
                                    Assert.fail("expected an error, got something else");
                                    return ;
                                
                              }
                          case "NotAgdaOrALS" :
                          case "CannotHandleURLsATM" :
                              Assert.fail("expected an error, got something else");
                              return ;
                          
                        }
                      }));
                it("should return nothing when the previously picked connection is not in the supplied paths", (async function () {
                        var target = agdaMockEndpoint.contents;
                        var agdaMockEndpoint$1 = target !== undefined ? target : PervasivesU.failwith("Unable to access the Agda mock target");
                        var memento = State__Memento$AgdaModeVscode.make(undefined);
                        await Connection__Endpoint$AgdaModeVscode.setPicked(memento, agdaMockEndpoint$1);
                        var paths = [
                            "path/to/agda",
                            "path/to/als"
                          ].map(Connection__URI$AgdaModeVscode.parse);
                        var actual = await Connection__Endpoint$AgdaModeVscode.getPicked(memento, paths);
                        if (OS$AgdaModeVscode.onUnix) {
                          var expected = {
                            TAG: "Error",
                            _0: [
                              {
                                TAG: "SomethingWentWrong",
                                _0: Connection__URI$AgdaModeVscode.parse("path/to/agda"),
                                _1: {
                                  TAG: "NotFound",
                                  _0: "path/to/agda"
                                }
                              },
                              {
                                TAG: "SomethingWentWrong",
                                _0: Connection__URI$AgdaModeVscode.parse("path/to/als"),
                                _1: {
                                  TAG: "NotFound",
                                  _0: "path/to/als"
                                }
                              }
                            ]
                          };
                          return Curry._3(Assert.deepStrictEqual, actual, expected, undefined);
                        }
                        if (actual.TAG === "Ok") {
                          Assert.fail("expected an error, got Ok");
                          return ;
                        }
                        var match = actual._0;
                        if (match.length !== 2) {
                          Assert.fail("expected an error, got something else");
                          return ;
                        }
                        var match$1 = match[0];
                        switch (match$1.TAG) {
                          case "SomethingWentWrong" :
                              var match$2 = match[1];
                              switch (match$2.TAG) {
                                case "SomethingWentWrong" :
                                    Assert.ok(true);
                                    return ;
                                case "NotAgdaOrALS" :
                                case "CannotHandleURLsATM" :
                                    Assert.fail("expected an error, got something else");
                                    return ;
                                
                              }
                          case "NotAgdaOrALS" :
                          case "CannotHandleURLsATM" :
                              Assert.fail("expected an error, got something else");
                              return ;
                          
                        }
                      }));
                it("should return the first usable connection target when the previously picked connection is invalid or not in the supplied paths", (async function () {
                        var target = agdaMockEndpoint.contents;
                        var agdaMockEndpoint$1 = target !== undefined ? target : PervasivesU.failwith("Unable to access the Agda mock target");
                        var memento = State__Memento$AgdaModeVscode.make(undefined);
                        var paths = [
                            "path/to/non-existent-agda",
                            agdaMockPath.contents,
                            "path/to/non-existent-als"
                          ].map(Connection__URI$AgdaModeVscode.parse);
                        var actual = await Connection__Endpoint$AgdaModeVscode.getPicked(memento, paths);
                        var expected = {
                          TAG: "Ok",
                          _0: agdaMockEndpoint$1
                        };
                        return Curry._3(Assert.deepStrictEqual, actual, expected, undefined);
                      }));
                after(async function () {
                      var target = agdaMockEndpoint.contents;
                      if (target !== undefined) {
                        await Test__Util$AgdaModeVscode.Endpoint.Agda.destroy(target);
                        agdaMockEndpoint.contents = undefined;
                        return ;
                      }
                      
                    });
              }));
        describe("Command searching", (function () {
                it("should be able to find itself (`which` or `where`), although it's not a valid target", (async function () {
                        if (OS$AgdaModeVscode.onUnix) {
                          var _output = await Connection__Command$AgdaModeVscode.search("which", undefined);
                          if (_output.TAG === "Ok") {
                            return PervasivesU.failwith("should not be a valid target");
                          }
                          switch (_output._0.TAG) {
                            case "NotFound" :
                            case "SomethingWentWrong" :
                                return PervasivesU.failwith("expected to find `which`");
                            case "NotValidTarget" :
                                return ;
                            
                          }
                        } else {
                          var _output$1 = await Connection__Command$AgdaModeVscode.search("where", undefined);
                          if (_output$1.TAG === "Ok") {
                            return PervasivesU.failwith("should not be a valid target");
                          }
                          switch (_output$1._0.TAG) {
                            case "NotFound" :
                            case "SomethingWentWrong" :
                                return PervasivesU.failwith("expected to find `where`");
                            case "NotValidTarget" :
                                return ;
                            
                          }
                        }
                      }));
                it("should return an error when the command is not found", (async function () {
                        var _output = await Connection__Command$AgdaModeVscode.search("non-existent-command", undefined);
                        if (_output.TAG === "Ok") {
                          return PervasivesU.failwith("expected to not find `non-existent-command`");
                        }
                        
                      }));
              }));
        describe("findCommands", (function () {
                it("should return the connection when a command is found", (async function () {
                        var commands = [
                          "agda",
                          "als"
                        ];
                        var platformDeps = Desktop$AgdaModeVscode.make();
                        var match = await Connection$AgdaModeVscode.findCommands(platformDeps, commands);
                        if (match.TAG === "Ok") {
                          return ;
                        } else {
                          return PervasivesU.failwith("expected to find `agda` or `als`");
                        }
                      }));
                it("should return an error when the command is not found", (async function () {
                        var commands = ["non-existent-command"];
                        var platformDeps = Desktop$AgdaModeVscode.make();
                        var match = await Connection$AgdaModeVscode.findCommands(platformDeps, commands);
                        if (match.TAG === "Ok") {
                          return PervasivesU.failwith("expected to not find `non-existent-command`");
                        }
                        
                      }));
              }));
        describe("`fromPathsAndCommands`", (function () {
                it("should find commands when no paths are given", (async function () {
                        var memento = State__Memento$AgdaModeVscode.make(undefined);
                        var paths = [];
                        var commands = [
                          "agda",
                          "als"
                        ];
                        var platformDeps = Desktop$AgdaModeVscode.make();
                        var result = await Connection$AgdaModeVscode.fromPathsAndCommands(platformDeps, memento, paths, commands);
                        var expected = await getAgdaTarget();
                        return Curry._3(Assert.deepStrictEqual, result, {
                                    TAG: "Ok",
                                    _0: expected
                                  }, undefined);
                      }));
                it("should find commands even if all paths given are wrong", (async function () {
                        var memento = State__Memento$AgdaModeVscode.make(undefined);
                        var paths = [Connection__URI$AgdaModeVscode.parse("some/other/paths")];
                        var commands = [
                          "agda",
                          "als"
                        ];
                        var platformDeps = Desktop$AgdaModeVscode.make();
                        var result = await Connection$AgdaModeVscode.fromPathsAndCommands(platformDeps, memento, paths, commands);
                        var expected = await getAgdaTarget();
                        return Curry._3(Assert.deepStrictEqual, result, {
                                    TAG: "Ok",
                                    _0: expected
                                  }, undefined);
                      }));
                it("should find the command with its path given", (async function () {
                        var agdaTarget = await getAgdaTarget();
                        var memento = State__Memento$AgdaModeVscode.make(undefined);
                        var paths = [
                          Connection__Endpoint$AgdaModeVscode.toURI(agdaTarget),
                          Connection__URI$AgdaModeVscode.parse("some/other/paths")
                        ];
                        var commands = [
                          "non-existent-command",
                          "agda",
                          "als"
                        ];
                        var platformDeps = Desktop$AgdaModeVscode.make();
                        var result = await Connection$AgdaModeVscode.fromPathsAndCommands(platformDeps, memento, paths, commands);
                        return Curry._3(Assert.deepStrictEqual, result, {
                                    TAG: "Ok",
                                    _0: agdaTarget
                                  }, undefined);
                      }));
                it("should throw an error when the command is not found", (async function () {
                        var memento = State__Memento$AgdaModeVscode.make(undefined);
                        var paths = [Connection__URI$AgdaModeVscode.parse("some/other/paths")];
                        var commands = ["non-existent-command"];
                        var platformDeps = Desktop$AgdaModeVscode.make();
                        var result = await Connection$AgdaModeVscode.fromPathsAndCommands(platformDeps, memento, paths, commands);
                        if (OS$AgdaModeVscode.onUnix) {
                          var expected_endpoints = [{
                              TAG: "SomethingWentWrong",
                              _0: Connection__URI$AgdaModeVscode.parse("some/other/paths"),
                              _1: OS$AgdaModeVscode.onUnix ? ({
                                    TAG: "NotFound",
                                    _0: "some/other/paths"
                                  }) : ({
                                    TAG: "NotFound",
                                    _0: "some\\other\\paths"
                                  })
                            }];
                          var expected_commands = [{
                              TAG: "NotFound",
                              _0: "non-existent-command"
                            }];
                          var expected = {
                            endpoints: expected_endpoints,
                            commands: expected_commands
                          };
                          return Curry._3(Assert.deepStrictEqual, result, {
                                      TAG: "Error",
                                      _0: expected
                                    }, undefined);
                        }
                        if (result.TAG === "Ok") {
                          Assert.fail("expected an error, got Ok");
                          return ;
                        }
                        var match = result._0.endpoints;
                        if (match.length !== 1) {
                          Assert.fail("expected an error with a single endpoint error");
                          return ;
                        }
                        var match$1 = match[0];
                        switch (match$1.TAG) {
                          case "SomethingWentWrong" :
                              Assert.ok(true);
                              return ;
                          case "NotAgdaOrALS" :
                          case "CannotHandleURLsATM" :
                              Assert.fail("expected an error with a single endpoint error");
                              return ;
                          
                        }
                      }));
              }));
        describe("`fromDownloads`", (function () {
                var attempts_endpoints = [];
                var attempts_commands = [];
                var attempts = {
                  endpoints: attempts_endpoints,
                  commands: attempts_commands
                };
                var agdaMockEndpoint = {
                  contents: undefined
                };
                before(async function () {
                      try {
                        var path = await Test__Util$AgdaModeVscode.Endpoint.Agda.mock("2.7.0.1", "agda-mock");
                        var target = await Connection__Endpoint$AgdaModeVscode.fromRawPath(path);
                        if (target.TAG === "Ok") {
                          agdaMockEndpoint.contents = target._0;
                          return ;
                        }
                        var errorMessage = Connection__Endpoint$AgdaModeVscode.$$Error.toString(target._0);
                        return PervasivesU.failwith("Got error when trying to construct target from mock Agda path:\n" + errorMessage);
                      }
                      catch (raw_msg){
                        var msg = Caml_js_exceptions.internalToOCamlException(raw_msg);
                        if (msg.RE_EXN_ID === "Failure") {
                          return PervasivesU.failwith(msg._1);
                        } else {
                          return PervasivesU.failwith("Got error when trying to construct target from mock Agda: unknown error");
                        }
                      }
                    });
                after(async function () {
                      await Config$AgdaModeVscode.Connection.setAgdaPaths([]);
                      await Connection__Endpoint$AgdaModeVscode.setPicked(State__Memento$AgdaModeVscode.make(undefined), undefined);
                      var target = agdaMockEndpoint.contents;
                      if (target !== undefined) {
                        await Test__Util$AgdaModeVscode.Endpoint.Agda.destroy(target);
                        agdaMockEndpoint.contents = undefined;
                        return ;
                      }
                      
                    });
                it("should throw the `PlatformNotSupported` error when the platform is not supported", (async function () {
                        var platform = {
                          os: "non-existent-os",
                          dist: "non-existent-dist",
                          codename: "non-existent-codename",
                          release: "non-existent-release"
                        };
                        var determinePlatform = function () {
                          return Promise.resolve({
                                      TAG: "Error",
                                      _0: platform
                                    });
                        };
                        var findCommands = function (_commands) {
                          return Promise.resolve({
                                      TAG: "Error",
                                      _0: [{
                                          TAG: "NotFound",
                                          _0: "mock"
                                        }]
                                    });
                        };
                        var alreadyDownloaded = function (_globalStorageUri) {
                          return function () {
                            return Promise.resolve(undefined);
                          };
                        };
                        var downloadLatestALS = function (_memento, _globalStorageUri) {
                          return function (_platform) {
                            return Promise.resolve({
                                        TAG: "Error",
                                        _0: "CannotFindCompatibleALSRelease"
                                      });
                          };
                        };
                        var getInstalledEndpointsAndPersistThem = function (_globalStorageUri) {
                          return Promise.resolve(Object.fromEntries([]));
                        };
                        var askUserAboutDownloadPolicy = function () {
                          return Promise.resolve("No");
                        };
                        var MockPlatform = {
                          determinePlatform: determinePlatform,
                          findCommands: findCommands,
                          alreadyDownloaded: alreadyDownloaded,
                          downloadLatestALS: downloadLatestALS,
                          getInstalledEndpointsAndPersistThem: getInstalledEndpointsAndPersistThem,
                          askUserAboutDownloadPolicy: askUserAboutDownloadPolicy
                        };
                        var memento = State__Memento$AgdaModeVscode.make(undefined);
                        var globalStorageUri = Vscode.Uri.file("/tmp/test-storage");
                        var result = await Connection$AgdaModeVscode.fromDownloads(MockPlatform, memento, globalStorageUri, attempts);
                        return Curry._3(Assert.deepStrictEqual, result, {
                                    TAG: "Error",
                                    _0: {
                                      TAG: "Aggregated",
                                      _0: {
                                        TAG: "PlatformNotSupported",
                                        _0: attempts,
                                        _1: platform
                                      }
                                    }
                                  }, undefined);
                      }));
                it("should throw the `NoDownloadALS` error when the initial download policy is `No`", (async function () {
                        await Config$AgdaModeVscode.Connection.DownloadPolicy.set("No");
                        var getDownloadPolicyCount = {
                          contents: 0
                        };
                        var determinePlatform = function () {
                          return Promise.resolve({
                                      TAG: "Ok",
                                      _0: "Windows"
                                    });
                        };
                        var findCommands = function (_commands) {
                          return Promise.resolve({
                                      TAG: "Error",
                                      _0: [{
                                          TAG: "NotFound",
                                          _0: "mock"
                                        }]
                                    });
                        };
                        var alreadyDownloaded = function (_globalStorageUri) {
                          return function () {
                            return Promise.resolve(undefined);
                          };
                        };
                        var downloadLatestALS = function (_memento, _globalStorageUri) {
                          return function (_platform) {
                            return Promise.resolve({
                                        TAG: "Error",
                                        _0: "CannotFindCompatibleALSRelease"
                                      });
                          };
                        };
                        var getInstalledEndpointsAndPersistThem = function (_globalStorageUri) {
                          return Promise.resolve(Object.fromEntries([]));
                        };
                        var askUserAboutDownloadPolicy = function () {
                          getDownloadPolicyCount.contents = getDownloadPolicyCount.contents + 1 | 0;
                          return Promise.resolve("No");
                        };
                        var MockPlatform = {
                          determinePlatform: determinePlatform,
                          findCommands: findCommands,
                          alreadyDownloaded: alreadyDownloaded,
                          downloadLatestALS: downloadLatestALS,
                          getInstalledEndpointsAndPersistThem: getInstalledEndpointsAndPersistThem,
                          askUserAboutDownloadPolicy: askUserAboutDownloadPolicy
                        };
                        var memento = State__Memento$AgdaModeVscode.make(undefined);
                        var globalStorageUri = Vscode.Uri.file("/tmp/test-storage");
                        var result = await Connection$AgdaModeVscode.fromDownloads(MockPlatform, memento, globalStorageUri, attempts);
                        Curry._3(Assert.deepStrictEqual, result, {
                              TAG: "Error",
                              _0: {
                                TAG: "Aggregated",
                                _0: {
                                  TAG: "NoDownloadALS",
                                  _0: attempts
                                }
                              }
                            }, undefined);
                        var policy = Config$AgdaModeVscode.Connection.DownloadPolicy.get();
                        Curry._3(Assert.deepStrictEqual, policy, "No", undefined);
                        return Curry._3(Assert.deepStrictEqual, getDownloadPolicyCount.contents, 0, undefined);
                      }));
                it("should throw the `NoDownloadALS` error when the user clicked `cancel` on the download dialog", (async function () {
                        await Config$AgdaModeVscode.Connection.DownloadPolicy.set("Undecided");
                        var getDownloadPolicyCount = {
                          contents: 0
                        };
                        var determinePlatform = function () {
                          return Promise.resolve({
                                      TAG: "Ok",
                                      _0: "Windows"
                                    });
                        };
                        var findCommands = function (_commands) {
                          return Promise.resolve({
                                      TAG: "Error",
                                      _0: [{
                                          TAG: "NotFound",
                                          _0: "mock"
                                        }]
                                    });
                        };
                        var alreadyDownloaded = function (_globalStorageUri) {
                          return function () {
                            return Promise.resolve(undefined);
                          };
                        };
                        var downloadLatestALS = function (_memento, _globalStorageUri) {
                          return function (_platform) {
                            return Promise.resolve({
                                        TAG: "Error",
                                        _0: "CannotFindCompatibleALSRelease"
                                      });
                          };
                        };
                        var getInstalledEndpointsAndPersistThem = function (_globalStorageUri) {
                          return Promise.resolve(Object.fromEntries([]));
                        };
                        var askUserAboutDownloadPolicy = function () {
                          getDownloadPolicyCount.contents = getDownloadPolicyCount.contents + 1 | 0;
                          return Promise.resolve("Undecided");
                        };
                        var MockPlatform = {
                          determinePlatform: determinePlatform,
                          findCommands: findCommands,
                          alreadyDownloaded: alreadyDownloaded,
                          downloadLatestALS: downloadLatestALS,
                          getInstalledEndpointsAndPersistThem: getInstalledEndpointsAndPersistThem,
                          askUserAboutDownloadPolicy: askUserAboutDownloadPolicy
                        };
                        var memento = State__Memento$AgdaModeVscode.make(undefined);
                        var globalStorageUri = Vscode.Uri.file("/tmp/test-storage");
                        var result = await Connection$AgdaModeVscode.fromDownloads(MockPlatform, memento, globalStorageUri, attempts);
                        Curry._3(Assert.deepStrictEqual, result, {
                              TAG: "Error",
                              _0: {
                                TAG: "Aggregated",
                                _0: {
                                  TAG: "NoDownloadALS",
                                  _0: attempts
                                }
                              }
                            }, undefined);
                        var policy = Config$AgdaModeVscode.Connection.DownloadPolicy.get();
                        Curry._3(Assert.deepStrictEqual, policy, "No", undefined);
                        return Curry._3(Assert.deepStrictEqual, getDownloadPolicyCount.contents, 1, undefined);
                      }));
                it("should check if the latest ALS is already downloaded when the download policy is `Yes`", (async function () {
                        var target = agdaMockEndpoint.contents;
                        var target$1 = target !== undefined ? target : PervasivesU.failwith("Unable to access the Agda mock target");
                        await Config$AgdaModeVscode.Connection.DownloadPolicy.set("Undecided");
                        var checkedCache = {
                          contents: false
                        };
                        var determinePlatform = function () {
                          return Promise.resolve({
                                      TAG: "Ok",
                                      _0: "Windows"
                                    });
                        };
                        var findCommands = function (_commands) {
                          return Promise.resolve({
                                      TAG: "Error",
                                      _0: [{
                                          TAG: "NotFound",
                                          _0: "mock"
                                        }]
                                    });
                        };
                        var alreadyDownloaded = function (_globalStorageUri) {
                          return function () {
                            checkedCache.contents = true;
                            return Promise.resolve(target$1);
                          };
                        };
                        var downloadLatestALS = function (_memento, _globalStorageUri) {
                          return function (_platform) {
                            return Promise.resolve({
                                        TAG: "Error",
                                        _0: "CannotFindCompatibleALSRelease"
                                      });
                          };
                        };
                        var getInstalledEndpointsAndPersistThem = function (_globalStorageUri) {
                          return Promise.resolve(Object.fromEntries([]));
                        };
                        var askUserAboutDownloadPolicy = function () {
                          return Promise.resolve("Yes");
                        };
                        var MockPlatform = {
                          determinePlatform: determinePlatform,
                          findCommands: findCommands,
                          alreadyDownloaded: alreadyDownloaded,
                          downloadLatestALS: downloadLatestALS,
                          getInstalledEndpointsAndPersistThem: getInstalledEndpointsAndPersistThem,
                          askUserAboutDownloadPolicy: askUserAboutDownloadPolicy
                        };
                        var memento = State__Memento$AgdaModeVscode.make(undefined);
                        var globalStorageUri = Vscode.Uri.file("/tmp/test-storage");
                        var result = await Connection$AgdaModeVscode.fromDownloads(MockPlatform, memento, globalStorageUri, attempts);
                        Curry._3(Assert.deepStrictEqual, checkedCache.contents, true, undefined);
                        Curry._3(Assert.deepStrictEqual, result, {
                              TAG: "Ok",
                              _0: target$1
                            }, undefined);
                        var policy = Config$AgdaModeVscode.Connection.DownloadPolicy.get();
                        Curry._3(Assert.deepStrictEqual, policy, "Yes", undefined);
                        var paths = Config$AgdaModeVscode.Connection.getAgdaPaths().map(Connection__URI$AgdaModeVscode.toString);
                        Assert.ok(Util$AgdaModeVscode.$$Array.includes(paths, Connection__URI$AgdaModeVscode.toString(Connection__Endpoint$AgdaModeVscode.toURI(target$1))));
                      }));
                it("should proceed to download the latest ALS when the download policy is `Yes` and the cached latest ALS is not found", (async function () {
                        var target = agdaMockEndpoint.contents;
                        var target$1 = target !== undefined ? target : PervasivesU.failwith("Unable to access the Agda mock target");
                        await Config$AgdaModeVscode.Connection.DownloadPolicy.set("Undecided");
                        var checkedCache = {
                          contents: false
                        };
                        var checkedDownload = {
                          contents: false
                        };
                        var determinePlatform = function () {
                          return Promise.resolve({
                                      TAG: "Ok",
                                      _0: "Windows"
                                    });
                        };
                        var findCommands = function (_commands) {
                          return Promise.resolve({
                                      TAG: "Error",
                                      _0: [{
                                          TAG: "NotFound",
                                          _0: "mock"
                                        }]
                                    });
                        };
                        var alreadyDownloaded = function (_globalStorageUri) {
                          return function () {
                            checkedCache.contents = true;
                            return Promise.resolve(undefined);
                          };
                        };
                        var downloadLatestALS = function (_memento, _globalStorageUri) {
                          return function (_platform) {
                            checkedDownload.contents = true;
                            return Promise.resolve({
                                        TAG: "Ok",
                                        _0: target$1
                                      });
                          };
                        };
                        var getInstalledEndpointsAndPersistThem = function (_globalStorageUri) {
                          return Promise.resolve(Object.fromEntries([]));
                        };
                        var askUserAboutDownloadPolicy = function () {
                          return Promise.resolve("Yes");
                        };
                        var MockPlatform = {
                          determinePlatform: determinePlatform,
                          findCommands: findCommands,
                          alreadyDownloaded: alreadyDownloaded,
                          downloadLatestALS: downloadLatestALS,
                          getInstalledEndpointsAndPersistThem: getInstalledEndpointsAndPersistThem,
                          askUserAboutDownloadPolicy: askUserAboutDownloadPolicy
                        };
                        var memento = State__Memento$AgdaModeVscode.make(undefined);
                        var globalStorageUri = Vscode.Uri.file("/tmp/test-storage");
                        var result = await Connection$AgdaModeVscode.fromDownloads(MockPlatform, memento, globalStorageUri, attempts);
                        Curry._3(Assert.deepStrictEqual, checkedCache.contents, true, undefined);
                        Curry._3(Assert.deepStrictEqual, checkedDownload.contents, true, undefined);
                        Curry._3(Assert.deepStrictEqual, result, {
                              TAG: "Ok",
                              _0: target$1
                            }, undefined);
                        var policy = Config$AgdaModeVscode.Connection.DownloadPolicy.get();
                        Curry._3(Assert.deepStrictEqual, policy, "Yes", undefined);
                        var paths = Config$AgdaModeVscode.Connection.getAgdaPaths().map(Connection__URI$AgdaModeVscode.toString);
                        Assert.ok(Util$AgdaModeVscode.$$Array.includes(paths, Connection__URI$AgdaModeVscode.toString(Connection__Endpoint$AgdaModeVscode.toURI(target$1))));
                      }));
                it("should throw the `DownloadALS` error when the download policy is `Yes` but the download fails", (async function () {
                        await Config$AgdaModeVscode.Connection.DownloadPolicy.set("Undecided");
                        var checkedCache = {
                          contents: false
                        };
                        var checkedDownload = {
                          contents: false
                        };
                        var determinePlatform = function () {
                          return Promise.resolve({
                                      TAG: "Ok",
                                      _0: "Windows"
                                    });
                        };
                        var findCommands = function (_commands) {
                          return Promise.resolve({
                                      TAG: "Error",
                                      _0: [{
                                          TAG: "NotFound",
                                          _0: "mock"
                                        }]
                                    });
                        };
                        var alreadyDownloaded = function (_globalStorageUri) {
                          return function () {
                            checkedCache.contents = true;
                            return Promise.resolve(undefined);
                          };
                        };
                        var downloadLatestALS = function (_memento, _globalStorageUri) {
                          return function (_platform) {
                            checkedDownload.contents = true;
                            return Promise.resolve({
                                        TAG: "Error",
                                        _0: "CannotFindCompatibleALSRelease"
                                      });
                          };
                        };
                        var getInstalledEndpointsAndPersistThem = function (_globalStorageUri) {
                          return Promise.resolve(Object.fromEntries([]));
                        };
                        var askUserAboutDownloadPolicy = function () {
                          return Promise.resolve("Yes");
                        };
                        var MockPlatform = {
                          determinePlatform: determinePlatform,
                          findCommands: findCommands,
                          alreadyDownloaded: alreadyDownloaded,
                          downloadLatestALS: downloadLatestALS,
                          getInstalledEndpointsAndPersistThem: getInstalledEndpointsAndPersistThem,
                          askUserAboutDownloadPolicy: askUserAboutDownloadPolicy
                        };
                        var memento = State__Memento$AgdaModeVscode.make(undefined);
                        var globalStorageUri = Vscode.Uri.file("/tmp/test-storage");
                        var result = await Connection$AgdaModeVscode.fromDownloads(MockPlatform, memento, globalStorageUri, attempts);
                        Curry._3(Assert.deepStrictEqual, checkedCache.contents, true, undefined);
                        Curry._3(Assert.deepStrictEqual, checkedDownload.contents, true, undefined);
                        Curry._3(Assert.deepStrictEqual, result, {
                              TAG: "Error",
                              _0: {
                                TAG: "Aggregated",
                                _0: {
                                  TAG: "DownloadALS",
                                  _0: attempts,
                                  _1: "CannotFindCompatibleALSRelease"
                                }
                              }
                            }, undefined);
                        var policy = Config$AgdaModeVscode.Connection.DownloadPolicy.get();
                        return Curry._3(Assert.deepStrictEqual, policy, "Yes", undefined);
                      }));
              }));
        describe("checkForPrebuiltDataDirectory", (function () {
                it("should return asset path when data directory exists", (async function () {
                        var tempDir = Nodepath.join(Nodeos.tmpdir(), "agda-test-" + String(Date.now() | 0));
                        var execPath = Nodepath.join(tempDir, "bin", "agda-language-server");
                        var dataDir = Nodepath.join(tempDir, "bin", "data");
                        await Nodefs.promises.mkdir(Nodepath.join(tempDir, "bin"), {
                              recursive: true,
                              mode: 511
                            });
                        await Nodefs.promises.mkdir(dataDir, {
                              recursive: true,
                              mode: 511
                            });
                        var result = await Connection__Endpoint$AgdaModeVscode.checkForPrebuiltDataDirectory(execPath);
                        var expectedAssetPath = Nodepath.join(execPath, "..", "data");
                        Curry._3(Assert.deepStrictEqual, result, expectedAssetPath, undefined);
                        Nodefs.rmdirSync(dataDir);
                        Nodefs.rmdirSync(Nodepath.join(tempDir, "bin"));
                        Nodefs.rmdirSync(tempDir);
                      }));
                it("should return None when data directory does not exist", (async function () {
                        var tempDir = Nodepath.join(Nodeos.tmpdir(), "agda-test-" + String(Date.now() | 0));
                        var execPath = Nodepath.join(tempDir, "bin", "agda-language-server");
                        await Nodefs.promises.mkdir(Nodepath.join(tempDir, "bin"), {
                              recursive: true,
                              mode: 511
                            });
                        var result = await Connection__Endpoint$AgdaModeVscode.checkForPrebuiltDataDirectory(execPath);
                        Curry._3(Assert.deepStrictEqual, result, undefined, undefined);
                        Nodefs.rmdirSync(Nodepath.join(tempDir, "bin"));
                        Nodefs.rmdirSync(tempDir);
                      }));
              }));
      }));

exports.getAgdaTarget = getAgdaTarget;
/*  Not a pure module */
