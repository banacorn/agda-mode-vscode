// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Assert = require("assert");
var Vscode = require("vscode");
var Nodefs = require("node:fs");
var Nodeos = require("node:os");
var Nodepath = require("node:path");
var Core__Option = require("@rescript/core/lib/js/src/Core__Option.bs.js");
var FS$AgdaModeVscode = require("../../src/FS.bs.js");

describe("FS", (function () {
        this.timeout(10000);
        describe("copy", (function () {
                it("should copy file successfully when source exists", (async function () {
                        var tempDir = Nodepath.join(Nodeos.tmpdir(), "fs-copy-test-" + String(Date.now() | 0));
                        var sourceFile = Nodepath.join(tempDir, "source.txt");
                        var destFile = Nodepath.join(tempDir, "dest.txt");
                        await Nodefs.promises.mkdir(tempDir, {
                              recursive: true,
                              mode: 511
                            });
                        var content = "test file content";
                        Nodefs.writeFileSync(sourceFile, Buffer.from(content));
                        var sourceUri = Vscode.Uri.file(sourceFile);
                        var destUri = Vscode.Uri.file(destFile);
                        var result = await FS$AgdaModeVscode.copy(sourceUri, destUri);
                        if (result.TAG === "Ok") {
                          var exists = Nodefs.existsSync(destFile);
                          Assert.ok(exists);
                          var destContent = Nodefs.readFileSync(destFile).toString();
                          Curry._3(Assert.deepStrictEqual, destContent, content, undefined);
                        } else {
                          Assert.fail("Expected Ok, got Error: " + result._0);
                        }
                        Nodefs.unlinkSync(sourceFile);
                        Nodefs.unlinkSync(destFile);
                        Nodefs.rmdirSync(tempDir);
                      }));
                it("should return Error when source file does not exist", (async function () {
                        var nonExistentSource = Nodepath.join(Nodeos.tmpdir(), "non-existent-source-" + String(Date.now() | 0) + ".txt");
                        var destFile = Nodepath.join(Nodeos.tmpdir(), "dest-" + String(Date.now() | 0) + ".txt");
                        var sourceUri = Vscode.Uri.file(nonExistentSource);
                        var destUri = Vscode.Uri.file(destFile);
                        var result = await FS$AgdaModeVscode.copy(sourceUri, destUri);
                        if (result.TAG === "Ok") {
                          Assert.fail("Expected Error for non-existent source, got Ok");
                          return ;
                        }
                        Assert.ok(result._0.length > 0);
                      }));
                it("should create parent directories when copying to non-existent destination directory", (async function () {
                        var tempDir = Nodepath.join(Nodeos.tmpdir(), "fs-copy-test-" + String(Date.now() | 0));
                        var sourceFile = Nodepath.join(tempDir, "source.txt");
                        var destFile = Nodepath.join(tempDir, "nonexistent", "dest.txt");
                        await Nodefs.promises.mkdir(tempDir, {
                              recursive: true,
                              mode: 511
                            });
                        Nodefs.writeFileSync(sourceFile, Buffer.from("test content"));
                        var sourceUri = Vscode.Uri.file(sourceFile);
                        var destUri = Vscode.Uri.file(destFile);
                        var result = await FS$AgdaModeVscode.copy(sourceUri, destUri);
                        if (result.TAG === "Ok") {
                          var exists = Nodefs.existsSync(destFile);
                          Assert.ok(exists);
                          var content = Nodefs.readFileSync(destFile).toString();
                          Curry._3(Assert.deepStrictEqual, content, "test content", undefined);
                        } else {
                          Assert.fail("Expected Ok, got Error: " + result._0);
                        }
                        Nodefs.unlinkSync(sourceFile);
                        Nodefs.unlinkSync(destFile);
                        Nodefs.rmdirSync(Nodepath.join(tempDir, "nonexistent"));
                        Nodefs.rmdirSync(tempDir);
                      }));
              }));
        describe("createDirectory", (function () {
                it("should create directory successfully when parent exists", (async function () {
                        var parentDir = Nodepath.join(Nodeos.tmpdir(), "fs-mkdir-test-" + String(Date.now() | 0));
                        var newDir = Nodepath.join(parentDir, "newdir");
                        await Nodefs.promises.mkdir(parentDir, {
                              recursive: true,
                              mode: 511
                            });
                        var uri = Vscode.Uri.file(newDir);
                        var result = await FS$AgdaModeVscode.createDirectory(uri);
                        if (result.TAG === "Ok") {
                          var exists = Nodefs.existsSync(newDir);
                          Assert.ok(exists);
                        } else {
                          Assert.fail("Expected Ok, got Error: " + result._0);
                        }
                        Nodefs.rmdirSync(newDir);
                        Nodefs.rmdirSync(parentDir);
                      }));
                it("should create parent directories recursively when they don't exist", (async function () {
                        var nonExistentParent = Nodepath.join(Nodeos.tmpdir(), "non-existent-parent-" + String(Date.now() | 0));
                        var newDir = Nodepath.join(nonExistentParent, "newdir");
                        var uri = Vscode.Uri.file(newDir);
                        var result = await FS$AgdaModeVscode.createDirectory(uri);
                        if (result.TAG === "Ok") {
                          var exists = Nodefs.existsSync(newDir);
                          Assert.ok(exists);
                          var parentExists = Nodefs.existsSync(nonExistentParent);
                          Assert.ok(parentExists);
                        } else {
                          Assert.fail("Expected Ok, got Error: " + result._0);
                        }
                        Nodefs.rmdirSync(newDir);
                        Nodefs.rmdirSync(nonExistentParent);
                      }));
                it("should succeed when directory already exists (idempotent)", (async function () {
                        var tempDir = Nodepath.join(Nodeos.tmpdir(), "fs-mkdir-existing-" + String(Date.now() | 0));
                        await Nodefs.promises.mkdir(tempDir, {
                              recursive: true,
                              mode: 511
                            });
                        var uri = Vscode.Uri.file(tempDir);
                        var result = await FS$AgdaModeVscode.createDirectory(uri);
                        if (result.TAG === "Ok") {
                          var exists = Nodefs.existsSync(tempDir);
                          Assert.ok(exists);
                        } else {
                          Assert.fail("Expected Ok, got Error: " + result._0);
                        }
                        Nodefs.rmdirSync(tempDir);
                      }));
              }));
        describe("delete", (function () {
                it("should delete file successfully when file exists", (async function () {
                        var tempFile = Nodepath.join(Nodeos.tmpdir(), "fs-delete-file-" + String(Date.now() | 0) + ".txt");
                        Nodefs.writeFileSync(tempFile, Buffer.from("test content"));
                        var existsBefore = Nodefs.existsSync(tempFile);
                        Assert.ok(existsBefore);
                        var uri = Vscode.Uri.file(tempFile);
                        var result = await FS$AgdaModeVscode.$$delete(uri);
                        if (result.TAG === "Ok") {
                          var existsAfter = Nodefs.existsSync(tempFile);
                          Assert.ok(!existsAfter);
                          return ;
                        }
                        Assert.fail("Expected Ok, got Error: " + result._0);
                      }));
                it("should delete directory successfully when directory exists and is empty", (async function () {
                        var tempDir = Nodepath.join(Nodeos.tmpdir(), "fs-delete-dir-" + String(Date.now() | 0));
                        await Nodefs.promises.mkdir(tempDir, {
                              recursive: true,
                              mode: 511
                            });
                        var existsBefore = Nodefs.existsSync(tempDir);
                        Assert.ok(existsBefore);
                        var uri = Vscode.Uri.file(tempDir);
                        var result = await FS$AgdaModeVscode.$$delete(uri);
                        if (result.TAG === "Ok") {
                          var existsAfter = Nodefs.existsSync(tempDir);
                          Assert.ok(!existsAfter);
                          return ;
                        }
                        Assert.fail("Expected Ok, got Error: " + result._0);
                      }));
                it("should return Error when trying to delete non-empty directory", (async function () {
                        var tempDir = Nodepath.join(Nodeos.tmpdir(), "fs-delete-nonempty-" + String(Date.now() | 0));
                        var file1 = Nodepath.join(tempDir, "file1.txt");
                        await Nodefs.promises.mkdir(tempDir, {
                              recursive: true,
                              mode: 511
                            });
                        Nodefs.writeFileSync(file1, Buffer.from("content1"));
                        Assert.ok(Nodefs.existsSync(tempDir));
                        Assert.ok(Nodefs.existsSync(file1));
                        var uri = Vscode.Uri.file(tempDir);
                        var result = await FS$AgdaModeVscode.$$delete(uri);
                        if (result.TAG === "Ok") {
                          Assert.fail("Expected Error for non-empty directory, got Ok");
                        } else {
                          Assert.ok(result._0.length > 0);
                          Assert.ok(Nodefs.existsSync(tempDir));
                          Assert.ok(Nodefs.existsSync(file1));
                        }
                        Nodefs.unlinkSync(file1);
                        Nodefs.rmdirSync(tempDir);
                      }));
                it("should return Error when trying to delete non-existent file", (async function () {
                        var nonExistentFile = Nodepath.join(Nodeos.tmpdir(), "non-existent-delete-" + String(Date.now() | 0) + ".txt");
                        var uri = Vscode.Uri.file(nonExistentFile);
                        var result = await FS$AgdaModeVscode.$$delete(uri);
                        if (result.TAG === "Ok") {
                          Assert.fail("Expected Error for non-existent file, got Ok");
                          return ;
                        }
                        Assert.ok(result._0.length > 0);
                      }));
              }));
        describe("isWritableFileSystem", (function () {
                it("should return Ok(true) for writable file system (local files)", (async function () {
                        var writableDir = Nodeos.tmpdir();
                        var uri = Vscode.Uri.file(writableDir);
                        var result = FS$AgdaModeVscode.isWritableFileSystem(uri);
                        if (result.TAG === "Ok") {
                          Assert.ok(result._0);
                          return ;
                        }
                        Assert.fail("Expected Ok, got Error: " + result._0);
                      }));
                it("should handle file URIs correctly", (async function () {
                        var tempFile = Nodepath.join(Nodeos.tmpdir(), "fs-writable-test-" + String(Date.now() | 0) + ".txt");
                        Nodefs.writeFileSync(tempFile, Buffer.from("test"));
                        var uri = Vscode.Uri.file(tempFile);
                        var result = FS$AgdaModeVscode.isWritableFileSystem(uri);
                        if (result.TAG === "Ok") {
                          Assert.ok(result._0);
                        } else {
                          Assert.fail("Expected Ok, got Error: " + result._0);
                        }
                        Nodefs.unlinkSync(tempFile);
                      }));
                it("should return consistent results for the same file system", (async function () {
                        var tempDir1 = Nodepath.join(Nodeos.tmpdir(), "test1");
                        var tempDir2 = Nodepath.join(Nodeos.tmpdir(), "test2");
                        var uri1 = Vscode.Uri.file(tempDir1);
                        var uri2 = Vscode.Uri.file(tempDir2);
                        var result1 = FS$AgdaModeVscode.isWritableFileSystem(uri1);
                        var result2 = FS$AgdaModeVscode.isWritableFileSystem(uri2);
                        if (result1.TAG === "Ok") {
                          if (result2.TAG === "Ok") {
                            return Curry._3(Assert.deepStrictEqual, result1._0, result2._0, undefined);
                          }
                          Assert.fail("Expected Ok for second URI, got Error: " + result2._0);
                          return ;
                        }
                        Assert.fail("Expected Ok for first URI, got Error: " + result1._0);
                      }));
              }));
        describe("readDirectory", (function () {
                it("should return directory contents when directory exists", (async function () {
                        var tempDir = Nodepath.join(Nodeos.tmpdir(), "fs-test-" + String(Date.now() | 0));
                        await Nodefs.promises.mkdir(tempDir, {
                              recursive: true,
                              mode: 511
                            });
                        Nodefs.writeFileSync(Nodepath.join(tempDir, "test.txt"), Buffer.from("test"));
                        await Nodefs.promises.mkdir(Nodepath.join(tempDir, "subdir"), {
                              recursive: true,
                              mode: 511
                            });
                        var uri = Vscode.Uri.file(tempDir);
                        var result = await FS$AgdaModeVscode.readDirectory(uri);
                        if (result.TAG === "Ok") {
                          var entries = result._0;
                          var names = entries.map(function (param) {
                                return param[0];
                              });
                          Assert.ok(names.includes("test.txt"));
                          Assert.ok(names.includes("subdir"));
                          var testFileEntry = entries.find(function (param) {
                                return param[0] === "test.txt";
                              });
                          var subdirEntry = entries.find(function (param) {
                                return param[0] === "subdir";
                              });
                          if (testFileEntry !== undefined && subdirEntry !== undefined) {
                            Assert.ok(true);
                          } else {
                            Assert.fail("Expected to find both file and directory entries");
                          }
                        } else {
                          Assert.fail("Expected Ok, got Error: " + result._0);
                        }
                        Nodefs.unlinkSync(Nodepath.join(tempDir, "test.txt"));
                        Nodefs.rmdirSync(Nodepath.join(tempDir, "subdir"));
                        Nodefs.rmdirSync(tempDir);
                      }));
                it("should return Error when directory does not exist", (async function () {
                        var nonExistentPath = Nodepath.join(Nodeos.tmpdir(), "non-existent-" + String(Date.now() | 0));
                        var uri = Vscode.Uri.file(nonExistentPath);
                        var result = await FS$AgdaModeVscode.readDirectory(uri);
                        if (result.TAG === "Ok") {
                          Assert.fail("Expected Error for non-existent directory, got Ok");
                          return ;
                        }
                        Assert.ok(result._0.length > 0);
                      }));
                it("should return Error when path is a file, not directory", (async function () {
                        var tempFile = Nodepath.join(Nodeos.tmpdir(), "fs-test-file-" + String(Date.now() | 0) + ".txt");
                        Nodefs.writeFileSync(tempFile, Buffer.from("test content"));
                        var uri = Vscode.Uri.file(tempFile);
                        var result = await FS$AgdaModeVscode.readDirectory(uri);
                        if (result.TAG === "Ok") {
                          Assert.fail("Expected Error when trying to read file as directory, got Ok");
                        } else {
                          Assert.ok(result._0.length > 0);
                        }
                        Nodefs.unlinkSync(tempFile);
                      }));
              }));
        describe("readFile", (function () {
                it("should read file content successfully when file exists", (async function () {
                        var tempFile = Nodepath.join(Nodeos.tmpdir(), "fs-readfile-test-" + String(Date.now() | 0) + ".txt");
                        Nodefs.writeFileSync(tempFile, Buffer.from("Hello, VS Code FileSystem!"));
                        var uri = Vscode.Uri.file(tempFile);
                        var result = await FS$AgdaModeVscode.readFile(uri);
                        if (result.TAG === "Ok") {
                          Assert.ok(result._0.length > 0);
                        } else {
                          Assert.fail("Expected Ok, got Error: " + result._0);
                        }
                        Nodefs.unlinkSync(tempFile);
                      }));
                it("should return Error when file does not exist", (async function () {
                        var nonExistentFile = Nodepath.join(Nodeos.tmpdir(), "non-existent-readfile-" + String(Date.now() | 0) + ".txt");
                        var uri = Vscode.Uri.file(nonExistentFile);
                        var result = await FS$AgdaModeVscode.readFile(uri);
                        if (result.TAG === "Ok") {
                          Assert.fail("Expected Error for non-existent file, got Ok");
                          return ;
                        }
                        Assert.ok(result._0.length > 0);
                      }));
                it("should return Error when trying to read a directory as file", (async function () {
                        var tempDir = Nodepath.join(Nodeos.tmpdir(), "fs-readfile-dir-" + String(Date.now() | 0));
                        await Nodefs.promises.mkdir(tempDir, {
                              recursive: true,
                              mode: 511
                            });
                        var uri = Vscode.Uri.file(tempDir);
                        var result = await FS$AgdaModeVscode.readFile(uri);
                        if (result.TAG === "Ok") {
                          Assert.fail("Expected Error when trying to read directory as file, got Ok");
                        } else {
                          Assert.ok(result._0.length > 0);
                        }
                        Nodefs.rmdirSync(tempDir);
                      }));
                it("should handle binary file content correctly", (async function () {
                        var tempFile = Nodepath.join(Nodeos.tmpdir(), "fs-readfile-binary-" + String(Date.now() | 0) + ".bin");
                        var binaryData = Buffer.from([
                              0,
                              1,
                              255,
                              127,
                              0,
                              42
                            ]);
                        Nodefs.writeFileSync(tempFile, binaryData);
                        var uri = Vscode.Uri.file(tempFile);
                        var result = await FS$AgdaModeVscode.readFile(uri);
                        if (result.TAG === "Ok") {
                          var uint8Array = result._0;
                          Curry._3(Assert.deepStrictEqual, uint8Array.length, binaryData.length, undefined);
                          for(var i = 0 ,i_finish = binaryData.length; i < i_finish; ++i){
                            var originalByte = binaryData.readUint8(i) | 0;
                            var readByte = Core__Option.getOr(uint8Array[i], 0);
                            Curry._3(Assert.deepStrictEqual, readByte, originalByte, undefined);
                          }
                        } else {
                          Assert.fail("Expected Ok, got Error: " + result._0);
                        }
                        Nodefs.unlinkSync(tempFile);
                      }));
              }));
      }));

/*  Not a pure module */
