// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Assert = require("assert");
var Vscode = require("vscode");
var Nodefs = require("node:fs");
var Nodeos = require("node:os");
var Nodepath = require("node:path");
var Core__Option = require("@rescript/core/lib/js/src/Core__Option.bs.js");
var FS$AgdaModeVscode = require("../../src/FS.bs.js");

var $$TextEncoder = {};

describe("FS", (function () {
        this.timeout(10000);
        describe("copy", (function () {
                it("should copy file successfully when source exists", (async function () {
                        var tempDir = Nodepath.join(Nodeos.tmpdir(), "fs-copy-test-" + String(Date.now() | 0));
                        var sourceFile = Nodepath.join(tempDir, "source.txt");
                        var destFile = Nodepath.join(tempDir, "dest.txt");
                        await Nodefs.promises.mkdir(tempDir, {
                              recursive: true,
                              mode: 511
                            });
                        var content = "test file content";
                        Nodefs.writeFileSync(sourceFile, Buffer.from(content));
                        var sourceUri = Vscode.Uri.file(sourceFile);
                        var destUri = Vscode.Uri.file(destFile);
                        var result = await FS$AgdaModeVscode.copy(sourceUri, destUri);
                        if (result.TAG === "Ok") {
                          var exists = Nodefs.existsSync(destFile);
                          Assert.ok(exists);
                          var destContent = Nodefs.readFileSync(destFile).toString();
                          Curry._3(Assert.deepStrictEqual, destContent, content, undefined);
                        } else {
                          Assert.fail("Expected Ok, got Error: " + result._0);
                        }
                        Nodefs.unlinkSync(sourceFile);
                        Nodefs.unlinkSync(destFile);
                        Nodefs.rmdirSync(tempDir);
                      }));
                it("should return Error when source file does not exist", (async function () {
                        var nonExistentSource = Nodepath.join(Nodeos.tmpdir(), "non-existent-source-" + String(Date.now() | 0) + ".txt");
                        var destFile = Nodepath.join(Nodeos.tmpdir(), "dest-" + String(Date.now() | 0) + ".txt");
                        var sourceUri = Vscode.Uri.file(nonExistentSource);
                        var destUri = Vscode.Uri.file(destFile);
                        var result = await FS$AgdaModeVscode.copy(sourceUri, destUri);
                        if (result.TAG === "Ok") {
                          Assert.fail("Expected Error for non-existent source, got Ok");
                          return ;
                        }
                        Assert.ok(result._0.length > 0);
                      }));
                it("should create parent directories when copying to non-existent destination directory", (async function () {
                        var tempDir = Nodepath.join(Nodeos.tmpdir(), "fs-copy-test-" + String(Date.now() | 0));
                        var sourceFile = Nodepath.join(tempDir, "source.txt");
                        var destFile = Nodepath.join(tempDir, "nonexistent", "dest.txt");
                        await Nodefs.promises.mkdir(tempDir, {
                              recursive: true,
                              mode: 511
                            });
                        Nodefs.writeFileSync(sourceFile, Buffer.from("test content"));
                        var sourceUri = Vscode.Uri.file(sourceFile);
                        var destUri = Vscode.Uri.file(destFile);
                        var result = await FS$AgdaModeVscode.copy(sourceUri, destUri);
                        if (result.TAG === "Ok") {
                          var exists = Nodefs.existsSync(destFile);
                          Assert.ok(exists);
                          var content = Nodefs.readFileSync(destFile).toString();
                          Curry._3(Assert.deepStrictEqual, content, "test content", undefined);
                        } else {
                          Assert.fail("Expected Ok, got Error: " + result._0);
                        }
                        Nodefs.unlinkSync(sourceFile);
                        Nodefs.unlinkSync(destFile);
                        Nodefs.rmdirSync(Nodepath.join(tempDir, "nonexistent"));
                        Nodefs.rmdirSync(tempDir);
                      }));
              }));
        describe("createDirectory", (function () {
                it("should create directory successfully when parent exists", (async function () {
                        var parentDir = Nodepath.join(Nodeos.tmpdir(), "fs-mkdir-test-" + String(Date.now() | 0));
                        var newDir = Nodepath.join(parentDir, "newdir");
                        await Nodefs.promises.mkdir(parentDir, {
                              recursive: true,
                              mode: 511
                            });
                        var uri = Vscode.Uri.file(newDir);
                        var result = await FS$AgdaModeVscode.createDirectory(uri);
                        if (result.TAG === "Ok") {
                          var exists = Nodefs.existsSync(newDir);
                          Assert.ok(exists);
                        } else {
                          Assert.fail("Expected Ok, got Error: " + result._0);
                        }
                        Nodefs.rmdirSync(newDir);
                        Nodefs.rmdirSync(parentDir);
                      }));
                it("should create parent directories recursively when they don't exist", (async function () {
                        var nonExistentParent = Nodepath.join(Nodeos.tmpdir(), "non-existent-parent-" + String(Date.now() | 0));
                        var newDir = Nodepath.join(nonExistentParent, "newdir");
                        var uri = Vscode.Uri.file(newDir);
                        var result = await FS$AgdaModeVscode.createDirectory(uri);
                        if (result.TAG === "Ok") {
                          var exists = Nodefs.existsSync(newDir);
                          Assert.ok(exists);
                          var parentExists = Nodefs.existsSync(nonExistentParent);
                          Assert.ok(parentExists);
                        } else {
                          Assert.fail("Expected Ok, got Error: " + result._0);
                        }
                        Nodefs.rmdirSync(newDir);
                        Nodefs.rmdirSync(nonExistentParent);
                      }));
                it("should succeed when directory already exists (idempotent)", (async function () {
                        var tempDir = Nodepath.join(Nodeos.tmpdir(), "fs-mkdir-existing-" + String(Date.now() | 0));
                        await Nodefs.promises.mkdir(tempDir, {
                              recursive: true,
                              mode: 511
                            });
                        var uri = Vscode.Uri.file(tempDir);
                        var result = await FS$AgdaModeVscode.createDirectory(uri);
                        if (result.TAG === "Ok") {
                          var exists = Nodefs.existsSync(tempDir);
                          Assert.ok(exists);
                        } else {
                          Assert.fail("Expected Ok, got Error: " + result._0);
                        }
                        Nodefs.rmdirSync(tempDir);
                      }));
              }));
        describe("delete", (function () {
                it("should delete file successfully when file exists", (async function () {
                        var tempFile = Nodepath.join(Nodeos.tmpdir(), "fs-delete-file-" + String(Date.now() | 0) + ".txt");
                        Nodefs.writeFileSync(tempFile, Buffer.from("test content"));
                        var existsBefore = Nodefs.existsSync(tempFile);
                        Assert.ok(existsBefore);
                        var uri = Vscode.Uri.file(tempFile);
                        var result = await FS$AgdaModeVscode.$$delete(uri);
                        if (result.TAG === "Ok") {
                          var existsAfter = Nodefs.existsSync(tempFile);
                          Assert.ok(!existsAfter);
                          return ;
                        }
                        Assert.fail("Expected Ok, got Error: " + result._0);
                      }));
                it("should delete directory successfully when directory exists and is empty", (async function () {
                        var tempDir = Nodepath.join(Nodeos.tmpdir(), "fs-delete-dir-" + String(Date.now() | 0));
                        await Nodefs.promises.mkdir(tempDir, {
                              recursive: true,
                              mode: 511
                            });
                        var existsBefore = Nodefs.existsSync(tempDir);
                        Assert.ok(existsBefore);
                        var uri = Vscode.Uri.file(tempDir);
                        var result = await FS$AgdaModeVscode.$$delete(uri);
                        if (result.TAG === "Ok") {
                          var existsAfter = Nodefs.existsSync(tempDir);
                          Assert.ok(!existsAfter);
                          return ;
                        }
                        Assert.fail("Expected Ok, got Error: " + result._0);
                      }));
                it("should return Error when trying to delete non-empty directory", (async function () {
                        var tempDir = Nodepath.join(Nodeos.tmpdir(), "fs-delete-nonempty-" + String(Date.now() | 0));
                        var file1 = Nodepath.join(tempDir, "file1.txt");
                        await Nodefs.promises.mkdir(tempDir, {
                              recursive: true,
                              mode: 511
                            });
                        Nodefs.writeFileSync(file1, Buffer.from("content1"));
                        Assert.ok(Nodefs.existsSync(tempDir));
                        Assert.ok(Nodefs.existsSync(file1));
                        var uri = Vscode.Uri.file(tempDir);
                        var result = await FS$AgdaModeVscode.$$delete(uri);
                        if (result.TAG === "Ok") {
                          Assert.fail("Expected Error for non-empty directory, got Ok");
                        } else {
                          Assert.ok(result._0.length > 0);
                          Assert.ok(Nodefs.existsSync(tempDir));
                          Assert.ok(Nodefs.existsSync(file1));
                        }
                        Nodefs.unlinkSync(file1);
                        Nodefs.rmdirSync(tempDir);
                      }));
                it("should return Error when trying to delete non-existent file", (async function () {
                        var nonExistentFile = Nodepath.join(Nodeos.tmpdir(), "non-existent-delete-" + String(Date.now() | 0) + ".txt");
                        var uri = Vscode.Uri.file(nonExistentFile);
                        var result = await FS$AgdaModeVscode.$$delete(uri);
                        if (result.TAG === "Ok") {
                          Assert.fail("Expected Error for non-existent file, got Ok");
                          return ;
                        }
                        Assert.ok(result._0.length > 0);
                      }));
              }));
        describe("isWritableFileSystem", (function () {
                it("should return Ok(true) for writable file system (local files)", (async function () {
                        var writableDir = Nodeos.tmpdir();
                        var uri = Vscode.Uri.file(writableDir);
                        var result = FS$AgdaModeVscode.isWritableFileSystem(uri);
                        if (result.TAG === "Ok") {
                          Assert.ok(result._0);
                          return ;
                        }
                        Assert.fail("Expected Ok, got Error: " + result._0);
                      }));
                it("should handle file URIs correctly", (async function () {
                        var tempFile = Nodepath.join(Nodeos.tmpdir(), "fs-writable-test-" + String(Date.now() | 0) + ".txt");
                        Nodefs.writeFileSync(tempFile, Buffer.from("test"));
                        var uri = Vscode.Uri.file(tempFile);
                        var result = FS$AgdaModeVscode.isWritableFileSystem(uri);
                        if (result.TAG === "Ok") {
                          Assert.ok(result._0);
                        } else {
                          Assert.fail("Expected Ok, got Error: " + result._0);
                        }
                        Nodefs.unlinkSync(tempFile);
                      }));
                it("should return consistent results for the same file system", (async function () {
                        var tempDir1 = Nodepath.join(Nodeos.tmpdir(), "test1");
                        var tempDir2 = Nodepath.join(Nodeos.tmpdir(), "test2");
                        var uri1 = Vscode.Uri.file(tempDir1);
                        var uri2 = Vscode.Uri.file(tempDir2);
                        var result1 = FS$AgdaModeVscode.isWritableFileSystem(uri1);
                        var result2 = FS$AgdaModeVscode.isWritableFileSystem(uri2);
                        if (result1.TAG === "Ok") {
                          if (result2.TAG === "Ok") {
                            return Curry._3(Assert.deepStrictEqual, result1._0, result2._0, undefined);
                          }
                          Assert.fail("Expected Ok for second URI, got Error: " + result2._0);
                          return ;
                        }
                        Assert.fail("Expected Ok for first URI, got Error: " + result1._0);
                      }));
              }));
        describe("readDirectory", (function () {
                it("should return directory contents when directory exists", (async function () {
                        var tempDir = Nodepath.join(Nodeos.tmpdir(), "fs-test-" + String(Date.now() | 0));
                        await Nodefs.promises.mkdir(tempDir, {
                              recursive: true,
                              mode: 511
                            });
                        Nodefs.writeFileSync(Nodepath.join(tempDir, "test.txt"), Buffer.from("test"));
                        await Nodefs.promises.mkdir(Nodepath.join(tempDir, "subdir"), {
                              recursive: true,
                              mode: 511
                            });
                        var uri = Vscode.Uri.file(tempDir);
                        var result = await FS$AgdaModeVscode.readDirectory(uri);
                        if (result.TAG === "Ok") {
                          var entries = result._0;
                          var names = entries.map(function (param) {
                                return param[0];
                              });
                          Assert.ok(names.includes("test.txt"));
                          Assert.ok(names.includes("subdir"));
                          var testFileEntry = entries.find(function (param) {
                                return param[0] === "test.txt";
                              });
                          var subdirEntry = entries.find(function (param) {
                                return param[0] === "subdir";
                              });
                          if (testFileEntry !== undefined && subdirEntry !== undefined) {
                            Assert.ok(true);
                          } else {
                            Assert.fail("Expected to find both file and directory entries");
                          }
                        } else {
                          Assert.fail("Expected Ok, got Error: " + result._0);
                        }
                        Nodefs.unlinkSync(Nodepath.join(tempDir, "test.txt"));
                        Nodefs.rmdirSync(Nodepath.join(tempDir, "subdir"));
                        Nodefs.rmdirSync(tempDir);
                      }));
                it("should return Error when directory does not exist", (async function () {
                        var nonExistentPath = Nodepath.join(Nodeos.tmpdir(), "non-existent-" + String(Date.now() | 0));
                        var uri = Vscode.Uri.file(nonExistentPath);
                        var result = await FS$AgdaModeVscode.readDirectory(uri);
                        if (result.TAG === "Ok") {
                          Assert.fail("Expected Error for non-existent directory, got Ok");
                          return ;
                        }
                        Assert.ok(result._0.length > 0);
                      }));
                it("should return Error when path is a file, not directory", (async function () {
                        var tempFile = Nodepath.join(Nodeos.tmpdir(), "fs-test-file-" + String(Date.now() | 0) + ".txt");
                        Nodefs.writeFileSync(tempFile, Buffer.from("test content"));
                        var uri = Vscode.Uri.file(tempFile);
                        var result = await FS$AgdaModeVscode.readDirectory(uri);
                        if (result.TAG === "Ok") {
                          Assert.fail("Expected Error when trying to read file as directory, got Ok");
                        } else {
                          Assert.ok(result._0.length > 0);
                        }
                        Nodefs.unlinkSync(tempFile);
                      }));
              }));
        describe("readFile", (function () {
                it("should read file content successfully when file exists", (async function () {
                        var tempFile = Nodepath.join(Nodeos.tmpdir(), "fs-readfile-test-" + String(Date.now() | 0) + ".txt");
                        Nodefs.writeFileSync(tempFile, Buffer.from("Hello, VS Code FileSystem!"));
                        var uri = Vscode.Uri.file(tempFile);
                        var result = await FS$AgdaModeVscode.readFile(uri);
                        if (result.TAG === "Ok") {
                          Assert.ok(result._0.length > 0);
                        } else {
                          Assert.fail("Expected Ok, got Error: " + result._0);
                        }
                        Nodefs.unlinkSync(tempFile);
                      }));
                it("should return Error when file does not exist", (async function () {
                        var nonExistentFile = Nodepath.join(Nodeos.tmpdir(), "non-existent-readfile-" + String(Date.now() | 0) + ".txt");
                        var uri = Vscode.Uri.file(nonExistentFile);
                        var result = await FS$AgdaModeVscode.readFile(uri);
                        if (result.TAG === "Ok") {
                          Assert.fail("Expected Error for non-existent file, got Ok");
                          return ;
                        }
                        Assert.ok(result._0.length > 0);
                      }));
                it("should return Error when trying to read a directory as file", (async function () {
                        var tempDir = Nodepath.join(Nodeos.tmpdir(), "fs-readfile-dir-" + String(Date.now() | 0));
                        await Nodefs.promises.mkdir(tempDir, {
                              recursive: true,
                              mode: 511
                            });
                        var uri = Vscode.Uri.file(tempDir);
                        var result = await FS$AgdaModeVscode.readFile(uri);
                        if (result.TAG === "Ok") {
                          Assert.fail("Expected Error when trying to read directory as file, got Ok");
                        } else {
                          Assert.ok(result._0.length > 0);
                        }
                        Nodefs.rmdirSync(tempDir);
                      }));
                it("should handle binary file content correctly", (async function () {
                        var tempFile = Nodepath.join(Nodeos.tmpdir(), "fs-readfile-binary-" + String(Date.now() | 0) + ".bin");
                        var binaryData = Buffer.from([
                              0,
                              1,
                              255,
                              127,
                              0,
                              42
                            ]);
                        Nodefs.writeFileSync(tempFile, binaryData);
                        var uri = Vscode.Uri.file(tempFile);
                        var result = await FS$AgdaModeVscode.readFile(uri);
                        if (result.TAG === "Ok") {
                          var uint8Array = result._0;
                          Curry._3(Assert.deepStrictEqual, uint8Array.length, binaryData.length, undefined);
                          for(var i = 0 ,i_finish = binaryData.length; i < i_finish; ++i){
                            var originalByte = binaryData.readUint8(i) | 0;
                            var readByte = Core__Option.getOr(uint8Array[i], 0);
                            Curry._3(Assert.deepStrictEqual, readByte, originalByte, undefined);
                          }
                        } else {
                          Assert.fail("Expected Ok, got Error: " + result._0);
                        }
                        Nodefs.unlinkSync(tempFile);
                      }));
              }));
        describe("rename", (function () {
                it("should rename file successfully when source exists", (async function () {
                        var tempDir = Nodepath.join(Nodeos.tmpdir(), "fs-rename-test-" + String(Date.now() | 0));
                        var sourceFile = Nodepath.join(tempDir, "source.txt");
                        var targetFile = Nodepath.join(tempDir, "target.txt");
                        await Nodefs.promises.mkdir(tempDir, {
                              recursive: true,
                              mode: 511
                            });
                        var content = "test file content";
                        Nodefs.writeFileSync(sourceFile, Buffer.from(content));
                        Assert.ok(Nodefs.existsSync(sourceFile));
                        Assert.ok(!Nodefs.existsSync(targetFile));
                        var sourceUri = Vscode.Uri.file(sourceFile);
                        var targetUri = Vscode.Uri.file(targetFile);
                        var result = await FS$AgdaModeVscode.rename(sourceUri, targetUri);
                        if (result.TAG === "Ok") {
                          Assert.ok(!Nodefs.existsSync(sourceFile));
                          Assert.ok(Nodefs.existsSync(targetFile));
                          var targetContent = Nodefs.readFileSync(targetFile).toString();
                          Curry._3(Assert.deepStrictEqual, targetContent, content, undefined);
                        } else {
                          Assert.fail("Expected Ok, got Error: " + result._0);
                        }
                        Nodefs.unlinkSync(targetFile);
                        Nodefs.rmdirSync(tempDir);
                      }));
                it("should return Error when source file does not exist", (async function () {
                        var nonExistentSource = Nodepath.join(Nodeos.tmpdir(), "non-existent-rename-" + String(Date.now() | 0) + ".txt");
                        var targetFile = Nodepath.join(Nodeos.tmpdir(), "rename-target-" + String(Date.now() | 0) + ".txt");
                        var sourceUri = Vscode.Uri.file(nonExistentSource);
                        var targetUri = Vscode.Uri.file(targetFile);
                        var result = await FS$AgdaModeVscode.rename(sourceUri, targetUri);
                        if (result.TAG === "Ok") {
                          Assert.fail("Expected Error for non-existent source, got Ok");
                          return ;
                        }
                        Assert.ok(result._0.length > 0);
                      }));
                it("should rename directory successfully when source exists", (async function () {
                        var tempDir = Nodepath.join(Nodeos.tmpdir(), "fs-rename-dir-test-" + String(Date.now() | 0));
                        var sourceDir = Nodepath.join(tempDir, "sourcedir");
                        var targetDir = Nodepath.join(tempDir, "targetdir");
                        var testFile = Nodepath.join(sourceDir, "test.txt");
                        await Nodefs.promises.mkdir(tempDir, {
                              recursive: true,
                              mode: 511
                            });
                        await Nodefs.promises.mkdir(sourceDir, {
                              recursive: true,
                              mode: 511
                            });
                        Nodefs.writeFileSync(testFile, Buffer.from("test content"));
                        Assert.ok(Nodefs.existsSync(sourceDir));
                        Assert.ok(Nodefs.existsSync(testFile));
                        Assert.ok(!Nodefs.existsSync(targetDir));
                        var sourceUri = Vscode.Uri.file(sourceDir);
                        var targetUri = Vscode.Uri.file(targetDir);
                        var result = await FS$AgdaModeVscode.rename(sourceUri, targetUri);
                        if (result.TAG === "Ok") {
                          Assert.ok(!Nodefs.existsSync(sourceDir));
                          Assert.ok(Nodefs.existsSync(targetDir));
                          var renamedFile = Nodepath.join(targetDir, "test.txt");
                          Assert.ok(Nodefs.existsSync(renamedFile));
                          var content = Nodefs.readFileSync(renamedFile).toString();
                          Curry._3(Assert.deepStrictEqual, content, "test content", undefined);
                        } else {
                          Assert.fail("Expected Ok, got Error: " + result._0);
                        }
                        Nodefs.unlinkSync(Nodepath.join(targetDir, "test.txt"));
                        Nodefs.rmdirSync(targetDir);
                        Nodefs.rmdirSync(tempDir);
                      }));
                it("should create parent directories when renaming to non-existent destination directory", (async function () {
                        var tempDir = Nodepath.join(Nodeos.tmpdir(), "fs-rename-parent-test-" + String(Date.now() | 0));
                        var sourceFile = Nodepath.join(tempDir, "source.txt");
                        var targetFile = Nodepath.join(tempDir, "nonexistent", "target.txt");
                        await Nodefs.promises.mkdir(tempDir, {
                              recursive: true,
                              mode: 511
                            });
                        Nodefs.writeFileSync(sourceFile, Buffer.from("test content"));
                        var sourceUri = Vscode.Uri.file(sourceFile);
                        var targetUri = Vscode.Uri.file(targetFile);
                        var result = await FS$AgdaModeVscode.rename(sourceUri, targetUri);
                        if (result.TAG === "Ok") {
                          Assert.ok(!Nodefs.existsSync(sourceFile));
                          Assert.ok(Nodefs.existsSync(targetFile));
                          var content = Nodefs.readFileSync(targetFile).toString();
                          Curry._3(Assert.deepStrictEqual, content, "test content", undefined);
                        } else {
                          Assert.fail("Expected Ok, got Error: " + result._0);
                        }
                        Nodefs.unlinkSync(targetFile);
                        Nodefs.rmdirSync(Nodepath.join(tempDir, "nonexistent"));
                        Nodefs.rmdirSync(tempDir);
                      }));
              }));
        describe("stat", (function () {
                it("should return file stats when file exists", (async function () {
                        var tempFile = Nodepath.join(Nodeos.tmpdir(), "fs-stat-file-" + String(Date.now() | 0) + ".txt");
                        var content = "test file content for stat";
                        Nodefs.writeFileSync(tempFile, Buffer.from(content));
                        var uri = Vscode.Uri.file(tempFile);
                        var result = await FS$AgdaModeVscode.stat(uri);
                        if (result.TAG === "Ok") {
                          var fileStat = result._0;
                          Assert.ok(fileStat.type === 1);
                          Curry._3(Assert.deepStrictEqual, fileStat.size, content.length, undefined);
                          var now = Date.now();
                          var mtime = fileStat.mtime;
                          var ctime = fileStat.ctime;
                          Assert.ok(now - mtime < 60000.0);
                          Assert.ok(now - ctime < 60000.0);
                        } else {
                          Assert.fail("Expected Ok, got Error: " + result._0);
                        }
                        Nodefs.unlinkSync(tempFile);
                      }));
                it("should return directory stats when directory exists", (async function () {
                        var tempDir = Nodepath.join(Nodeos.tmpdir(), "fs-stat-dir-" + String(Date.now() | 0));
                        await Nodefs.promises.mkdir(tempDir, {
                              recursive: true,
                              mode: 511
                            });
                        var uri = Vscode.Uri.file(tempDir);
                        var result = await FS$AgdaModeVscode.stat(uri);
                        if (result.TAG === "Ok") {
                          var fileStat = result._0;
                          Assert.ok(fileStat.type === 2);
                          Assert.ok(fileStat.size >= 0);
                          var now = Date.now();
                          var mtime = fileStat.mtime;
                          var ctime = fileStat.ctime;
                          Assert.ok(now - mtime < 60000.0);
                          Assert.ok(now - ctime < 60000.0);
                        } else {
                          Assert.fail("Expected Ok, got Error: " + result._0);
                        }
                        Nodefs.rmdirSync(tempDir);
                      }));
                it("should return Error when file does not exist", (async function () {
                        var nonExistentFile = Nodepath.join(Nodeos.tmpdir(), "non-existent-stat-" + String(Date.now() | 0) + ".txt");
                        var uri = Vscode.Uri.file(nonExistentFile);
                        var result = await FS$AgdaModeVscode.stat(uri);
                        if (result.TAG === "Ok") {
                          Assert.fail("Expected Error for non-existent file, got Ok");
                          return ;
                        }
                        Assert.ok(result._0.length > 0);
                      }));
                it("should distinguish between files and directories", (async function () {
                        var tempDir = Nodepath.join(Nodeos.tmpdir(), "fs-stat-types-" + String(Date.now() | 0));
                        var testFile = Nodepath.join(tempDir, "test.txt");
                        var testSubdir = Nodepath.join(tempDir, "subdir");
                        await Nodefs.promises.mkdir(tempDir, {
                              recursive: true,
                              mode: 511
                            });
                        Nodefs.writeFileSync(testFile, Buffer.from("test"));
                        await Nodefs.promises.mkdir(testSubdir, {
                              recursive: true,
                              mode: 511
                            });
                        var fileUri = Vscode.Uri.file(testFile);
                        var fileResult = await FS$AgdaModeVscode.stat(fileUri);
                        var dirUri = Vscode.Uri.file(testSubdir);
                        var dirResult = await FS$AgdaModeVscode.stat(dirUri);
                        if (fileResult.TAG === "Ok") {
                          var fileStat = fileResult._0;
                          if (dirResult.TAG === "Ok") {
                            var dirStat = dirResult._0;
                            Assert.ok(fileStat.type === 1);
                            Assert.ok(dirStat.type === 2);
                            Assert.ok(fileStat.size === 4);
                            Assert.ok(dirStat.size !== fileStat.size);
                          } else {
                            Assert.fail("Expected Ok for directory stat, got Error: " + dirResult._0);
                          }
                        } else {
                          Assert.fail("Expected Ok for file stat, got Error: " + fileResult._0);
                        }
                        Nodefs.unlinkSync(testFile);
                        Nodefs.rmdirSync(testSubdir);
                        Nodefs.rmdirSync(tempDir);
                      }));
              }));
        describe("writeFile", (function () {
                it("should write file content successfully", (async function () {
                        var tempFile = Nodepath.join(Nodeos.tmpdir(), "fs-writefile-test-" + String(Date.now() | 0) + ".txt");
                        var content = "Hello from FS.writeFile!";
                        var uint8Array = new TextEncoder().encode(content);
                        var uri = Vscode.Uri.file(tempFile);
                        var result = await FS$AgdaModeVscode.writeFile(uri, uint8Array);
                        if (result.TAG === "Ok") {
                          Assert.ok(Nodefs.existsSync(tempFile));
                          var writtenContent = Nodefs.readFileSync(tempFile).toString();
                          Curry._3(Assert.deepStrictEqual, writtenContent, content, undefined);
                        } else {
                          Assert.fail("Expected Ok, got Error: " + result._0);
                        }
                        Nodefs.unlinkSync(tempFile);
                      }));
                it("should overwrite existing file content", (async function () {
                        var tempFile = Nodepath.join(Nodeos.tmpdir(), "fs-writefile-overwrite-" + String(Date.now() | 0) + ".txt");
                        var originalContent = "Original content";
                        var newContent = "New content from FS.writeFile";
                        Nodefs.writeFileSync(tempFile, Buffer.from(originalContent));
                        var readContent1 = Nodefs.readFileSync(tempFile).toString();
                        Curry._3(Assert.deepStrictEqual, readContent1, originalContent, undefined);
                        var uint8Array = new TextEncoder().encode(newContent);
                        var uri = Vscode.Uri.file(tempFile);
                        var result = await FS$AgdaModeVscode.writeFile(uri, uint8Array);
                        if (result.TAG === "Ok") {
                          var readContent2 = Nodefs.readFileSync(tempFile).toString();
                          Curry._3(Assert.deepStrictEqual, readContent2, newContent, undefined);
                        } else {
                          Assert.fail("Expected Ok, got Error: " + result._0);
                        }
                        Nodefs.unlinkSync(tempFile);
                      }));
                it("should create parent directories when writing to non-existent directory", (async function () {
                        var tempDir = Nodepath.join(Nodeos.tmpdir(), "fs-writefile-parent-" + String(Date.now() | 0));
                        var tempFile = Nodepath.join(tempDir, "nested", "test.txt");
                        var content = "Content in nested directory";
                        Assert.ok(!Nodefs.existsSync(tempDir));
                        Assert.ok(!Nodefs.existsSync(Nodepath.join(tempDir, "nested")));
                        var uint8Array = new TextEncoder().encode(content);
                        var uri = Vscode.Uri.file(tempFile);
                        var result = await FS$AgdaModeVscode.writeFile(uri, uint8Array);
                        if (result.TAG === "Ok") {
                          Assert.ok(Nodefs.existsSync(tempFile));
                          var writtenContent = Nodefs.readFileSync(tempFile).toString();
                          Curry._3(Assert.deepStrictEqual, writtenContent, content, undefined);
                        } else {
                          Assert.fail("Expected Ok, got Error: " + result._0);
                        }
                        Nodefs.unlinkSync(tempFile);
                        Nodefs.rmdirSync(Nodepath.join(tempDir, "nested"));
                        Nodefs.rmdirSync(tempDir);
                      }));
                it("should handle binary file content correctly", (async function () {
                        var tempFile = Nodepath.join(Nodeos.tmpdir(), "fs-writefile-binary-" + String(Date.now() | 0) + ".bin");
                        var binaryData = [
                          0,
                          1,
                          255,
                          127,
                          0,
                          42
                        ];
                        var buffer = Buffer.from(binaryData);
                        var uint8Array = new Uint8Array(binaryData);
                        var uri = Vscode.Uri.file(tempFile);
                        var result = await FS$AgdaModeVscode.writeFile(uri, uint8Array);
                        if (result.TAG === "Ok") {
                          Assert.ok(Nodefs.existsSync(tempFile));
                          var writtenBuffer = Nodefs.readFileSync(tempFile);
                          Curry._3(Assert.deepStrictEqual, writtenBuffer.length, buffer.length, undefined);
                          for(var i = 0 ,i_finish = buffer.length; i < i_finish; ++i){
                            var originalByte = buffer.readUint8(i) | 0;
                            var writtenByte = writtenBuffer.readUint8(i) | 0;
                            Curry._3(Assert.deepStrictEqual, writtenByte, originalByte, undefined);
                          }
                        } else {
                          Assert.fail("Expected Ok, got Error: " + result._0);
                        }
                        Nodefs.unlinkSync(tempFile);
                      }));
              }));
      }));

exports.$$TextEncoder = $$TextEncoder;
/*  Not a pure module */
