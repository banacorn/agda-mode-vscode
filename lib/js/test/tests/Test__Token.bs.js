// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Assert = require("assert");
var Token$AgdaModeVscode = require("../../src/Tokens/Token.bs.js");
var Parser$AgdaModeVscode = require("../../src/Parser/Parser.bs.js");
var Json_Decode$JsonCombinators = require("@glennsl/rescript-json-combinators/lib/js/src/Json_Decode.bs.js");

describe("Token", (function () {
        describe("Token.parse", (function () {
                it("should return None for atomic SExpression", (function () {
                        var result = Token$AgdaModeVscode.parse({
                              TAG: "A",
                              _0: "test"
                            });
                        Curry._3(Assert.deepStrictEqual, result, undefined, undefined);
                      }));
                it("should parse basic token without source", (function () {
                        var sexp = {
                          TAG: "L",
                          _0: [
                            {
                              TAG: "A",
                              _0: "10"
                            },
                            {
                              TAG: "A",
                              _0: "20"
                            },
                            {
                              TAG: "L",
                              _0: [{
                                  TAG: "A",
                                  _0: "keyword"
                                }]
                            }
                          ]
                        };
                        var result = Token$AgdaModeVscode.parse(sexp);
                        var expected = {
                          start: 9,
                          end: 19,
                          aspects: ["Keyword"],
                          isTokenBased: false,
                          note: undefined,
                          source: undefined
                        };
                        Curry._3(Assert.deepStrictEqual, result, expected, undefined);
                      }));
                it("should parse token with extra field", (function () {
                        var sexp = {
                          TAG: "L",
                          _0: [
                            {
                              TAG: "A",
                              _0: "5"
                            },
                            {
                              TAG: "A",
                              _0: "15"
                            },
                            {
                              TAG: "L",
                              _0: [{
                                  TAG: "A",
                                  _0: "function"
                                }]
                            },
                            {
                              TAG: "A",
                              _0: "extra"
                            }
                          ]
                        };
                        var result = Token$AgdaModeVscode.parse(sexp);
                        var expected = {
                          start: 4,
                          end: 14,
                          aspects: ["Function"],
                          isTokenBased: false,
                          note: undefined,
                          source: undefined
                        };
                        Curry._3(Assert.deepStrictEqual, result, expected, undefined);
                      }));
                it("should parse token with source information", (function () {
                        var sexp = {
                          TAG: "L",
                          _0: [
                            {
                              TAG: "A",
                              _0: "1"
                            },
                            {
                              TAG: "A",
                              _0: "5"
                            },
                            {
                              TAG: "L",
                              _0: [{
                                  TAG: "A",
                                  _0: "module"
                                }]
                            },
                            {
                              TAG: "A",
                              _0: ""
                            },
                            {
                              TAG: "A",
                              _0: ""
                            },
                            {
                              TAG: "L",
                              _0: [
                                {
                                  TAG: "A",
                                  _0: "/path/to/file.agda"
                                },
                                {
                                  TAG: "A",
                                  _0: ""
                                },
                                {
                                  TAG: "A",
                                  _0: "42"
                                }
                              ]
                            }
                          ]
                        };
                        var result = Token$AgdaModeVscode.parse(sexp);
                        var expected = {
                          start: 0,
                          end: 4,
                          aspects: ["Module"],
                          isTokenBased: false,
                          note: undefined,
                          source: [
                            Parser$AgdaModeVscode.Filepath.make("/path/to/file.agda"),
                            42
                          ]
                        };
                        Curry._3(Assert.deepStrictEqual, result, expected, undefined);
                      }));
                it("should parse token with multiple aspects", (function () {
                        var sexp = {
                          TAG: "L",
                          _0: [
                            {
                              TAG: "A",
                              _0: "100"
                            },
                            {
                              TAG: "A",
                              _0: "110"
                            },
                            {
                              TAG: "L",
                              _0: [
                                {
                                  TAG: "A",
                                  _0: "function"
                                },
                                {
                                  TAG: "A",
                                  _0: "operator"
                                }
                              ]
                            }
                          ]
                        };
                        var result = Token$AgdaModeVscode.parse(sexp);
                        var expected = {
                          start: 99,
                          end: 109,
                          aspects: [
                            "Function",
                            "Operator"
                          ],
                          isTokenBased: false,
                          note: undefined,
                          source: undefined
                        };
                        Curry._3(Assert.deepStrictEqual, result, expected, undefined);
                      }));
                it("should return None for invalid start offset", (function () {
                        var sexp = {
                          TAG: "L",
                          _0: [
                            {
                              TAG: "A",
                              _0: "invalid"
                            },
                            {
                              TAG: "A",
                              _0: "20"
                            },
                            {
                              TAG: "L",
                              _0: [{
                                  TAG: "A",
                                  _0: "keyword"
                                }]
                            }
                          ]
                        };
                        var result = Token$AgdaModeVscode.parse(sexp);
                        Curry._3(Assert.deepStrictEqual, result, undefined, undefined);
                      }));
                it("should return None for invalid end offset", (function () {
                        var sexp = {
                          TAG: "L",
                          _0: [
                            {
                              TAG: "A",
                              _0: "10"
                            },
                            {
                              TAG: "A",
                              _0: "invalid"
                            },
                            {
                              TAG: "L",
                              _0: [{
                                  TAG: "A",
                                  _0: "keyword"
                                }]
                            }
                          ]
                        };
                        var result = Token$AgdaModeVscode.parse(sexp);
                        Curry._3(Assert.deepStrictEqual, result, undefined, undefined);
                      }));
                it("should return None for invalid source index", (function () {
                        var sexp = {
                          TAG: "L",
                          _0: [
                            {
                              TAG: "A",
                              _0: "1"
                            },
                            {
                              TAG: "A",
                              _0: "5"
                            },
                            {
                              TAG: "L",
                              _0: [{
                                  TAG: "A",
                                  _0: "module"
                                }]
                            },
                            {
                              TAG: "A",
                              _0: ""
                            },
                            {
                              TAG: "A",
                              _0: ""
                            },
                            {
                              TAG: "L",
                              _0: [
                                {
                                  TAG: "A",
                                  _0: "/path/to/file.agda"
                                },
                                {
                                  TAG: "A",
                                  _0: ""
                                },
                                {
                                  TAG: "A",
                                  _0: "invalid"
                                }
                              ]
                            }
                          ]
                        };
                        var result = Token$AgdaModeVscode.parse(sexp);
                        Curry._3(Assert.deepStrictEqual, result, undefined, undefined);
                      }));
                it("should return None for malformed SExpression", (function () {
                        var sexp = {
                          TAG: "L",
                          _0: [{
                              TAG: "A",
                              _0: "only_one_element"
                            }]
                        };
                        var result = Token$AgdaModeVscode.parse(sexp);
                        Curry._3(Assert.deepStrictEqual, result, undefined, undefined);
                      }));
              }));
        describe("Token.parseDirectHighlightings", (function () {
                it("should parse empty array", (function () {
                        var result = Token$AgdaModeVscode.parseDirectHighlightings([]);
                        Curry._3(Assert.deepStrictEqual, result, [], undefined);
                      }));
                it("should skip first two elements and parse rest", (function () {
                        var tokens = [
                          {
                            TAG: "A",
                            _0: "skip1"
                          },
                          {
                            TAG: "A",
                            _0: "skip2"
                          },
                          {
                            TAG: "L",
                            _0: [
                              {
                                TAG: "A",
                                _0: "10"
                              },
                              {
                                TAG: "A",
                                _0: "20"
                              },
                              {
                                TAG: "L",
                                _0: [{
                                    TAG: "A",
                                    _0: "keyword"
                                  }]
                              }
                            ]
                          },
                          {
                            TAG: "L",
                            _0: [
                              {
                                TAG: "A",
                                _0: "30"
                              },
                              {
                                TAG: "A",
                                _0: "40"
                              },
                              {
                                TAG: "L",
                                _0: [{
                                    TAG: "A",
                                    _0: "function"
                                  }]
                              }
                            ]
                          }
                        ];
                        var result = Token$AgdaModeVscode.parseDirectHighlightings(tokens);
                        var expected = [
                          {
                            start: 9,
                            end: 19,
                            aspects: ["Keyword"],
                            isTokenBased: false,
                            note: undefined,
                            source: undefined
                          },
                          {
                            start: 29,
                            end: 39,
                            aspects: ["Function"],
                            isTokenBased: false,
                            note: undefined,
                            source: undefined
                          }
                        ];
                        Curry._3(Assert.deepStrictEqual, result, expected, undefined);
                      }));
                it("should filter out invalid tokens", (function () {
                        var tokens = [
                          {
                            TAG: "A",
                            _0: "skip1"
                          },
                          {
                            TAG: "A",
                            _0: "skip2"
                          },
                          {
                            TAG: "L",
                            _0: [
                              {
                                TAG: "A",
                                _0: "10"
                              },
                              {
                                TAG: "A",
                                _0: "20"
                              },
                              {
                                TAG: "L",
                                _0: [{
                                    TAG: "A",
                                    _0: "keyword"
                                  }]
                              }
                            ]
                          },
                          {
                            TAG: "L",
                            _0: [
                              {
                                TAG: "A",
                                _0: "invalid"
                              },
                              {
                                TAG: "A",
                                _0: "40"
                              },
                              {
                                TAG: "L",
                                _0: [{
                                    TAG: "A",
                                    _0: "function"
                                  }]
                              }
                            ]
                          },
                          {
                            TAG: "L",
                            _0: [
                              {
                                TAG: "A",
                                _0: "50"
                              },
                              {
                                TAG: "A",
                                _0: "60"
                              },
                              {
                                TAG: "L",
                                _0: [{
                                    TAG: "A",
                                    _0: "symbol"
                                  }]
                              }
                            ]
                          }
                        ];
                        var result = Token$AgdaModeVscode.parseDirectHighlightings(tokens);
                        var expected = [
                          {
                            start: 9,
                            end: 19,
                            aspects: ["Keyword"],
                            isTokenBased: false,
                            note: undefined,
                            source: undefined
                          },
                          {
                            start: 49,
                            end: 59,
                            aspects: ["Symbol"],
                            isTokenBased: false,
                            note: undefined,
                            source: undefined
                          }
                        ];
                        Curry._3(Assert.deepStrictEqual, result, expected, undefined);
                      }));
              }));
        describe("Token.decodeToken", (function () {
                it("should decode valid JSON token", (function () {
                        var json = JSON.parse("[10, 20, [\"keyword\"], false, null, null]");
                        var result = Json_Decode$JsonCombinators.decode(json, Token$AgdaModeVscode.decodeToken);
                        if (result.TAG === "Ok") {
                          var token = result._0;
                          Curry._3(Assert.deepStrictEqual, token.start, 9, undefined);
                          Curry._3(Assert.deepStrictEqual, token.end, 19, undefined);
                          Curry._3(Assert.deepStrictEqual, token.aspects, ["Keyword"], undefined);
                          Curry._3(Assert.deepStrictEqual, token.isTokenBased, false, undefined);
                          Curry._3(Assert.deepStrictEqual, token.note, undefined, undefined);
                          return Curry._3(Assert.deepStrictEqual, token.source, undefined, undefined);
                        }
                        Assert.fail("Decoding should succeed: " + result._0);
                      }));
                it("should decode token with source", (function () {
                        var json = JSON.parse("[5, 15, [\"module\"], true, \"note\", [\"/path/file.agda\", 100]]");
                        var result = Json_Decode$JsonCombinators.decode(json, Token$AgdaModeVscode.decodeToken);
                        if (result.TAG === "Ok") {
                          var token = result._0;
                          Curry._3(Assert.deepStrictEqual, token.start, 4, undefined);
                          Curry._3(Assert.deepStrictEqual, token.end, 14, undefined);
                          Curry._3(Assert.deepStrictEqual, token.aspects, ["Module"], undefined);
                          Curry._3(Assert.deepStrictEqual, token.isTokenBased, true, undefined);
                          Curry._3(Assert.deepStrictEqual, token.note, "note", undefined);
                          return Curry._3(Assert.deepStrictEqual, token.source, [
                                      Parser$AgdaModeVscode.Filepath.make("/path/file.agda"),
                                      100
                                    ], undefined);
                        }
                        Assert.fail("Decoding should succeed: " + result._0);
                      }));
                it("should handle multiple aspects", (function () {
                        var json = JSON.parse("[1, 10, [\"function\", \"operator\"], false, null, null]");
                        var result = Json_Decode$JsonCombinators.decode(json, Token$AgdaModeVscode.decodeToken);
                        if (result.TAG === "Ok") {
                          return Curry._3(Assert.deepStrictEqual, result._0.aspects, [
                                      "Function",
                                      "Operator"
                                    ], undefined);
                        }
                        Assert.fail("Decoding should succeed: " + result._0);
                      }));
              }));
        describe("Token.decodeResponseHighlightingInfoDirect", (function () {
                it("should decode highlighting response", (function () {
                        var json = JSON.parse("[true, [[10, 20, [\"keyword\"], false, null, null]]]");
                        var result = Json_Decode$JsonCombinators.decode(json, Token$AgdaModeVscode.decodeResponseHighlightingInfoDirect);
                        if (result.TAG === "Ok") {
                          var match = result._0;
                          Curry._3(Assert.deepStrictEqual, match[0], true, undefined);
                          var expectedTokens = [{
                              start: 9,
                              end: 19,
                              aspects: ["Keyword"],
                              isTokenBased: false,
                              note: undefined,
                              source: undefined
                            }];
                          return Curry._3(Assert.deepStrictEqual, match[1], expectedTokens, undefined);
                        }
                        Assert.fail("Decoding should succeed: " + result._0);
                      }));
                it("should decode empty token array", (function () {
                        var json = JSON.parse("[false, []]");
                        var result = Json_Decode$JsonCombinators.decode(json, Token$AgdaModeVscode.decodeResponseHighlightingInfoDirect);
                        if (result.TAG === "Ok") {
                          var match = result._0;
                          Curry._3(Assert.deepStrictEqual, match[0], false, undefined);
                          return Curry._3(Assert.deepStrictEqual, match[1], [], undefined);
                        }
                        Assert.fail("Decoding should succeed: " + result._0);
                      }));
              }));
        describe("Token.toString and toStringWithoutOffsets", (function () {
                var sampleToken_aspects = [
                  "Function",
                  "Operator"
                ];
                var sampleToken_source = [
                  Parser$AgdaModeVscode.Filepath.make("/test.agda"),
                  42
                ];
                var sampleToken = {
                  start: 10,
                  end: 20,
                  aspects: sampleToken_aspects,
                  isTokenBased: false,
                  note: undefined,
                  source: sampleToken_source
                };
                it("should format token with offsets", (function () {
                        var result = Token$AgdaModeVscode.toString(sampleToken);
                        Assert.ok(result.includes("(10, 20)"));
                        Assert.ok(result.includes("Function"));
                        Assert.ok(result.includes("[src: 42]"));
                      }));
                it("should format token without offsets", (function () {
                        var result = Token$AgdaModeVscode.toStringWithoutOffsets(sampleToken);
                        Assert.ok(!result.includes("(10, 20)"));
                        Assert.ok(result.includes("Function"));
                        Assert.ok(result.includes("[src: 42]"));
                      }));
                it("should handle token without source", (function () {
                        var tokenNoSource_aspects = sampleToken_aspects;
                        var tokenNoSource = {
                          start: 10,
                          end: 20,
                          aspects: tokenNoSource_aspects,
                          isTokenBased: false,
                          note: undefined,
                          source: undefined
                        };
                        var result = Token$AgdaModeVscode.toStringWithoutOffsets(tokenNoSource);
                        Assert.ok(!result.includes("[src:"));
                      }));
                it("should handle empty aspects", (function () {
                        var tokenNoAspects_aspects = [];
                        var tokenNoAspects_source = sampleToken_source;
                        var tokenNoAspects = {
                          start: 10,
                          end: 20,
                          aspects: tokenNoAspects_aspects,
                          isTokenBased: false,
                          note: undefined,
                          source: tokenNoAspects_source
                        };
                        var result = Token$AgdaModeVscode.toString(tokenNoAspects);
                        Assert.ok(result.includes("(10, 20)"));
                      }));
              }));
      }));

/*  Not a pure module */
