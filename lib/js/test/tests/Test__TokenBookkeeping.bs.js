// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Assert = require("assert");
var Vscode = require("vscode");
var Editor$AgdaModeVscode = require("../../src/Editor.bs.js");
var Tokens$AgdaModeVscode = require("../../src/Tokens.bs.js");
var Resource$AgdaModeVscode = require("../../src/Resource.bs.js");
var Test__Util$AgdaModeVscode = require("./Test__Util.bs.js");
var Highlighting__SemanticToken$AgdaModeVscode = require("../../src/Highlighting/Highlighting__SemanticToken.bs.js");

describe("Token Bookkeeping\n", (function () {
        var filename = "Issue180.agda";
        var fileContent = {
          contents: ""
        };
        beforeEach(async function () {
              fileContent.contents = await Test__Util$AgdaModeVscode.$$File.read(Test__Util$AgdaModeVscode.Path.asset(filename));
            });
        afterEach(async function () {
              return await Test__Util$AgdaModeVscode.$$File.write(Test__Util$AgdaModeVscode.Path.asset(filename), fileContent.contents);
            });
        it("should work after inserting a newline", (async function () {
                var ctx = await Test__Util$AgdaModeVscode.AgdaMode.makeAndLoad(filename);
                await Editor$AgdaModeVscode.$$Text.insert(ctx.state.document, new Vscode.Position(6, 0), "\n");
                var expected = [
                  "(7:0-3) function",
                  "(7:6-7) type",
                  "(7:10-11) type",
                  "(7:14-15) type",
                  "(8:0-1) variable",
                  "(8:2-3) function",
                  "(8:4-5) variable"
                ];
                var tokens = await Resource$AgdaModeVscode.get(Tokens$AgdaModeVscode.getVSCodeTokens(ctx.state.tokens));
                var actual = tokens.slice(12).map(Highlighting__SemanticToken$AgdaModeVscode.toString);
                return Curry._3(Assert.deepStrictEqual, actual, expected, undefined);
              }));
        it("should work after deleting an empty line", (async function () {
                var ctx = await Test__Util$AgdaModeVscode.AgdaMode.makeAndLoad(filename);
                await Editor$AgdaModeVscode.$$Text.$$delete(ctx.state.document, new Vscode.Range(new Vscode.Position(5, 0), new Vscode.Position(6, 0)));
                var expected = [
                  "(5:0-3) function",
                  "(5:6-7) type",
                  "(5:10-11) type",
                  "(5:14-15) type",
                  "(6:0-1) variable",
                  "(6:2-3) function",
                  "(6:4-5) variable"
                ];
                var tokens = await Resource$AgdaModeVscode.get(Tokens$AgdaModeVscode.getVSCodeTokens(ctx.state.tokens));
                var actual = tokens.slice(12).map(Highlighting__SemanticToken$AgdaModeVscode.toString);
                return Curry._3(Assert.deepStrictEqual, actual, expected, undefined);
              }));
        it("should work after deleting an existing line", (async function () {
                var ctx = await Test__Util$AgdaModeVscode.AgdaMode.makeAndLoad(filename);
                await Editor$AgdaModeVscode.$$Text.$$delete(ctx.state.document, new Vscode.Range(new Vscode.Position(5, 0), new Vscode.Position(7, 0)));
                var expected = [
                  "(5:0-1) variable",
                  "(5:2-3) function",
                  "(5:4-5) variable"
                ];
                var tokens = await Resource$AgdaModeVscode.get(Tokens$AgdaModeVscode.getVSCodeTokens(ctx.state.tokens));
                var actual = tokens.slice(12).map(Highlighting__SemanticToken$AgdaModeVscode.toString);
                return Curry._3(Assert.deepStrictEqual, actual, expected, undefined);
              }));
        it.only("should remove Tokens after Command.Quit", (async function () {
                var ctx = await Test__Util$AgdaModeVscode.AgdaMode.makeAndLoad(filename);
                var tokensBefore = await Resource$AgdaModeVscode.get(Tokens$AgdaModeVscode.getVSCodeTokens(ctx.state.tokens));
                console.log("Test: Before quit, have " + String(tokensBefore.length) + " tokens");
                console.log("Test: Starting quit operation");
                await Test__Util$AgdaModeVscode.AgdaMode.quit(ctx);
                console.log("Test: Quit operation completed");
                console.log("Test: Getting tokens from context after quit");
                var tokens = await Resource$AgdaModeVscode.get(Tokens$AgdaModeVscode.getVSCodeTokens(ctx.state.tokens));
                console.log("Test: After quit, context has " + String(tokens.length) + " tokens");
                return Curry._3(Assert.deepStrictEqual, tokens.length, 0, undefined);
              }));
        it("should update tokens & decorations after each Command.Load", (async function () {
                var filterTerminationProblem = function (__x) {
                  return __x.filter(function (token) {
                              return token.aspects.some(function (aspect) {
                                          return aspect === "TerminationProblem";
                                        });
                            });
                };
                var ctx = await Test__Util$AgdaModeVscode.AgdaMode.makeAndLoad(filename);
                var tokensWithTerminationProblem = filterTerminationProblem(Tokens$AgdaModeVscode.toTokenArray(ctx.state.tokens));
                Curry._3(Assert.deepStrictEqual, tokensWithTerminationProblem.length, 0, undefined);
                var decorationRanges = Array.from(Tokens$AgdaModeVscode.toDecorations(ctx.state.tokens).values()).flat();
                Curry._3(Assert.deepStrictEqual, decorationRanges.length, 0, undefined);
                await Editor$AgdaModeVscode.$$Text.replace(ctx.state.document, new Vscode.Range(new Vscode.Position(7, 8), new Vscode.Position(7, 15)), "x + y");
                await Test__Util$AgdaModeVscode.AgdaMode.execute(ctx, "Load", undefined, undefined);
                var tokensWithTerminationProblem$1 = filterTerminationProblem(Tokens$AgdaModeVscode.toTokenArray(ctx.state.tokens));
                Curry._3(Assert.deepStrictEqual, tokensWithTerminationProblem$1.length, 2, undefined);
                var decorationRanges$1 = Array.from(Tokens$AgdaModeVscode.toDecorations(ctx.state.tokens).values()).flat();
                Curry._3(Assert.deepStrictEqual, decorationRanges$1.length, 2, undefined);
                await Editor$AgdaModeVscode.$$Text.replace(ctx.state.document, new Vscode.Range(new Vscode.Position(7, 8), new Vscode.Position(7, 13)), "{!   !}");
                await Test__Util$AgdaModeVscode.AgdaMode.execute(ctx, "Load", undefined, undefined);
                var tokensWithTerminationProblem$2 = filterTerminationProblem(Tokens$AgdaModeVscode.toTokenArray(ctx.state.tokens));
                Curry._3(Assert.deepStrictEqual, tokensWithTerminationProblem$2.length, 0, undefined);
                var decorationRanges$2 = Array.from(Tokens$AgdaModeVscode.toDecorations(ctx.state.tokens).values()).flat();
                return Curry._3(Assert.deepStrictEqual, decorationRanges$2.length, 0, undefined);
              }));
      }));

/*  Not a pure module */
