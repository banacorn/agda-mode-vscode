// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Os = require("os");
var Diff = require("diff");
var Path = require("path");
var Util = require("util");
var Curry = require("bs-platform/lib/js/curry.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.bs.js");
var Process = require("process");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Assert$BsMocha = require("bs-mocha/lib/js/src/Assert.bs.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Promise$BsMocha = require("bs-mocha/lib/js/src/Promise.bs.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");

var Exn = Caml_exceptions.create("Test__Util-AgdaModeVscode.Exn");

function toAbsolute(filepath) {
  var dirname = typeof __dirname === "undefined" ? undefined : __dirname;
  if (dirname !== undefined) {
    return Path.resolve(dirname, filepath);
  } else {
    return Process.cwd();
  }
}

function extensionPath(param) {
  var dirname = typeof __dirname === "undefined" ? undefined : __dirname;
  if (dirname !== undefined) {
    return Path.resolve(dirname, "../../../../");
  } else {
    return Process.cwd();
  }
}

function asset(filepath) {
  return Path.join(extensionPath(undefined), "test/tests/assets", filepath);
}

var Path$1 = {
  toAbsolute: toAbsolute,
  extensionPath: extensionPath,
  asset: asset
};

function wait(ms) {
  var match = $$Promise.pending(undefined);
  setTimeout(match[1], ms);
  return match[0];
}

function toPromise(f) {
  return new Promise((function (resolve, reject) {
                return $$Promise.get(f, (function (error) {
                              if (error.TAG) {
                                return reject(error._0);
                              } else {
                                return resolve(error._0);
                              }
                            }));
              }));
}

function it(s, f) {
  return Promise$BsMocha.it(s)(undefined, undefined, undefined, (function (param) {
                return toPromise(Curry._1(f, undefined));
              }));
}

function it_only(s, f) {
  return Promise$BsMocha.it_only(s)(undefined, undefined, undefined, (function (param) {
                return toPromise(Curry._1(f, undefined));
              }));
}

function it_skip(s, f) {
  return Promise$BsMocha.it_skip(s)(undefined, undefined, undefined, (function (param) {
                return toPromise(Curry._1(f, undefined));
              }));
}

function before(f) {
  return Promise$BsMocha.before(undefined)(undefined, undefined, undefined, (function (param) {
                return toPromise(Curry._1(f, undefined));
              }));
}

function before_each(f) {
  return Promise$BsMocha.before_each(undefined)(undefined, undefined, undefined, (function (param) {
                return toPromise(Curry._1(f, undefined));
              }));
}

function after(f) {
  return Promise$BsMocha.after(undefined)(undefined, undefined, undefined, (function (param) {
                return toPromise(Curry._1(f, undefined));
              }));
}

function after_each(f) {
  return Promise$BsMocha.after_each(undefined)(undefined, undefined, undefined, (function (param) {
                return toPromise(Curry._1(f, undefined));
              }));
}

var Q = {
  toPromise: toPromise,
  it: it,
  it_only: it_only,
  it_skip: it_skip,
  before: before,
  before_each: before_each,
  after: after,
  after_each: after_each
};

function equal(expected, actual) {
  var tmp;
  try {
    Assert$BsMocha.equal(undefined, actual, expected);
    tmp = {
      TAG: 0,
      _0: undefined,
      [Symbol.for("name")]: "Ok"
    };
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    tmp = {
      TAG: 1,
      _0: exn,
      [Symbol.for("name")]: "Error"
    };
  }
  return $$Promise.resolved(tmp);
}

var A = {
  equal: equal
};

function normalize(string) {
  return string.trim().replace(/\r\n|\r/g, "\n");
}

function serialize(xs) {
  return xs.join("\n");
}

function serializeWith(f, xs) {
  return Belt_Array.map(xs, f).join("\n");
}

function breakInput(input, breakpoints) {
  var breakpoints$prime = Belt_Array.concat([0], breakpoints);
  return Belt_Array.map(Belt_Array.mapWithIndex(breakpoints$prime, (function (i, x) {
                    var next = Belt_Array.get(breakpoints$prime, i + 1 | 0);
                    if (next !== undefined) {
                      return [
                              x,
                              next - x | 0
                            ];
                    } else {
                      return [
                              x,
                              input.length - x | 0
                            ];
                    }
                  })), (function (param) {
                return input.substr(param[0], param[1]);
              }));
}

var Strings = {
  normalize: normalize,
  serialize: serialize,
  serializeWith: serializeWith,
  breakInput: breakInput
};

function getValue(string) {
  return string._0;
}

function fromChangeObject(obj) {
  if (obj.added) {
    return {
            TAG: 0,
            _0: obj.value,
            [Symbol.for("name")]: "Added"
          };
  } else if (obj.removed) {
    return {
            TAG: 1,
            _0: obj.value,
            [Symbol.for("name")]: "Removed"
          };
  } else {
    return {
            TAG: 2,
            _0: obj.value,
            [Symbol.for("name")]: "NoChange"
          };
  }
}

function wordsWithSpace(a, b) {
  return Belt_Array.map(Diff.diffWordsWithSpace(a, b), fromChangeObject);
}

function firstChange(diffs) {
  var count = {
    contents: 0
  };
  var change = {
    contents: undefined
  };
  Belt_Array.forEach(diffs, (function (diff) {
          if (!Belt_Option.isNone(change.contents)) {
            return ;
          }
          switch (diff.TAG | 0) {
            case /* Added */0 :
                change.contents = {
                  TAG: 0,
                  _0: diff._0,
                  [Symbol.for("name")]: "Added"
                };
                return ;
            case /* Removed */1 :
                change.contents = {
                  TAG: 1,
                  _0: diff._0,
                  [Symbol.for("name")]: "Removed"
                };
                return ;
            case /* NoChange */2 :
                count.contents = count.contents + diff._0.length | 0;
                return ;
            
          }
        }));
  return Belt_Option.map(change.contents, (function (change) {
                return [
                        change,
                        count.contents
                      ];
              }));
}

var Diff$1 = {
  getValue: getValue,
  fromChangeObject: fromChangeObject,
  wordsWithSpace: wordsWithSpace,
  firstChange: firstChange
};

function getGoldenFilepaths(directoryPath) {
  var directoryPath$1 = toAbsolute(directoryPath);
  var readdir = Util.promisify(function (prim, prim$1) {
        Fs.readdir(prim, prim$1);
        
      });
  var isInFile = function (param) {
    return param.endsWith(".in");
  };
  var toBasename = function (path) {
    return Path.join(directoryPath$1, Path.basename(path, ".in"));
  };
  return readdir(directoryPath$1).then(function (paths) {
              return Promise.resolve(Belt_Array.map(Belt_Array.keep(paths, isInFile), toBasename));
            });
}

function getGoldenFilepathsSync(directoryPath) {
  var directoryPath$1 = toAbsolute(directoryPath);
  var isInFile = function (param) {
    return param.endsWith(".in");
  };
  var toBasename = function (path) {
    return Path.join(directoryPath$1, Path.basename(path, ".in"));
  };
  return Belt_Array.map(Belt_Array.keep(Fs.readdirSync(directoryPath$1), isInFile), toBasename);
}

var FileMissing = Caml_exceptions.create("Test__Util-AgdaModeVscode.Golden.FileMissing");

function map(param, f) {
  return {
          _0: param._0,
          _1: Curry._1(f, param._1),
          _2: param._2,
          [Symbol.for("name")]: "Golden"
        };
}

function readFile(filepath) {
  var filepath$1 = toAbsolute(filepath);
  var readFile$1 = Util.promisify(function (prim, prim$1) {
        Fs.readFile(prim, prim$1);
        
      });
  return Promise.all([
                readFile$1(filepath$1 + ".in"),
                readFile$1(filepath$1 + ".out")
              ]).then(function (param) {
              if (param.length !== 2) {
                return Promise.reject({
                            RE_EXN_ID: FileMissing,
                            _1: filepath$1
                          });
              }
              var input = param[0];
              var output = param[1];
              return Promise.resolve({
                          _0: filepath$1,
                          _1: input.toString(),
                          _2: normalize(output.toString()),
                          [Symbol.for("name")]: "Golden"
                        });
            });
}

function compare(param) {
  var actual = normalize(param._1);
  var expected = normalize(param._2);
  Belt_Option.forEach(firstChange(wordsWithSpace(actual, expected)), (function (param) {
          var count = param[1];
          var diff = param[0];
          var value = diff._0;
          var expected$1 = expected.substr(Caml_primitive.caml_int_max(0, count - 50 | 0), (50 + value.length | 0) + 50 | 0);
          var actual$1 = actual.substr(Caml_primitive.caml_int_max(0, count - 50 | 0), (50 + value.length | 0) + 50 | 0);
          switch (diff.TAG | 0) {
            case /* Added */0 :
            case /* Removed */1 :
                return Assert$BsMocha.fail$prime(undefined, undefined, undefined, actual$1, expected$1);
            case /* NoChange */2 :
                return ;
            
          }
        }));
  return Promise.resolve(undefined);
}

var Golden = {
  Diff: Diff$1,
  getGoldenFilepaths: getGoldenFilepaths,
  getGoldenFilepathsSync: getGoldenFilepathsSync,
  FileMissing: FileMissing,
  map: map,
  readFile: readFile,
  compare: compare
};

function onUnix(param) {
  var match = Os.type();
  if (match === "Windows_NT") {
    return false;
  } else {
    return true;
  }
}

exports.Exn = Exn;
exports.Path = Path$1;
exports.wait = wait;
exports.Q = Q;
exports.A = A;
exports.Strings = Strings;
exports.Golden = Golden;
exports.onUnix = onUnix;
/* fs Not a pure module */
