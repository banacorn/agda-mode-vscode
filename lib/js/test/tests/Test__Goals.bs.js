// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Assert = require("assert");
var Vscode = require("vscode");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Core__Option = require("@rescript/core/lib/js/src/Core__Option.bs.js");
var OS$AgdaModeVscode = require("../../src/Util/OS.bs.js");
var Agda$AgdaModeVscode = require("../../src/Agda.bs.js");
var Goal$AgdaModeVscode = require("../../src/Goal.bs.js");
var Goals$AgdaModeVscode = require("../../src/Goals.bs.js");
var Editor$AgdaModeVscode = require("../../src/Editor.bs.js");
var Test__Util$AgdaModeVscode = require("./Test__Util.bs.js");

describe("Goals", (function () {
        var filename = "Goals.agda";
        var fileContent = {
          contents: ""
        };
        before(async function () {
              fileContent.contents = await Test__Util$AgdaModeVscode.$$File.read(Test__Util$AgdaModeVscode.Path.asset(filename));
            });
        afterEach(async function () {
              return await Test__Util$AgdaModeVscode.$$File.write(Test__Util$AgdaModeVscode.Path.asset(filename), fileContent.contents);
            });
        after(async function () {
              return await Test__Util$AgdaModeVscode.$$File.write(Test__Util$AgdaModeVscode.Path.asset(filename), fileContent.contents);
            });
        describe("Handle `onDidChangeTextDocument`", (function () {
                it("should instantiate all 5 goals with question marks expanded to holes", (async function () {
                        var ctx = await Test__Util$AgdaModeVscode.AgdaMode.makeAndLoad(filename);
                        Curry._3(Assert.deepStrictEqual, Goals$AgdaModeVscode.serializeGoals(ctx.state.goals), [
                              "#0 [8:12-19)",
                              "#1 [9:19-26)",
                              "#2 [10:20-27)",
                              "#3 [11:19-26)",
                              "#4 [11:27-31)"
                            ], undefined);
                        await Test__Util$AgdaModeVscode.AgdaMode.quit(ctx);
                        var actual = await Test__Util$AgdaModeVscode.$$File.read(Test__Util$AgdaModeVscode.Path.asset(filename));
                        var expected = await Test__Util$AgdaModeVscode.$$File.read(Test__Util$AgdaModeVscode.Path.asset("Goals.agda.out"));
                        return Curry._3(Assert.deepStrictEqual, actual, expected, undefined);
                      }));
                it("should translate goals on an insertion immediately before a goal", (async function () {
                        var ctx = await Test__Util$AgdaModeVscode.AgdaMode.makeAndLoad(filename);
                        await Editor$AgdaModeVscode.$$Text.insert(ctx.state.document, new Vscode.Position(8, 18), " ");
                        Curry._3(Assert.deepStrictEqual, Goals$AgdaModeVscode.serializeGoals(ctx.state.goals), [
                              "#0 [8:12-19)",
                              "#1 [9:20-27)",
                              "#2 [10:20-27)",
                              "#3 [11:19-26)",
                              "#4 [11:27-31)"
                            ], undefined);
                        return await Test__Util$AgdaModeVscode.AgdaMode.quit(ctx);
                      }));
                it("should translate goals on an insertion immediately after a goal", (async function () {
                        var ctx = await Test__Util$AgdaModeVscode.AgdaMode.makeAndLoad(filename);
                        await Editor$AgdaModeVscode.$$Text.insert(ctx.state.document, new Vscode.Position(8, 25), " ");
                        Curry._3(Assert.deepStrictEqual, Goals$AgdaModeVscode.serializeGoals(ctx.state.goals), [
                              "#0 [8:12-19)",
                              "#1 [9:19-26)",
                              "#2 [10:20-27)",
                              "#3 [11:19-26)",
                              "#4 [11:27-31)"
                            ], undefined);
                        return await Test__Util$AgdaModeVscode.AgdaMode.quit(ctx);
                      }));
                it("should destroy a goal after it has been completely deleted", (async function () {
                        var ctx = await Test__Util$AgdaModeVscode.AgdaMode.makeAndLoad(filename);
                        await Editor$AgdaModeVscode.$$Text.$$delete(ctx.state.document, new Vscode.Range(new Vscode.Position(9, 19), new Vscode.Position(9, 26)));
                        Curry._3(Assert.deepStrictEqual, Goals$AgdaModeVscode.serializeGoals(ctx.state.goals), [
                              "#0 [8:12-19)",
                              "#1 [9:19-26)",
                              "#3 [11:19-26)",
                              "#4 [11:27-31)"
                            ], undefined);
                        return await Test__Util$AgdaModeVscode.AgdaMode.quit(ctx);
                      }));
                it("should destroy a goal after it has been completely replaced 1", (async function () {
                        var ctx = await Test__Util$AgdaModeVscode.AgdaMode.makeAndLoad(filename);
                        await Editor$AgdaModeVscode.$$Text.replace(ctx.state.document, new Vscode.Range(new Vscode.Position(9, 19), new Vscode.Position(9, 26)), "       ");
                        Curry._3(Assert.deepStrictEqual, Goals$AgdaModeVscode.serializeGoals(ctx.state.goals), [
                              "#0 [8:12-19)",
                              "#1 [9:19-26)",
                              "#3 [11:19-26)",
                              "#4 [11:27-31)"
                            ], undefined);
                        return await Test__Util$AgdaModeVscode.AgdaMode.quit(ctx);
                      }));
                it("should destroy a goal after it has been completely replaced 2", (async function () {
                        var ctx = await Test__Util$AgdaModeVscode.AgdaMode.makeAndLoad(filename);
                        await Editor$AgdaModeVscode.$$Text.replace(ctx.state.document, new Vscode.Range(new Vscode.Position(10, 17), new Vscode.Position(10, 26)), "::DD");
                        Curry._3(Assert.deepStrictEqual, Goals$AgdaModeVscode.serializeGoals(ctx.state.goals), [
                              "#0 [8:12-19)",
                              "#1 [9:19-26)",
                              "#2 [10:20-27)",
                              "#4 [11:22-26)"
                            ], undefined);
                        return await Test__Util$AgdaModeVscode.AgdaMode.quit(ctx);
                      }));
                it("should only resize a goal after its content has been edited", (async function () {
                        var ctx = await Test__Util$AgdaModeVscode.AgdaMode.makeAndLoad(filename);
                        await Editor$AgdaModeVscode.$$Text.replace(ctx.state.document, new Vscode.Range(new Vscode.Position(9, 22), new Vscode.Position(9, 23)), ":D");
                        Curry._3(Assert.deepStrictEqual, Goals$AgdaModeVscode.serializeGoals(ctx.state.goals), [
                              "#0 [8:12-19)",
                              "#1 [9:19-26)",
                              "#2 [10:20-28)",
                              "#3 [11:19-26)",
                              "#4 [11:27-31)"
                            ], undefined);
                        return await Test__Util$AgdaModeVscode.AgdaMode.quit(ctx);
                      }));
                describe.skip("Restore hole damaged boundaries", (function () {
                        it("should protect against a backspace on the right boundary", (async function () {
                                var ctx = await Test__Util$AgdaModeVscode.AgdaMode.makeAndLoad(filename);
                                await Editor$AgdaModeVscode.$$Text.$$delete(ctx.state.document, new Vscode.Range(new Vscode.Position(9, 25), new Vscode.Position(9, 26)));
                                await Test__Util$AgdaModeVscode.AgdaMode.quit(ctx);
                                var range = new Vscode.Range(new Vscode.Position(9, 19), new Vscode.Position(9, 26));
                                var actual = Editor$AgdaModeVscode.$$Text.get(ctx.state.document, range);
                                Curry._3(Assert.deepStrictEqual, actual, "{!   !}", undefined);
                                return Curry._3(Assert.deepStrictEqual, Goals$AgdaModeVscode.serializeGoals(ctx.state.goals), [
                                            "#0 [92-99)",
                                            "#1 [118-125)",
                                            "#2 [145-152)",
                                            "#3 [171-175)"
                                          ], undefined);
                              }));
                        it("should protect against a deletion on the right boundary", (async function () {
                                var ctx = await Test__Util$AgdaModeVscode.AgdaMode.makeAndLoad(filename);
                                await Editor$AgdaModeVscode.$$Text.$$delete(ctx.state.document, new Vscode.Range(new Vscode.Position(9, 24), new Vscode.Position(9, 25)));
                                await Test__Util$AgdaModeVscode.AgdaMode.quit(ctx);
                                var range = new Vscode.Range(new Vscode.Position(9, 19), new Vscode.Position(9, 26));
                                var actual = Editor$AgdaModeVscode.$$Text.get(ctx.state.document, range);
                                Curry._3(Assert.deepStrictEqual, actual, "{!   !}", undefined);
                                return Curry._3(Assert.deepStrictEqual, Goals$AgdaModeVscode.serializeGoals(ctx.state.goals), [
                                            "#0 [92-99)",
                                            "#1 [118-125)",
                                            "#2 [145-152)",
                                            "#3 [171-175)"
                                          ], undefined);
                              }));
                        it("should protect against a backspace on the left boundary", (async function () {
                                var ctx = await Test__Util$AgdaModeVscode.AgdaMode.makeAndLoad(filename);
                                await Editor$AgdaModeVscode.$$Text.$$delete(ctx.state.document, new Vscode.Range(new Vscode.Position(9, 20), new Vscode.Position(9, 21)));
                                await Test__Util$AgdaModeVscode.AgdaMode.quit(ctx);
                                var range = new Vscode.Range(new Vscode.Position(9, 19), new Vscode.Position(9, 26));
                                var actual = Editor$AgdaModeVscode.$$Text.get(ctx.state.document, range);
                                Curry._3(Assert.deepStrictEqual, actual, "{!   !}", undefined);
                                return Curry._3(Assert.deepStrictEqual, Goals$AgdaModeVscode.serializeGoals(ctx.state.goals), [
                                            "#0 [92-99)",
                                            "#1 [118-125)",
                                            "#2 [145-152)",
                                            "#3 [171-175)"
                                          ], undefined);
                              }));
                        it("should protect against a deletion on the left boundary", (async function () {
                                var ctx = await Test__Util$AgdaModeVscode.AgdaMode.makeAndLoad(filename);
                                await Editor$AgdaModeVscode.$$Text.$$delete(ctx.state.document, new Vscode.Range(new Vscode.Position(9, 19), new Vscode.Position(9, 20)));
                                await Test__Util$AgdaModeVscode.AgdaMode.quit(ctx);
                                var range = new Vscode.Range(new Vscode.Position(9, 19), new Vscode.Position(9, 26));
                                var actual = Editor$AgdaModeVscode.$$Text.get(ctx.state.document, range);
                                Curry._3(Assert.deepStrictEqual, actual, "{!   !}", undefined);
                                return Curry._3(Assert.deepStrictEqual, Goals$AgdaModeVscode.serializeGoals(ctx.state.goals), [
                                            "#0 [92-99)",
                                            "#1 [118-125)",
                                            "#2 [145-152)",
                                            "#3 [171-175)"
                                          ], undefined);
                              }));
                      }));
              }));
        describe("`parseGoalPositionsFromRefine`", (function () {
                it("should find single question mark", (async function () {
                        var actual = Goals$AgdaModeVscode.parseGoalPositionsFromRefine("?");
                        var expected = [[
                            0,
                            1
                          ]];
                        return Curry._3(Assert.deepStrictEqual, actual, expected, undefined);
                      }));
                it("should find question mark surrounded by spaces", (async function () {
                        var actual = Goals$AgdaModeVscode.parseGoalPositionsFromRefine(" ? ");
                        var expected = [[
                            1,
                            2
                          ]];
                        return Curry._3(Assert.deepStrictEqual, actual, expected, undefined);
                      }));
                it("should find multiple question marks", (async function () {
                        var actual = Goals$AgdaModeVscode.parseGoalPositionsFromRefine("(fst ? ?)");
                        var expected = [
                          [
                            5,
                            6
                          ],
                          [
                            7,
                            8
                          ]
                        ];
                        return Curry._3(Assert.deepStrictEqual, actual, expected, undefined);
                      }));
                it("should find question marks with various delimiters", (async function () {
                        var actual = Goals$AgdaModeVscode.parseGoalPositionsFromRefine("(a ? b) {c ? d} e ? f");
                        var expected = [
                          [
                            3,
                            4
                          ],
                          [
                            11,
                            12
                          ],
                          [
                            18,
                            19
                          ]
                        ];
                        return Curry._3(Assert.deepStrictEqual, actual, expected, undefined);
                      }));
                it("should find question mark at start of string", (async function () {
                        var actual = Goals$AgdaModeVscode.parseGoalPositionsFromRefine("? rest");
                        var expected = [[
                            0,
                            1
                          ]];
                        return Curry._3(Assert.deepStrictEqual, actual, expected, undefined);
                      }));
                it("should find question mark at end of string", (async function () {
                        var actual = Goals$AgdaModeVscode.parseGoalPositionsFromRefine("start ?");
                        var expected = [[
                            6,
                            7
                          ]];
                        return Curry._3(Assert.deepStrictEqual, actual, expected, undefined);
                      }));
                it("should ignore question marks in identifiers", (async function () {
                        var actual = Goals$AgdaModeVscode.parseGoalPositionsFromRefine("foo?bar");
                        var expected = [];
                        return Curry._3(Assert.deepStrictEqual, actual, expected, undefined);
                      }));
                it("should handle mixed standalone and non-standalone question marks", (async function () {
                        var actual = Goals$AgdaModeVscode.parseGoalPositionsFromRefine("foo?bar ? baz");
                        var expected = [[
                            8,
                            9
                          ]];
                        return Curry._3(Assert.deepStrictEqual, actual, expected, undefined);
                      }));
                it("should handle empty string", (async function () {
                        var actual = Goals$AgdaModeVscode.parseGoalPositionsFromRefine("");
                        var expected = [];
                        return Curry._3(Assert.deepStrictEqual, actual, expected, undefined);
                      }));
                it("should handle string with no question marks", (async function () {
                        var actual = Goals$AgdaModeVscode.parseGoalPositionsFromRefine("no question marks here");
                        var expected = [];
                        return Curry._3(Assert.deepStrictEqual, actual, expected, undefined);
                      }));
                it("should handle complex expression from real use case", (async function () {
                        var actual = Goals$AgdaModeVscode.parseGoalPositionsFromRefine("record\n{ very-long-field-name-1 = ?\n; very-long-field-name-2 = ?\n; very-long-field-name-3 = ?\n}");
                        var expected = OS$AgdaModeVscode.onUnix ? [
                            [
                              34,
                              35
                            ],
                            [
                              63,
                              64
                            ],
                            [
                              92,
                              93
                            ]
                          ] : [
                            [
                              35,
                              36
                            ],
                            [
                              65,
                              66
                            ],
                            [
                              95,
                              96
                            ]
                          ];
                        return Curry._3(Assert.deepStrictEqual, actual, expected, undefined);
                      }));
                it("should handle underscore delimiter", (async function () {
                        var actual = Goals$AgdaModeVscode.parseGoalPositionsFromRefine("foo_?_bar");
                        var expected = [[
                            4,
                            5
                          ]];
                        return Curry._3(Assert.deepStrictEqual, actual, expected, undefined);
                      }));
                it("should handle all supported delimiters", (async function () {
                        var input = " ?(){}_.\\\"@?";
                        var actual = Goals$AgdaModeVscode.parseGoalPositionsFromRefine(input);
                        var firstPos = input.indexOf("?");
                        var lastPos = input.lastIndexOf("?");
                        var expected = [
                          [
                            firstPos,
                            firstPos + 1 | 0
                          ],
                          [
                            lastPos,
                            lastPos + 1 | 0
                          ]
                        ];
                        return Curry._3(Assert.deepStrictEqual, actual, expected, undefined);
                      }));
              }));
        describe("`getGoalAtCursor`", (function () {
                it("should return `None` when the cursor is not in a hole", (async function () {
                        var ctx = await Test__Util$AgdaModeVscode.AgdaMode.makeAndLoad(filename);
                        Editor$AgdaModeVscode.Cursor.set(ctx.state.editor, new Vscode.Position(0, 0));
                        var actual = Goals$AgdaModeVscode.getGoalAtCursor(ctx.state.goals, ctx.state.editor);
                        await Test__Util$AgdaModeVscode.AgdaMode.quit(ctx);
                        return Curry._3(Assert.deepStrictEqual, actual, undefined, undefined);
                      }));
                it("should return the goal when the cursor is inside a hole", (async function () {
                        var ctx = await Test__Util$AgdaModeVscode.AgdaMode.makeAndLoad(filename);
                        Editor$AgdaModeVscode.Cursor.set(ctx.state.editor, new Vscode.Position(7, 14));
                        var actual = Core__Option.map(Goals$AgdaModeVscode.getGoalAtCursor(ctx.state.goals, ctx.state.editor), Goal$AgdaModeVscode.toString);
                        await Test__Util$AgdaModeVscode.AgdaMode.quit(ctx);
                        return Curry._3(Assert.deepStrictEqual, actual, "#0 [8:12-19)", undefined);
                      }));
                it("should return the goal when the cursor is immediately before a hole", (async function () {
                        var ctx = await Test__Util$AgdaModeVscode.AgdaMode.makeAndLoad(filename);
                        Editor$AgdaModeVscode.Cursor.set(ctx.state.editor, new Vscode.Position(7, 11));
                        var actual = Core__Option.map(Goals$AgdaModeVscode.getGoalAtCursor(ctx.state.goals, ctx.state.editor), Goal$AgdaModeVscode.toString);
                        await Test__Util$AgdaModeVscode.AgdaMode.quit(ctx);
                        return Curry._3(Assert.deepStrictEqual, actual, "#0 [8:12-19)", undefined);
                      }));
                it("should return the goal when the cursor is immediately after a hole", (async function () {
                        var ctx = await Test__Util$AgdaModeVscode.AgdaMode.makeAndLoad(filename);
                        Editor$AgdaModeVscode.Cursor.set(ctx.state.editor, new Vscode.Position(7, 18));
                        var actual = Core__Option.map(Goals$AgdaModeVscode.getGoalAtCursor(ctx.state.goals, ctx.state.editor), Goal$AgdaModeVscode.toString);
                        await Test__Util$AgdaModeVscode.AgdaMode.quit(ctx);
                        return Curry._3(Assert.deepStrictEqual, actual, "#0 [8:12-19)", undefined);
                      }));
              }));
        describe("Jumping between goals", (function () {
                it("should jump to the next goal", (async function () {
                        var ctx = await Test__Util$AgdaModeVscode.AgdaMode.makeAndLoad(filename);
                        Editor$AgdaModeVscode.Cursor.set(ctx.state.editor, new Vscode.Position(0, 0));
                        await Test__Util$AgdaModeVscode.AgdaMode.nextGoal(ctx);
                        Curry._3(Assert.deepStrictEqual, Editor$AgdaModeVscode.Cursor.get(ctx.state.editor), new Vscode.Position(7, 14), undefined);
                        await Test__Util$AgdaModeVscode.AgdaMode.nextGoal(ctx);
                        Curry._3(Assert.deepStrictEqual, Editor$AgdaModeVscode.Cursor.get(ctx.state.editor), new Vscode.Position(8, 21), undefined);
                        await Test__Util$AgdaModeVscode.AgdaMode.nextGoal(ctx);
                        Curry._3(Assert.deepStrictEqual, Editor$AgdaModeVscode.Cursor.get(ctx.state.editor), new Vscode.Position(9, 22), undefined);
                        await Test__Util$AgdaModeVscode.AgdaMode.nextGoal(ctx);
                        Curry._3(Assert.deepStrictEqual, Editor$AgdaModeVscode.Cursor.get(ctx.state.editor), new Vscode.Position(10, 21), undefined);
                        await Test__Util$AgdaModeVscode.AgdaMode.nextGoal(ctx);
                        Curry._3(Assert.deepStrictEqual, Editor$AgdaModeVscode.Cursor.get(ctx.state.editor), new Vscode.Position(10, 28), undefined);
                        await Test__Util$AgdaModeVscode.AgdaMode.nextGoal(ctx);
                        Curry._3(Assert.deepStrictEqual, Editor$AgdaModeVscode.Cursor.get(ctx.state.editor), new Vscode.Position(7, 14), undefined);
                        return await Test__Util$AgdaModeVscode.AgdaMode.quit(ctx);
                      }));
                it("should jump to the previous goal", (async function () {
                        var ctx = await Test__Util$AgdaModeVscode.AgdaMode.makeAndLoad(filename);
                        Editor$AgdaModeVscode.Cursor.set(ctx.state.editor, new Vscode.Position(0, 0));
                        await Test__Util$AgdaModeVscode.AgdaMode.previousGoal(ctx);
                        Curry._3(Assert.deepStrictEqual, Editor$AgdaModeVscode.Cursor.get(ctx.state.editor), new Vscode.Position(10, 28), undefined);
                        await Test__Util$AgdaModeVscode.AgdaMode.previousGoal(ctx);
                        Curry._3(Assert.deepStrictEqual, Editor$AgdaModeVscode.Cursor.get(ctx.state.editor), new Vscode.Position(10, 21), undefined);
                        await Test__Util$AgdaModeVscode.AgdaMode.previousGoal(ctx);
                        Curry._3(Assert.deepStrictEqual, Editor$AgdaModeVscode.Cursor.get(ctx.state.editor), new Vscode.Position(9, 22), undefined);
                        await Test__Util$AgdaModeVscode.AgdaMode.previousGoal(ctx);
                        Curry._3(Assert.deepStrictEqual, Editor$AgdaModeVscode.Cursor.get(ctx.state.editor), new Vscode.Position(8, 21), undefined);
                        await Test__Util$AgdaModeVscode.AgdaMode.previousGoal(ctx);
                        Curry._3(Assert.deepStrictEqual, Editor$AgdaModeVscode.Cursor.get(ctx.state.editor), new Vscode.Position(7, 14), undefined);
                        await Test__Util$AgdaModeVscode.AgdaMode.previousGoal(ctx);
                        Curry._3(Assert.deepStrictEqual, Editor$AgdaModeVscode.Cursor.get(ctx.state.editor), new Vscode.Position(10, 28), undefined);
                        return await Test__Util$AgdaModeVscode.AgdaMode.quit(ctx);
                      }));
              }));
        describe("Cursor placement", (function () {
                it("should place the cursor inside a nearby hole after expanding it", (async function () {
                        var filepath = Test__Util$AgdaModeVscode.Path.asset(filename);
                        await Vscode.workspace.openTextDocument(filepath);
                        var editor = Vscode.window.activeTextEditor;
                        if (editor !== undefined) {
                          Editor$AgdaModeVscode.Cursor.set(Caml_option.valFromOption(editor), new Vscode.Position(8, 18));
                        } else {
                          Assert.fail("Cannot open editor for " + filename);
                        }
                        var ctx = await Test__Util$AgdaModeVscode.AgdaMode.makeAndLoad(filename);
                        return Curry._3(Assert.deepStrictEqual, Editor$AgdaModeVscode.Cursor.get(ctx.state.editor), new Vscode.Position(8, 21), undefined);
                      }));
              }));
        describe("Issue #157", (function () {
                it("should handle nested holes correctly", (async function () {
                        var ctx = await Test__Util$AgdaModeVscode.AgdaMode.makeAndLoad("Issue157.agda");
                        Curry._3(Assert.deepStrictEqual, Goals$AgdaModeVscode.serializeGoals(ctx.state.goals), ["#0 [4:5-26)"], undefined);
                        return await Test__Util$AgdaModeVscode.AgdaMode.quit(ctx);
                      }));
              }));
        describe("Issue #159", (function () {
                it("should create holes in literate agda files", (async function () {
                        var ctx = await Test__Util$AgdaModeVscode.AgdaMode.makeAndLoad("Issue159.lagda.tex");
                        Curry._3(Assert.deepStrictEqual, Goals$AgdaModeVscode.serializeGoals(ctx.state.goals), ["#0 [5:5-7:3)"], undefined);
                        return await Test__Util$AgdaModeVscode.AgdaMode.quit(ctx);
                      }));
              }));
        describe("Issue #211", (function () {
                it("should create a hole on the second line instead of the first line", (async function () {
                        var ctx = await Test__Util$AgdaModeVscode.AgdaMode.makeAndLoad("Issue211.agda");
                        Curry._3(Assert.deepStrictEqual, Goals$AgdaModeVscode.serializeGoals(ctx.state.goals), ["#0 [5:5-12)"], undefined);
                        return await Test__Util$AgdaModeVscode.AgdaMode.quit(ctx);
                      }));
              }));
        describe("Issue #214", (function () {
                it("should not create a hole in non-Agda code blocks", (async function () {
                        var ctx = await Test__Util$AgdaModeVscode.AgdaMode.makeAndLoad("Issue214.lagda.md");
                        Curry._3(Assert.deepStrictEqual, Goals$AgdaModeVscode.serializeGoals(ctx.state.goals), ["#0 [9:11-17)"], undefined);
                        return await Test__Util$AgdaModeVscode.AgdaMode.quit(ctx);
                      }));
              }));
        describe("Issue #229", (function () {
                it("should not create a hole in an indentifier with a question mark", (async function () {
                        var ctx = await Test__Util$AgdaModeVscode.AgdaMode.makeAndLoad("Issue229.agda");
                        await Test__Util$AgdaModeVscode.AgdaMode.execute(ctx, "Refine", Caml_option.some(new Vscode.Position(12, 11)), undefined);
                        Curry._3(Assert.deepStrictEqual, Goals$AgdaModeVscode.serializeGoals(ctx.state.goals), [
                              "#1 [19:9-16)",
                              "#2 [13:13-20)",
                              "#3 [13:21-28)"
                            ], undefined);
                        return await Test__Util$AgdaModeVscode.AgdaMode.quit(ctx);
                      }));
              }));
        describe("Issue #239", (function () {
                it("should commented out holes should be ignored", (async function () {
                        var ctx = await Test__Util$AgdaModeVscode.AgdaMode.makeAndLoad(filename);
                        Curry._3(Assert.deepStrictEqual, Goals$AgdaModeVscode.serializeGoals(ctx.state.goals), [
                              "#0 [8:12-19)",
                              "#1 [9:19-26)",
                              "#2 [10:20-27)",
                              "#3 [11:19-26)",
                              "#4 [11:27-31)"
                            ], undefined);
                        await Editor$AgdaModeVscode.$$Text.insert(ctx.state.document, new Vscode.Position(7, 0), "-- ");
                        await Test__Util$AgdaModeVscode.AgdaMode.execute(ctx, "Load", undefined, undefined);
                        Curry._3(Assert.deepStrictEqual, Goals$AgdaModeVscode.serializeGoals(ctx.state.goals), [
                              "#0 [9:19-26)",
                              "#1 [10:20-27)",
                              "#2 [11:19-26)",
                              "#3 [11:27-31)"
                            ], undefined);
                        return await Test__Util$AgdaModeVscode.AgdaMode.quit(ctx);
                      }));
              }));
        describe.only("Unicode hole placement", (function () {
                var filename = "UnicodeGoalPlacement.agda";
                var fileContent = {
                  contents: ""
                };
                beforeEach(async function () {
                      var content = await Test__Util$AgdaModeVscode.$$File.read(Test__Util$AgdaModeVscode.Path.asset(filename));
                      fileContent.contents = content;
                      console.log("=== FILE CONTENT DEBUG ===");
                      console.log("Filename: " + filename);
                      console.log("File path: " + Test__Util$AgdaModeVscode.Path.asset(filename));
                      console.log("Content length in bytes: " + content.length.toString());
                      console.log("Content length in characters: " + Agda$AgdaModeVscode.OffsetConverter.characterWidth(content).toString());
                      var lines = content.split("\n");
                      console.log("File content (first 10 lines):");
                      var maxLine = lines.length - 1 | 0;
                      var endIndex = maxLine < 9 ? maxLine : 9;
                      for(var i = 0; i <= endIndex; ++i){
                        var line = lines[i];
                        if (line !== undefined) {
                          console.log("  " + (i + 1 | 0).toString() + ": " + line);
                        } else {
                          console.log("  " + (i + 1 | 0).toString() + ": <empty line>");
                        }
                      }
                      var targetLines = [
                        11,
                        15,
                        19,
                        23,
                        27,
                        31
                      ];
                      console.log("Unicode analysis of target lines:");
                      targetLines.forEach(function (lineIndex) {
                            if (lineIndex >= lines.length) {
                              return ;
                            }
                            var line = lines[lineIndex];
                            if (line !== undefined) {
                              console.log("  Line " + (lineIndex + 1 | 0).toString() + ": \"" + line + "\"");
                              console.log("    UTF-16 length: " + line.length.toString());
                              console.log("    Logical length: " + Agda$AgdaModeVscode.OffsetConverter.characterWidth(line).toString());
                              var charCodes = [];
                              for(var i = 0 ,i_finish = line.length; i < i_finish; ++i){
                                charCodes.push((line.charCodeAt(i) | 0).toString());
                              }
                              if (charCodes.length > 0) {
                                console.log("    Char codes: [" + charCodes.join(", ") + "]");
                                return ;
                              } else {
                                return ;
                              }
                            }
                            console.log("  Line " + (lineIndex + 1 | 0).toString() + ": <line not found>");
                          });
                    });
                afterEach(async function () {
                      return await Test__Util$AgdaModeVscode.$$File.write(Test__Util$AgdaModeVscode.Path.asset(filename), fileContent.contents);
                    });
                it("should correctly place holes when Unicode characters are properly handled", (async function () {
                        console.log("=== UNICODE TEST DEBUG START ===");
                        console.log("On Unix: " + (
                              OS$AgdaModeVscode.onUnix ? "true" : "false"
                            ));
                        var ctx = await Test__Util$AgdaModeVscode.AgdaMode.makeAndLoad(filename);
                        var goalPositions = Goals$AgdaModeVscode.serializeGoals(ctx.state.goals);
                        var positions = OS$AgdaModeVscode.onUnix ? [
                            "#0 [12:6-13)",
                            "#1 [16:10-17)",
                            "#2 [20:24-31)",
                            "#3 [24:12-19)",
                            "#4 [24:20-27)",
                            "#5 [28:6-13)",
                            "#6 [32:11-18)"
                          ] : [
                            "#0 [12:6-13)",
                            "#1 [16:10-17)",
                            "#2 [20:24-31)",
                            "#3 [24:12-19)",
                            "#4 [24:20-27)",
                            "#5 [28:6-13)",
                            "#6 [32:11-18)"
                          ];
                        console.log("=== TEST COMPARISON ===");
                        console.log("Expected positions:");
                        positions.forEach(function (pos, i) {
                              console.log("  [" + i.toString() + "]: " + pos);
                            });
                        console.log("Actual positions:");
                        goalPositions.forEach(function (pos, i) {
                              console.log("  [" + i.toString() + "]: " + pos);
                            });
                        if (goalPositions.length !== positions.length) {
                          console.log("LENGTH MISMATCH! Expected: " + positions.length.toString() + ", Actual: " + goalPositions.length.toString());
                        }
                        var actualLen = goalPositions.length;
                        var expectedLen = positions.length;
                        var minLength = actualLen < expectedLen ? actualLen : expectedLen;
                        for(var i = 0; i < minLength; ++i){
                          var match = goalPositions[i];
                          var match$1 = positions[i];
                          if (match !== undefined) {
                            if (match$1 !== undefined) {
                              if (match !== match$1) {
                                console.log("MISMATCH at index " + i.toString() + ":");
                                console.log("  Expected: " + match$1);
                                console.log("  Actual:   " + match);
                              }
                              
                            } else {
                              console.log("EXTRA ACTUAL at index " + i.toString() + ": " + match);
                            }
                          } else if (match$1 !== undefined) {
                            console.log("MISSING ACTUAL at index " + i.toString() + ", expected: " + match$1);
                          }
                          
                        }
                        console.log("=== UNICODE TEST DEBUG END ===");
                        if (OS$AgdaModeVscode.onUnix) {
                          Curry._3(Assert.deepStrictEqual, goalPositions, positions, undefined);
                        } else {
                          console.log("=== WINDOWS ACTUAL POSITIONS (for test update) ===");
                          goalPositions.forEach(function (pos, i) {
                                console.log("            \"#" + i.toString() + " " + pos + "\", // Windows position");
                              });
                          console.log("=== END WINDOWS POSITIONS ===");
                          var expectedCount = positions.length;
                          var actualCount = goalPositions.length;
                          if (actualCount !== expectedCount) {
                            Assert.fail("Expected " + expectedCount.toString() + " goals on Windows, but got " + actualCount.toString());
                          } else {
                            console.log("Windows test passed: correct number of goals detected");
                          }
                        }
                        return await Test__Util$AgdaModeVscode.AgdaMode.quit(ctx);
                      }));
              }));
      }));

/*  Not a pure module */
