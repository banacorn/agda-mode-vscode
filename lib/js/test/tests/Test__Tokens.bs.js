// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Assert = require("assert");
var FastCheck = require("fast-check");
var Util$AgdaModeVscode = require("../../src/Util/Util.bs.js");
var Editor$AgdaModeVscode = require("../../src/Editor.bs.js");
var Tokens$AgdaModeVscode = require("../../src/Tokens.bs.js");
var Test__Util$AgdaModeVscode = require("./Test__Util.bs.js");

describe("Tokens", (function () {
        this.timeout(10000);
        describe("GotoDefinition.agda", (function () {
                it("should produce 28 tokens", (async function () {
                        var ctx = await Test__Util$AgdaModeVscode.AgdaMode.makeAndLoad("GotoDefinition.agda");
                        var tokens = Tokens$AgdaModeVscode.toArray(ctx.state.tokens).map(function (param) {
                              return Editor$AgdaModeVscode.$$Range.toString(param[1]) + " " + Tokens$AgdaModeVscode.Token.toString(param[0]);
                            });
                        return Curry._3(Assert.deepEqual, tokens.length, 28, undefined);
                      }));
                it("should produce correct tokens", (async function () {
                        var ctx = await Test__Util$AgdaModeVscode.AgdaMode.makeAndLoad("GotoDefinition.agda");
                        var tokens = Tokens$AgdaModeVscode.toArray(ctx.state.tokens).map(function (param) {
                              return Editor$AgdaModeVscode.$$Range.toString(param[1]) + " " + Tokens$AgdaModeVscode.Token.toString(param[0]);
                            });
                        var version = ctx.state.agdaVersion;
                        var srcOfPrimitive;
                        if (version !== undefined) {
                          srcOfPrimitive = Util$AgdaModeVscode.Version.gte(version, "2.6.4") ? "[src: 388]" : "[src: 320]";
                        } else {
                          throw {
                                RE_EXN_ID: "Failure",
                                _1: "No Agda version found",
                                Error: new Error()
                              };
                        }
                        return Curry._3(Assert.deepEqual, tokens, [
                                    "0:0-6 (0, 6) [Keyword]",
                                    "0:7-21 (7, 21) [Module] [src: 1]",
                                    "0:22-27 (22, 27) [Keyword]",
                                    "1:0-4 (28, 32) [Keyword]",
                                    "1:5-6 (33, 34) [Datatype] [src: 34]",
                                    "1:7-8 (35, 36) [Symbol]",
                                    "1:9-12 (37, 40) [Primitive] " + srcOfPrimitive,
                                    "1:13-18 (41, 46) [Keyword]",
                                    "2:2-3 (49, 50) [ConstructorInductive] [src: 50]",
                                    "2:4-5 (51, 52) [Symbol]",
                                    "2:6-7 (53, 54) [Datatype] [src: 34]",
                                    "3:2-3 (57, 58) [ConstructorInductive] [src: 58]",
                                    "3:4-5 (59, 60) [Symbol]",
                                    "3:6-7 (61, 62) [Datatype] [src: 34]",
                                    "3:8-9 (63, 64) [Symbol]",
                                    "3:10-11 (65, 66) [Datatype] [src: 34]",
                                    "5:0-3 (68, 71) [Function, Operator] [src: 69]",
                                    "5:4-5 (72, 73) [Symbol]",
                                    "5:6-7 (74, 75) [Datatype] [src: 34]",
                                    "5:8-9 (76, 77) [Symbol]",
                                    "5:10-11 (78, 79) [Datatype] [src: 34]",
                                    "5:12-13 (80, 81) [Symbol]",
                                    "5:14-15 (82, 83) [Datatype] [src: 34]",
                                    "6:0-1 (84, 85) [Bound] [src: 85]",
                                    "6:2-3 (86, 87) [Function, Operator] [src: 69]",
                                    "6:4-5 (88, 89) [Bound] [src: 89]",
                                    "6:6-7 (90, 91) [Symbol]",
                                    "6:8-15 (92, 99) [Hole]"
                                  ], undefined);
                      }));
              }));
        describe("Change", (function () {
                it("`arbitraryBatch` should generate valid changes", (function () {
                        FastCheck.assert(FastCheck.property(Tokens$AgdaModeVscode.Change.arbitraryBatch(undefined), (function (xs) {
                                    return Tokens$AgdaModeVscode.Change.areValid(xs);
                                  })));
                      }));
              }));
        describe("Intervals", (function () {
                it("`empty` should should be valid", (function () {
                        Assert.ok(Tokens$AgdaModeVscode.Intervals.isValid(Tokens$AgdaModeVscode.Intervals.empty));
                      }));
                it("`applyChanges` should result in correct intervals with changes", (function () {
                        FastCheck.assert(FastCheck.property(Tokens$AgdaModeVscode.Change.arbitraryBatch(undefined), (function (changes) {
                                    var result = Tokens$AgdaModeVscode.Intervals.applyChanges(Tokens$AgdaModeVscode.Intervals.empty, changes);
                                    Tokens$AgdaModeVscode.Intervals.debugIsValid(result);
                                    if (Tokens$AgdaModeVscode.Intervals.isValid(result)) {
                                      return Tokens$AgdaModeVscode.Intervals.isValidWRTChanges(result, changes);
                                    } else {
                                      return false;
                                    }
                                  })));
                      }));
                it("`applyChanges` twice should result in correct intervals with changes", (function () {
                        FastCheck.assert(FastCheck.property(Tokens$AgdaModeVscode.Change.arbitraryBatch(undefined), Tokens$AgdaModeVscode.Change.arbitraryBatch(undefined), (function (changes1, changes2) {
                                    console.log("\nchanges1:    " + Util$AgdaModeVscode.Pretty.array(changes1.map(Tokens$AgdaModeVscode.Change.toString)));
                                    console.log("changes2:    " + Util$AgdaModeVscode.Pretty.array(changes2.map(Tokens$AgdaModeVscode.Change.toString)));
                                    var intervals = Tokens$AgdaModeVscode.Intervals.applyChanges(Tokens$AgdaModeVscode.Intervals.empty, changes1);
                                    var intervals$1 = Tokens$AgdaModeVscode.Intervals.applyChanges(intervals, changes2);
                                    console.log("intervals:  " + Tokens$AgdaModeVscode.Intervals.toString(intervals$1));
                                    if (Tokens$AgdaModeVscode.Intervals.isValid(intervals$1)) {
                                      return Tokens$AgdaModeVscode.Intervals.isValidWRTChangeBatches(intervals$1, [
                                                  changes1,
                                                  changes2
                                                ]);
                                    } else {
                                      return false;
                                    }
                                  })));
                      }));
                it.only("COUNTEREXAMPLE: `applyChanges` twice should result in correct intervals with changes", (function () {
                        console.log("example: " + Tokens$AgdaModeVscode.Intervals.toString({
                                  TAG: "Replace",
                                  _0: 12,
                                  _1: 16,
                                  _2: 2,
                                  _3: {
                                    TAG: "Replace",
                                    _0: 20,
                                    _1: 24,
                                    _2: 1,
                                    _3: "EOF",
                                    [Symbol.for("name")]: "Replace"
                                  },
                                  [Symbol.for("name")]: "Replace"
                                }));
                        var changes1 = [{
                            offset: 0,
                            removed: 0,
                            inserted: 0
                          }];
                        var changes2 = [{
                            offset: 0,
                            removed: 0,
                            inserted: 1
                          }];
                        var batches = [
                          changes1,
                          changes2
                        ];
                        var intervals = Tokens$AgdaModeVscode.Intervals.applyChanges(Tokens$AgdaModeVscode.Intervals.empty, changes1);
                        var intervals$1 = Tokens$AgdaModeVscode.Intervals.applyChanges(intervals, changes2);
                        var ok = Tokens$AgdaModeVscode.Intervals.isValid(intervals$1) && Tokens$AgdaModeVscode.Intervals.isValidWRTChangeBatches(intervals$1, batches);
                        console.log("\nchanges1:    " + Util$AgdaModeVscode.Pretty.array(changes1.map(Tokens$AgdaModeVscode.Change.toString)));
                        console.log("changes2:    " + Util$AgdaModeVscode.Pretty.array(changes2.map(Tokens$AgdaModeVscode.Change.toString)));
                        console.log("intervals:  " + Tokens$AgdaModeVscode.Intervals.toString(intervals$1));
                        Assert.ok(ok);
                      }));
              }));
      }));

/*  Not a pure module */
