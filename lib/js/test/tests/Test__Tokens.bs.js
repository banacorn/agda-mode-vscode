// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Assert = require("assert");
var Vscode = require("vscode");
var FastCheck = require("fast-check");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Util$AgdaModeVscode = require("../../src/Util/Util.bs.js");
var Editor$AgdaModeVscode = require("../../src/Editor.bs.js");
var Parser$AgdaModeVscode = require("../../src/Parser/Parser.bs.js");
var Tokens$AgdaModeVscode = require("../../src/Tokens.bs.js");
var Test__Util$AgdaModeVscode = require("./Test__Util.bs.js");

describe("Tokens", (function () {
        this.timeout(10000);
        describe("Token generation", (function () {
                it("should produce 28 tokens", (async function () {
                        var ctx = await Test__Util$AgdaModeVscode.AgdaMode.makeAndLoad("GotoDefinition.agda");
                        var tokens = Tokens$AgdaModeVscode.toArray(ctx.state.tokens).map(function (token) {
                              var range = new Vscode.Range(ctx.state.document.positionAt(token.start), ctx.state.document.positionAt(token.end));
                              return Editor$AgdaModeVscode.$$Range.toString(range) + " " + Tokens$AgdaModeVscode.Token.toString(token);
                            });
                        return Curry._3(Assert.deepStrictEqual, tokens.length, 28, undefined);
                      }));
                it("should produce correct tokens", (async function () {
                        var ctx = await Test__Util$AgdaModeVscode.AgdaMode.makeAndLoad("GotoDefinition.agda");
                        var tokens = Tokens$AgdaModeVscode.toArray(ctx.state.tokens).map(function (token) {
                              var range = new Vscode.Range(ctx.state.document.positionAt(token.start), ctx.state.document.positionAt(token.end));
                              return Editor$AgdaModeVscode.$$Range.toString(range) + " " + Tokens$AgdaModeVscode.Token.toStringWithoutOffsets(token);
                            });
                        var version = ctx.state.agdaVersion;
                        var srcOfPrimitive;
                        if (version !== undefined) {
                          srcOfPrimitive = Util$AgdaModeVscode.Version.gte(version, "2.6.4") ? "[src: 388]" : "[src: 320]";
                        } else {
                          throw {
                                RE_EXN_ID: "Failure",
                                _1: "No Agda version found",
                                Error: new Error()
                              };
                        }
                        return Curry._3(Assert.deepStrictEqual, tokens, [
                                    "0:0-6 [Keyword]",
                                    "0:7-21 [Module] [src: 1]",
                                    "0:22-27 [Keyword]",
                                    "1:0-4 [Keyword]",
                                    "1:5-6 [Datatype] [src: 34]",
                                    "1:7-8 [Symbol]",
                                    "1:9-12 [Primitive] " + srcOfPrimitive,
                                    "1:13-18 [Keyword]",
                                    "2:2-3 [ConstructorInductive] [src: 50]",
                                    "2:4-5 [Symbol]",
                                    "2:6-7 [Datatype] [src: 34]",
                                    "3:2-3 [ConstructorInductive] [src: 58]",
                                    "3:4-5 [Symbol]",
                                    "3:6-7 [Datatype] [src: 34]",
                                    "3:8-9 [Symbol]",
                                    "3:10-11 [Datatype] [src: 34]",
                                    "5:0-3 [Function, Operator] [src: 69]",
                                    "5:4-5 [Symbol]",
                                    "5:6-7 [Datatype] [src: 34]",
                                    "5:8-9 [Symbol]",
                                    "5:10-11 [Datatype] [src: 34]",
                                    "5:12-13 [Symbol]",
                                    "5:14-15 [Datatype] [src: 34]",
                                    "6:0-1 [Bound] [src: 85]",
                                    "6:2-3 [Function, Operator] [src: 69]",
                                    "6:4-5 [Bound] [src: 89]",
                                    "6:6-7 [Symbol]",
                                    "6:8-15 [Hole]"
                                  ], undefined);
                      }));
              }));
        describe("`goToDefinition`", (function () {
                it("should return the position of the definition", (async function () {
                        var ctx = await Test__Util$AgdaModeVscode.AgdaMode.makeAndLoad("Lib.agda");
                        var filepath = Parser$AgdaModeVscode.Filepath.make(ctx.state.document.fileName);
                        var position = new Vscode.Position(12, 27);
                        var thunk = Tokens$AgdaModeVscode.goToDefinition(ctx.state.tokens, ctx.state.document)(filepath, position);
                        if (thunk !== undefined) {
                          var actual = await Caml_option.valFromOption(thunk);
                          var expected = [[
                              new Vscode.Range(new Vscode.Position(12, 26), new Vscode.Position(12, 27)),
                              Parser$AgdaModeVscode.Filepath.toString(filepath),
                              new Vscode.Position(12, 22)
                            ]];
                          return Curry._3(Assert.deepStrictEqual, actual, expected, undefined);
                        }
                        throw {
                              RE_EXN_ID: "Failure",
                              _1: "No definition found for the given position",
                              Error: new Error()
                            };
                      }));
              }));
        describe("Change", (function () {
                it("`arbitraryBatch` should generate valid changes", (function () {
                        FastCheck.assert(FastCheck.property(Tokens$AgdaModeVscode.Change.arbitraryBatch(undefined, undefined), (function (xs) {
                                    return Tokens$AgdaModeVscode.Change.areValid(xs);
                                  })));
                      }));
              }));
        describe("Intervals", (function () {
                it("`empty` should should be valid", (function () {
                        Curry._3(Assert.deepStrictEqual, Tokens$AgdaModeVscode.Intervals.hasError(Tokens$AgdaModeVscode.Intervals.empty), undefined, undefined);
                      }));
                it("`applyChanges` should result in correct intervals with changes", (function () {
                        FastCheck.assert(FastCheck.property(Tokens$AgdaModeVscode.Change.arbitraryBatch(undefined, undefined), (function (changes) {
                                    var result = Tokens$AgdaModeVscode.Intervals.applyChanges(Tokens$AgdaModeVscode.Intervals.empty, changes);
                                    Tokens$AgdaModeVscode.Intervals.debugIsValid(result);
                                    if (Tokens$AgdaModeVscode.Intervals.hasError(result) === undefined) {
                                      return Tokens$AgdaModeVscode.Intervals.isValidWRTChanges(result, changes);
                                    } else {
                                      return false;
                                    }
                                  })));
                      }));
                it("`applyChanges` twice should result in correct intervals with changes", (function () {
                        FastCheck.assert(FastCheck.property(Tokens$AgdaModeVscode.Change.arbitraryBatch(undefined, undefined), Tokens$AgdaModeVscode.Change.arbitraryBatch(undefined, undefined), (function (batch1, batch2) {
                                    var batches = [
                                      batch1,
                                      batch2
                                    ];
                                    var intervals = Tokens$AgdaModeVscode.Intervals.applyChanges(Tokens$AgdaModeVscode.Intervals.applyChanges(Tokens$AgdaModeVscode.Intervals.empty, batch1), batch2);
                                    Curry._3(Assert.deepStrictEqual, Tokens$AgdaModeVscode.Intervals.hasError(intervals), undefined, undefined);
                                    return Tokens$AgdaModeVscode.Intervals.isValidWRTChangeBatches(intervals, batches);
                                  })));
                      }));
              }));
      }));

/*  Not a pure module */
