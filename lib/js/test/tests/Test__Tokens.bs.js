// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Assert = require("assert");
var Vscode = require("vscode");
var FastCheck = require("fast-check");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Util$AgdaModeVscode = require("../../src/Util/Util.bs.js");
var Token$AgdaModeVscode = require("../../src/Tokens/Token.bs.js");
var Editor$AgdaModeVscode = require("../../src/Editor.bs.js");
var Parser$AgdaModeVscode = require("../../src/Parser/Parser.bs.js");
var Tokens$AgdaModeVscode = require("../../src/Tokens.bs.js");
var Test__Util$AgdaModeVscode = require("./Test__Util.bs.js");
var TokenChange$AgdaModeVscode = require("../../src/Tokens/TokenChange.bs.js");
var TokenIntervals$AgdaModeVscode = require("../../src/Tokens/TokenIntervals.bs.js");

describe("Tokens", (function () {
        this.timeout(10000);
        describe("Token generation", (function () {
                it("should produce 28 tokens", (async function () {
                        var ctx = await Test__Util$AgdaModeVscode.AgdaMode.makeAndLoad("GotoDefinition.agda");
                        var tokens = Tokens$AgdaModeVscode.toTokenArray(ctx.state.tokens).map(function (token) {
                              var range = new Vscode.Range(ctx.state.document.positionAt(token.start), ctx.state.document.positionAt(token.end));
                              return Editor$AgdaModeVscode.$$Range.toString(range) + " " + Token$AgdaModeVscode.toString(token);
                            });
                        return Curry._3(Assert.deepStrictEqual, tokens.length, 28, undefined);
                      }));
                it("should produce correct tokens", (async function () {
                        var ctx = await Test__Util$AgdaModeVscode.AgdaMode.makeAndLoad("GotoDefinition.agda");
                        var tokens = Tokens$AgdaModeVscode.toTokenArray(ctx.state.tokens).map(function (token) {
                              var range = new Vscode.Range(ctx.state.document.positionAt(token.start), ctx.state.document.positionAt(token.end));
                              return Editor$AgdaModeVscode.$$Range.toString(range) + " " + Token$AgdaModeVscode.toStringWithoutOffsets(token);
                            });
                        var version = ctx.state.agdaVersion;
                        var srcOfPrimitive;
                        if (version !== undefined) {
                          srcOfPrimitive = Util$AgdaModeVscode.Version.gte(version, "2.6.4") ? "[src: 388]" : "[src: 320]";
                        } else {
                          throw {
                                RE_EXN_ID: "Failure",
                                _1: "No Agda version found",
                                Error: new Error()
                              };
                        }
                        return Curry._3(Assert.deepStrictEqual, tokens, [
                                    "1:1-7 [Keyword]",
                                    "1:8-22 [Module] [src: 1]",
                                    "1:23-28 [Keyword]",
                                    "2:1-5 [Keyword]",
                                    "2:6-7 [Datatype] [src: 34]",
                                    "2:8-9 [Symbol]",
                                    "2:10-13 [Primitive] " + srcOfPrimitive,
                                    "2:14-19 [Keyword]",
                                    "3:3-4 [ConstructorInductive] [src: 50]",
                                    "3:5-6 [Symbol]",
                                    "3:7-8 [Datatype] [src: 34]",
                                    "4:3-4 [ConstructorInductive] [src: 58]",
                                    "4:5-6 [Symbol]",
                                    "4:7-8 [Datatype] [src: 34]",
                                    "4:9-10 [Symbol]",
                                    "4:11-12 [Datatype] [src: 34]",
                                    "6:1-4 [Function, Operator] [src: 69]",
                                    "6:5-6 [Symbol]",
                                    "6:7-8 [Datatype] [src: 34]",
                                    "6:9-10 [Symbol]",
                                    "6:11-12 [Datatype] [src: 34]",
                                    "6:13-14 [Symbol]",
                                    "6:15-16 [Datatype] [src: 34]",
                                    "7:1-2 [Bound] [src: 85]",
                                    "7:3-4 [Function, Operator] [src: 69]",
                                    "7:5-6 [Bound] [src: 89]",
                                    "7:7-8 [Symbol]",
                                    "7:9-16 [Hole]"
                                  ], undefined);
                      }));
              }));
        describe("`goToDefinition`", (function () {
                it("should return the position of the definition", (async function () {
                        var ctx = await Test__Util$AgdaModeVscode.AgdaMode.makeAndLoad("Lib.agda");
                        var filepath = Parser$AgdaModeVscode.Filepath.make(ctx.state.document.fileName);
                        var position = new Vscode.Position(12, 27);
                        var thunk = Tokens$AgdaModeVscode.goToDefinition(ctx.state.tokens, ctx.state.document)(filepath, position);
                        if (thunk !== undefined) {
                          var actual = await Caml_option.valFromOption(thunk);
                          var expected = [[
                              new Vscode.Range(new Vscode.Position(12, 26), new Vscode.Position(12, 27)),
                              Parser$AgdaModeVscode.Filepath.toString(filepath),
                              new Vscode.Position(12, 22)
                            ]];
                          return Curry._3(Assert.deepStrictEqual, actual, expected, undefined);
                        }
                        throw {
                              RE_EXN_ID: "Failure",
                              _1: "No definition found for the given position",
                              Error: new Error()
                            };
                      }));
              }));
        describe("Change", (function () {
                it("`arbitraryBatch` should generate valid changes", (function () {
                        FastCheck.assert(FastCheck.property(TokenChange$AgdaModeVscode.arbitraryBatch(undefined, undefined), (function (xs) {
                                    return TokenChange$AgdaModeVscode.areValid(xs);
                                  })));
                      }));
              }));
        describe("Intervals", (function () {
                it("`empty` should should be valid", (function () {
                        Curry._3(Assert.deepStrictEqual, TokenIntervals$AgdaModeVscode.hasError(TokenIntervals$AgdaModeVscode.empty), undefined, undefined);
                      }));
                it("`applyChanges` should result in correct intervals with changes", (function () {
                        FastCheck.assert(FastCheck.property(TokenChange$AgdaModeVscode.arbitraryBatch(undefined, undefined), (function (changes) {
                                    var result = TokenIntervals$AgdaModeVscode.applyChanges(TokenIntervals$AgdaModeVscode.empty, changes);
                                    TokenIntervals$AgdaModeVscode.debugIsValid(result);
                                    if (TokenIntervals$AgdaModeVscode.hasError(result) === undefined) {
                                      return TokenIntervals$AgdaModeVscode.isValidWRTChanges(result, changes);
                                    } else {
                                      return false;
                                    }
                                  })));
                      }));
                it("`applyChanges` twice should result in correct intervals with changes", (function () {
                        FastCheck.assert(FastCheck.property(TokenChange$AgdaModeVscode.arbitraryBatch(undefined, undefined), TokenChange$AgdaModeVscode.arbitraryBatch(undefined, undefined), (function (batch1, batch2) {
                                    var batches = [
                                      batch1,
                                      batch2
                                    ];
                                    var intervals = TokenIntervals$AgdaModeVscode.applyChanges(TokenIntervals$AgdaModeVscode.applyChanges(TokenIntervals$AgdaModeVscode.empty, batch1), batch2);
                                    Curry._3(Assert.deepStrictEqual, TokenIntervals$AgdaModeVscode.hasError(intervals), undefined, undefined);
                                    return TokenIntervals$AgdaModeVscode.isValidWRTChangeBatches(intervals, batches);
                                  })));
                      }));
              }));
      }));

/*  Not a pure module */
