// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Assert = require("assert");
var Util$AgdaModeVscode = require("../../src/Util/Util.bs.js");
var Test__Util$AgdaModeVscode = require("./Test__Util.bs.js");
var Registry__Connection$AgdaModeVscode = require("../../src/Registry__Connection.bs.js");

async function setup() {
  await Registry__Connection$AgdaModeVscode.shutdown();
  return await Util$AgdaModeVscode.Promise_.$$setTimeout(500);
}

function makeDummyConnection() {
  return ({
    TAG: "Agda",
    _0: {
      chan: { removeAllListeners: () => {} },
      process: { status: "Destroyed" },
      encountedFirstPrompt: false
    },
    _1: "mock-path",
    _2: "2.6.4"
  });
}

describe("Registry__Connection", (function () {
        it("Singleton: acquire returns the same connection for different owners", (async function () {
                await setup();
                var makeCalled = {
                  contents: 0
                };
                var dummyConnection = makeDummyConnection();
                var make = async function () {
                  makeCalled.contents = makeCalled.contents + 1 | 0;
                  return {
                          TAG: "Ok",
                          _0: dummyConnection
                        };
                };
                var res1 = await Registry__Connection$AgdaModeVscode.acquire("owner1", make);
                var res2 = await Registry__Connection$AgdaModeVscode.acquire("owner2", make);
                Curry._3(Assert.deepStrictEqual, res1, {
                      TAG: "Ok",
                      _0: dummyConnection
                    }, undefined);
                Curry._3(Assert.deepStrictEqual, res2, {
                      TAG: "Ok",
                      _0: dummyConnection
                    }, undefined);
                Curry._3(Assert.deepStrictEqual, makeCalled.contents, 1, undefined);
                var view = Registry__Connection$AgdaModeVscode.inspect();
                Curry._3(Assert.deepStrictEqual, view.userCount, 2, undefined);
                return Curry._3(Assert.deepStrictEqual, view.status, "Active", undefined);
              }));
        it("Serialization: concurrent execution is queued", (async function () {
                await setup();
                var dummyConnection = makeDummyConnection();
                var make = async function () {
                  return {
                          TAG: "Ok",
                          _0: dummyConnection
                        };
                };
                await Registry__Connection$AgdaModeVscode.acquire("owner1", make);
                var executionOrder = [];
                var task1 = async function (param) {
                  executionOrder.push("task1-start");
                  await Util$AgdaModeVscode.Promise_.$$setTimeout(50);
                  executionOrder.push("task1-end");
                  return {
                          TAG: "Ok",
                          _0: undefined
                        };
                };
                var task2 = async function (param) {
                  executionOrder.push("task2-start");
                  return {
                          TAG: "Ok",
                          _0: undefined
                        };
                };
                var p1 = Registry__Connection$AgdaModeVscode.execute("owner1", task1);
                var p2 = Registry__Connection$AgdaModeVscode.execute("owner2", task2);
                await p1;
                await p2;
                return Curry._3(Assert.deepStrictEqual, executionOrder, [
                            "task1-start",
                            "task1-end",
                            "task2-start"
                          ], undefined);
              }));
        it("Reentrancy: nested execution from same owner is allowed", (async function () {
                await setup();
                var dummyConnection = makeDummyConnection();
                var make = async function () {
                  return {
                          TAG: "Ok",
                          _0: dummyConnection
                        };
                };
                await Registry__Connection$AgdaModeVscode.acquire("owner1", make);
                var executionOrder = [];
                var task = async function (param) {
                  executionOrder.push("outer-start");
                  await Registry__Connection$AgdaModeVscode.execute("owner1", (async function (param) {
                          executionOrder.push("inner");
                          return {
                                  TAG: "Ok",
                                  _0: undefined
                                };
                        }));
                  executionOrder.push("outer-end");
                  return {
                          TAG: "Ok",
                          _0: undefined
                        };
                };
                await Registry__Connection$AgdaModeVscode.execute("owner1", task);
                return Curry._3(Assert.deepStrictEqual, executionOrder, [
                            "outer-start",
                            "inner",
                            "outer-end"
                          ], undefined);
              }));
        it("Reference Counting: connection is destroyed only when all users release it", (async function () {
                await setup();
                var dummyConnection = makeDummyConnection();
                var make = async function () {
                  return {
                          TAG: "Ok",
                          _0: dummyConnection
                        };
                };
                await Registry__Connection$AgdaModeVscode.acquire("owner1", make);
                await Registry__Connection$AgdaModeVscode.acquire("owner2", make);
                Curry._3(Assert.deepStrictEqual, Registry__Connection$AgdaModeVscode.inspect().userCount, 2, undefined);
                await Registry__Connection$AgdaModeVscode.release("owner1");
                Curry._3(Assert.deepStrictEqual, Registry__Connection$AgdaModeVscode.inspect().userCount, 1, undefined);
                Curry._3(Assert.deepStrictEqual, Registry__Connection$AgdaModeVscode.inspect().status, "Active", undefined);
                await Registry__Connection$AgdaModeVscode.release("owner2");
                return Curry._3(Assert.deepStrictEqual, Registry__Connection$AgdaModeVscode.inspect().status, "Empty", undefined);
              }));
        describe("Real-world Scenario", (function () {
                this.timeout(30000);
                it("should share a single connection mechanism between two different Agda files", (async function () {
                        await setup();
                        var agdaA = await Test__Util$AgdaModeVscode.AgdaMode.makeAndLoad("GotoDefinition.agda");
                        var view1 = Registry__Connection$AgdaModeVscode.inspect();
                        Curry._3(Assert.deepStrictEqual, view1.makeCount, 1, undefined);
                        Curry._3(Assert.deepStrictEqual, view1.userCount, 1, undefined);
                        var agdaB = await Test__Util$AgdaModeVscode.AgdaMode.makeAndLoad("Lib.agda");
                        var view2 = Registry__Connection$AgdaModeVscode.inspect();
                        Curry._3(Assert.deepStrictEqual, view2.makeCount, 1, undefined);
                        Curry._3(Assert.deepStrictEqual, view2.userCount, 2, undefined);
                        Curry._3(Assert.deepStrictEqual, view2.status, "Active", undefined);
                        await Test__Util$AgdaModeVscode.AgdaMode.quit(agdaA);
                        Curry._3(Assert.deepStrictEqual, Registry__Connection$AgdaModeVscode.inspect().userCount, 1, undefined);
                        await Test__Util$AgdaModeVscode.AgdaMode.quit(agdaB);
                        return Curry._3(Assert.deepStrictEqual, Registry__Connection$AgdaModeVscode.inspect().status, "Empty", undefined);
                      }));
              }));
      }));

exports.setup = setup;
exports.makeDummyConnection = makeDummyConnection;
/*  Not a pure module */
