// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var VSCode = require("rescript-vscode/lib/js/src/VSCode.bs.js");
var Vscode = require("vscode");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Core__Option = require("@rescript/core/lib/js/src/Core__Option.bs.js");
var Caml_splice_call = require("rescript/lib/js/caml_splice_call.js");
var IM$AgdaModeVscode = require("../InputMethod/IM.bs.js");
var Log$AgdaModeVscode = require("../State/Log.bs.js");
var Chan$AgdaModeVscode = require("../Util/Chan.bs.js");
var Goals$AgdaModeVscode = require("../Goals.bs.js");
var State$AgdaModeVscode = require("../State/State.bs.js");
var Config$AgdaModeVscode = require("../Config.bs.js");
var Editor$AgdaModeVscode = require("../Editor.bs.js");
var Parser$AgdaModeVscode = require("../Parser/Parser.bs.js");
var Tokens$AgdaModeVscode = require("../Tokens.bs.js");
var Command$AgdaModeVscode = require("../Command.bs.js");
var Memento$AgdaModeVscode = require("../Memento.bs.js");
var Registry$AgdaModeVscode = require("../Registry.bs.js");
var Singleton$AgdaModeVscode = require("../View/Singleton.bs.js");
var State__View$AgdaModeVscode = require("../State/State__View.bs.js");
var TokenChange$AgdaModeVscode = require("../Tokens/TokenChange.bs.js");
var WebviewPanel$AgdaModeVscode = require("../View/WebviewPanel.bs.js");
var QueryJs = require("./../../../../asset/query.js").default;
var State__Command$AgdaModeVscode = require("../State/State__Command.bs.js");
var State__InputMethod$AgdaModeVscode = require("../State/State__InputMethod.bs.js");
var Highlighting__SemanticToken$AgdaModeVscode = require("../Highlighting/Highlighting__SemanticToken.bs.js");

var rawTable = QueryJs;

function isAgda($$document) {
  return /\.agda$|\.lagda/i.test($$document.fileName);
}

function onOpenEditor(callback) {
  Core__Option.forEach(Vscode.window.activeTextEditor, callback);
  return Vscode.window.onDidChangeActiveTextEditor(function (next) {
              Core__Option.forEach(next, callback);
            });
}

function onCloseDocument(callback) {
  return Vscode.workspace.onDidCloseTextDocument(callback);
}

function onTriggerCommand(callback) {
  return Command$AgdaModeVscode.names.map(function (param) {
              var command = param[0];
              return Vscode.commands.registerCommand("agda-mode." + param[1], (function () {
                            return Core__Option.map(Vscode.window.activeTextEditor, (function (editor) {
                                          if (isAgda(editor.document)) {
                                            return callback(command, editor);
                                          } else {
                                            return Promise.resolve(undefined);
                                          }
                                        }));
                          }));
            });
}

var Inputs = {
  onOpenEditor: onOpenEditor,
  onCloseDocument: onCloseDocument,
  onTriggerCommand: onTriggerCommand
};

function initialize(platformDeps, channels, extensionUri, globalStorageUri, memento, editor, semanticTokensRequest, semanticTokensEventEmitter) {
  var panel = Singleton$AgdaModeVscode.Panel.make(extensionUri);
  WebviewPanel$AgdaModeVscode.onceDestroyed(panel).finally(function () {
        Registry$AgdaModeVscode.removeAndDestroyAll();
      });
  var state = State$AgdaModeVscode.make(platformDeps, channels, globalStorageUri, extensionUri, memento, editor, semanticTokensRequest);
  State__View$AgdaModeVscode.Panel.setFontSize(state, Config$AgdaModeVscode.$$Buffer.getFontSize());
  var subscribe = function (disposable) {
    state.subscriptions.push(disposable);
  };
  Core__Option.forEach(semanticTokensEventEmitter, (function (emitter) {
          subscribe(new Vscode.Disposable(Chan$AgdaModeVscode.on(Tokens$AgdaModeVscode.onUpdate(state.tokens), (function () {
                          emitter.fire();
                        }))));
        }));
  var getCurrentEditor = function () {
    var editor = Vscode.window.activeTextEditor;
    if (editor !== undefined) {
      return Caml_option.some(Caml_option.valFromOption(editor));
    } else {
      return Vscode.window.visibleTextEditors[0];
    }
  };
  subscribe(WebviewPanel$AgdaModeVscode.onEvent(State__View$AgdaModeVscode.Panel.get(state), (function ($$event) {
              var editor$p = getCurrentEditor();
              if (editor$p === undefined) {
                return ;
              }
              var fileName = editor.document.fileName;
              var fileName$p = Caml_option.valFromOption(editor$p).document.fileName;
              if (fileName$p === fileName) {
                State__Command$AgdaModeVscode.dispatchCommand(state, {
                      TAG: "EventFromView",
                      _0: $$event
                    });
                return ;
              }
              
            })));
  subscribe(Vscode.window.onDidChangeTextEditorSelection(function ($$event) {
            var $$document = editor.document;
            var intervals = $$event.selections.map(function (selection) {
                  return [
                          $$document.offsetAt(selection.start),
                          $$document.offsetAt(selection.end)
                        ];
                });
            State__InputMethod$AgdaModeVscode.select(state, intervals);
          }));
  subscribe(Vscode.workspace.onDidChangeTextDocument(function ($$event) {
            var changes = IM$AgdaModeVscode.Input.fromTextDocumentChangeEvent(editor, $$event);
            State__InputMethod$AgdaModeVscode.keyUpdateEditorIM(state, changes);
            Tokens$AgdaModeVscode.applyEdit(state.tokens, editor, $$event);
            var changes$1 = $$event.contentChanges.map(TokenChange$AgdaModeVscode.fromTextDocumentContentChangeEvent).toReversed();
            if (changes$1.length !== 0) {
              Goals$AgdaModeVscode.scanAllGoals(state.goals, editor, changes$1);
              return ;
            }
            
          }));
  subscribe(Editor$AgdaModeVscode.Provider.registerDefinitionProvider(function (filepath, position) {
            return Tokens$AgdaModeVscode.goToDefinition(state.tokens, state.document)(Parser$AgdaModeVscode.Filepath.make(filepath), position);
          }));
  return state;
}

function registerDocumentSemanticTokensProvider(onDidChangeSemanticTokens) {
  var tokenTypes = Highlighting__SemanticToken$AgdaModeVscode.TokenType.enumurate;
  var tokenModifiers = Highlighting__SemanticToken$AgdaModeVscode.TokenModifier.enumurate;
  var provideDocumentSemanticTokens = function ($$document, _cancel) {
    return Caml_option.some(Registry$AgdaModeVscode.requestSemanticTokens($$document).then(function (tokens) {
                    var semanticTokensLegend = new Vscode.SemanticTokensLegend(tokenTypes, tokenModifiers);
                    var builder = new Vscode.SemanticTokensBuilder(semanticTokensLegend);
                    tokens.forEach(function (param) {
                          builder.push(Highlighting__SemanticToken$AgdaModeVscode.Module.SingleLineRange.toVsCodeRange(param.range), Highlighting__SemanticToken$AgdaModeVscode.TokenType.toString(param.type_), Core__Option.map(param.modifiers, (function (xs) {
                                      return xs.map(Highlighting__SemanticToken$AgdaModeVscode.TokenModifier.toString);
                                    })));
                        });
                    return builder.build();
                  }));
  };
  return Editor$AgdaModeVscode.Provider.registerDocumentSemanticTokensProvider(provideDocumentSemanticTokens, onDidChangeSemanticTokens, [
              tokenTypes,
              tokenModifiers
            ]);
}

function registerInputMethodHintHoverProvider() {
  return Vscode.languages.registerHoverProvider([
              VSCode.StringOr.make({
                    TAG: "String",
                    _0: "agda"
                  }),
              VSCode.StringOr.make({
                    TAG: "String",
                    _0: "lagda-markdown"
                  }),
              VSCode.StringOr.make({
                    TAG: "String",
                    _0: "markdown"
                  }),
              VSCode.StringOr.make({
                    TAG: "String",
                    _0: "lagda-typst"
                  }),
              VSCode.StringOr.make({
                    TAG: "String",
                    _0: "typst"
                  }),
              VSCode.StringOr.make({
                    TAG: "String",
                    _0: "lagda-tex"
                  }),
              VSCode.StringOr.make({
                    TAG: "String",
                    _0: "lagda-rst"
                  }),
              VSCode.StringOr.make({
                    TAG: "String",
                    _0: "lagda-org"
                  }),
              VSCode.StringOr.make({
                    TAG: "String",
                    _0: "org"
                  }),
              VSCode.StringOr.make({
                    TAG: "String",
                    _0: "lagda-forester"
                  }),
              VSCode.StringOr.make({
                    TAG: "String",
                    _0: "forester"
                  })
            ], {
              provideHover: (function ($$document, position, _token) {
                  var text = $$document.lineAt(position.line).text;
                  var $$char = text.charAt(position.character);
                  var ignoredChars = [" "];
                  var foundInputMethods = ignoredChars.includes($$char) ? undefined : Core__Option.flatMap(Core__Option.map($$char.codePointAt(0), (function (prim) {
                                return String(prim);
                              })), (function (extra) {
                            return rawTable[extra];
                          }));
                  if (foundInputMethods === undefined) {
                    return ;
                  }
                  var sortedMethods = foundInputMethods.toSorted(function (a, b) {
                        return a.length - b.length | 0;
                      });
                  var match = sortedMethods.length;
                  var methodsText;
                  if (match !== 1) {
                    if (match !== 2) {
                      var lastMethod = sortedMethods.at(-1);
                      var otherMethods = sortedMethods.slice(0, -1);
                      methodsText = otherMethods.map(function (m) {
                              return "`\\" + m + "`";
                            }).join(", ") + ", or `\\" + lastMethod + "`";
                    } else {
                      methodsText = "`\\" + sortedMethods[0] + "` or `\\" + sortedMethods[1] + "`";
                    }
                  } else {
                    methodsText = "`\\" + sortedMethods[0] + "`";
                  }
                  var hoverText = "Input sequence: " + methodsText;
                  return Caml_option.some(new Promise((function (resolve, _reject) {
                                    resolve(new Vscode.Hover([new Vscode.MarkdownString(hoverText)]));
                                  })));
                })
            });
}

function finalize(isRestart) {
  if (Registry$AgdaModeVscode.isEmpty()) {
    Singleton$AgdaModeVscode.Panel.destroy();
    if (!isRestart) {
      return Singleton$AgdaModeVscode.DebugBuffer.destroy();
    } else {
      return ;
    }
  }
  
}

function activateWithoutContext(platformDeps, subscriptions, extensionUri, globalStorageUri, memento) {
  var subscribe = function (x) {
    subscriptions.push(x);
  };
  var subscribeMany = function (xs) {
    Caml_splice_call.spliceObjApply(subscriptions, "push", [xs]);
  };
  var semanticTokensEventEmitter = new Vscode.EventEmitter();
  subscribe(new Vscode.Disposable((function () {
              semanticTokensEventEmitter.dispose();
            })));
  var onDidChangeSemanticTokens = semanticTokensEventEmitter.event;
  var channels_inputMethod = Chan$AgdaModeVscode.make();
  var channels_responseHandled = Chan$AgdaModeVscode.make();
  var channels_commandHandled = Chan$AgdaModeVscode.make();
  var channels_log = Chan$AgdaModeVscode.make();
  var channels = {
    inputMethod: channels_inputMethod,
    responseHandled: channels_responseHandled,
    commandHandled: channels_commandHandled,
    log: channels_log
  };
  subscribe(onOpenEditor(function (editor) {
            var $$document = editor.document;
            if (isAgda($$document)) {
              return Core__Option.forEach(Core__Option.flatMap(Registry$AgdaModeVscode.get($$document), (function (entry) {
                                return entry.state;
                              })), (function (state) {
                            state.editor = editor;
                            state.document = $$document;
                            State__Command$AgdaModeVscode.dispatchCommand(state, "Refresh");
                          }));
            }
            
          }));
  subscribe(Vscode.workspace.onDidChangeConfiguration(function ($$event) {
            var agdaModeFontSizeChanged = $$event.affectsConfiguration("agdaMode.buffer.fontSize", undefined);
            var editorFontSizeChanged = $$event.affectsConfiguration("editor.fontSize", undefined);
            if (!(agdaModeFontSizeChanged || editorFontSizeChanged)) {
              return ;
            }
            var newFontSize = Config$AgdaModeVscode.$$Buffer.getFontSize();
            var state = Core__Option.flatMap(Registry$AgdaModeVscode.getAll()[0], (function (entry) {
                    return entry.state;
                  }));
            if (state !== undefined) {
              State__View$AgdaModeVscode.Panel.setFontSize(state, newFontSize);
              return ;
            }
            
          }));
  subscribe(Vscode.workspace.onDidCloseTextDocument(function ($$document) {
            if (isAgda($$document)) {
              Registry$AgdaModeVscode.removeAndDestroy($$document);
              finalize(false);
              return ;
            }
            
          }));
  subscribeMany(onTriggerCommand(async function (command, editor) {
            var $$document = editor.document;
            if (typeof command !== "object") {
              switch (command) {
                case "Quit" :
                    await Registry$AgdaModeVscode.removeAndDestroy($$document);
                    finalize(false);
                    break;
                case "Restart" :
                    await Registry$AgdaModeVscode.removeAndDestroy($$document);
                    finalize(true);
                    break;
                default:
                  
              }
            }
            var exit = 0;
            if (typeof command !== "object") {
              switch (command) {
                case "Load" :
                case "Restart" :
                    exit = 1;
                    break;
                default:
                  
              }
            } else if (command.TAG === "InputMethod") {
              var tmp = command._0;
              if (typeof tmp !== "object" && tmp === "Activate") {
                exit = 1;
              }
              
            }
            if (exit === 1) {
              var entry = Registry$AgdaModeVscode.get($$document);
              if (entry !== undefined) {
                var match = entry.state;
                if (match === undefined) {
                  var state = initialize(platformDeps, channels, extensionUri, globalStorageUri, memento, editor, Caml_option.some(entry.semanticTokens), Caml_option.some(semanticTokensEventEmitter));
                  Registry$AgdaModeVscode.add($$document, state);
                }
                
              } else {
                var state$1 = initialize(platformDeps, channels, extensionUri, globalStorageUri, memento, editor, undefined, Caml_option.some(semanticTokensEventEmitter));
                Registry$AgdaModeVscode.add($$document, state$1);
              }
            }
            var state$2 = Core__Option.flatMap(Registry$AgdaModeVscode.get($$document), (function (entry) {
                    return entry.state;
                  }));
            if (state$2 !== undefined) {
              await State__Command$AgdaModeVscode.dispatchCommand(state$2, command);
              return {
                      TAG: "Ok",
                      _0: state$2
                    };
            }
            
          }));
  subscribe(registerDocumentSemanticTokensProvider(Caml_option.some(onDidChangeSemanticTokens)));
  subscribe(registerInputMethodHintHoverProvider());
  return channels;
}

function activate(platformDeps, context) {
  var subscriptions = context.subscriptions;
  var extensionUri = context.extensionUri;
  var globalStorageUri = context.globalStorageUri;
  var uriString = globalStorageUri.toString();
  var globalStorageUri$1;
  if (uriString.includes("/User/globalStorage/")) {
    var correctedUriString = uriString.replaceAll("/User/globalStorage/", "/Users/globalStorage/");
    globalStorageUri$1 = Vscode.Uri.parse(correctedUriString);
  } else {
    globalStorageUri$1 = globalStorageUri;
  }
  return activateWithoutContext(platformDeps, subscriptions, extensionUri, globalStorageUri$1, Memento$AgdaModeVscode.make(Caml_option.some(context.workspaceState)));
}

function deactivate() {
  
}

exports.rawTable = rawTable;
exports.isAgda = isAgda;
exports.Inputs = Inputs;
exports.initialize = initialize;
exports.registerDocumentSemanticTokensProvider = registerDocumentSemanticTokensProvider;
exports.registerInputMethodHintHoverProvider = registerInputMethodHintHoverProvider;
exports.finalize = finalize;
exports.activateWithoutContext = activateWithoutContext;
exports.activate = activate;
exports.deactivate = deactivate;
/* rawTable Not a pure module */
