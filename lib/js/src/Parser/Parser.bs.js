// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Nodepath = require("node:path");
var Core__Array = require("@rescript/core/lib/js/src/Core__Array.bs.js");
var Core__Option = require("@rescript/core/lib/js/src/Core__Option.bs.js");
var OS$AgdaModeVscode = require("../Util/OS.bs.js");

function splitToLines(s) {
  return Core__Array.filterMap(s.split(/\r\n|\n/).map(function (x) {
                  if (x !== undefined) {
                    return x;
                  }
                  
                }), (function (x) {
                return x;
              }));
}

function map(f, x) {
  if (typeof x !== "object") {
    return "Stop";
  } else {
    return {
            TAG: "Yield",
            _0: f(x._0)
          };
  }
}

function tap(f, x) {
  if (typeof x !== "object") {
    return "Stop";
  }
  var x$1 = x._0;
  f(x$1);
  return {
          TAG: "Yield",
          _0: x$1
        };
}

function flatMap(f, x) {
  if (typeof x !== "object") {
    return "Stop";
  } else {
    return f(x._0);
  }
}

var Gen = {
  map: map,
  tap: tap,
  flatMap: flatMap
};

function make(initialContinuation, callback) {
  return {
          initialContinuation: initialContinuation,
          continuation: {
            contents: undefined
          },
          callback: callback
        };
}

function feed(self, input) {
  var $$continue = Core__Option.getOr(self.continuation.contents, self.initialContinuation);
  var err = $$continue(input);
  switch (err.TAG) {
    case "Error" :
        return self.callback({
                    TAG: "Yield",
                    _0: {
                      TAG: "Error",
                      _0: err._0
                    }
                  });
    case "Continue" :
        self.continuation.contents = err._0;
        return ;
    case "Done" :
        self.callback({
              TAG: "Yield",
              _0: {
                TAG: "Ok",
                _0: err._0
              }
            });
        self.continuation.contents = undefined;
        return ;
    
  }
}

function stop(self) {
  self.callback("Stop");
}

var Incr = {
  Gen: Gen,
  make: make,
  feed: feed,
  stop: stop
};

function toString(x) {
  switch (x) {
    case "StackEmpty" :
        return "StackEmpty";
    case "StackElementNullReference" :
        return "StackElementNullReference";
    case "PreprocessError" :
        return "PreprocessError";
    
  }
}

var SExprParseError = {
  toString: toString
};

function toString$1(x) {
  if (x.TAG === "A") {
    return "\"" + (x._0 + "\"");
  } else {
    return "[" + (x._0.map(toString$1).join(", ") + "]");
  }
}

function preprocess(string) {
  if (string.substring(0, 13) === "cannot read: ") {
    return {
            TAG: "Error",
            _0: string.slice(12)
          };
  } else {
    return {
            TAG: "Ok",
            _0: string
          };
  }
}

function flatten(x) {
  if (x.TAG === "A") {
    return [x._0];
  } else {
    return x._0.map(flatten).flat();
  }
}

function parseWithContinuation(string) {
  var parseSExpression = function (state, string) {
    var in_str = state.in_str;
    var escaped = state.escaped;
    var word = state.word;
    var stack = state.stack;
    var pushToTheTop = function (elem) {
      var index = stack.length - 1 | 0;
      var expr = stack[index];
      if (expr === undefined) {
        return ;
      }
      var xs = expr.contents;
      if (xs.TAG === "A") {
        expr.contents = {
          TAG: "L",
          _0: [
            expr.contents,
            elem
          ]
        };
        return ;
      }
      xs._0.push(elem);
    };
    var totalLength = string.length;
    for(var i = 0; i < totalLength; ++i){
      var $$char = string.charAt(i);
      if (escaped.contents) {
        if ($$char === "n") {
          word.contents = word.contents + "\\";
        }
        word.contents = word.contents + $$char;
        escaped.contents = false;
      } else if (!($$char === "\'" && !in_str.contents)) {
        if ($$char === "(" && !in_str.contents) {
          stack.push({
                contents: {
                  TAG: "L",
                  _0: []
                }
              });
        } else if ($$char === ")" && !in_str.contents) {
          if (word.contents !== "") {
            pushToTheTop({
                  TAG: "A",
                  _0: word.contents
                });
            word.contents = "";
          }
          var expr = stack.pop();
          if (expr !== undefined) {
            pushToTheTop(expr.contents);
          }
          
        } else if ($$char === " " && !in_str.contents) {
          if (word.contents !== "") {
            pushToTheTop({
                  TAG: "A",
                  _0: word.contents
                });
            word.contents = "";
          }
          
        } else if ($$char === "\"") {
          in_str.contents = !in_str.contents;
        } else if ($$char === "\\" && in_str.contents) {
          escaped.contents = true;
        } else {
          word.contents = word.contents + $$char;
        }
      }
      
    }
    var match = stack.length;
    if (match === 0) {
      return {
              TAG: "Error",
              _0: [
                "StackEmpty",
                string
              ]
            };
    }
    if (match !== 1) {
      return {
              TAG: "Continue",
              _0: (function (extra) {
                  return parseSExpression(state, extra);
                })
            };
    }
    var v = stack[0];
    if (v === undefined) {
      return {
              TAG: "Error",
              _0: [
                "StackEmpty",
                string
              ]
            };
    }
    var xs = v.contents;
    if (xs.TAG === "A") {
      return {
              TAG: "Error",
              _0: [
                "StackElementNullReference",
                string
              ]
            };
    }
    var w = xs._0[0];
    if (w !== undefined) {
      return {
              TAG: "Done",
              _0: w
            };
    } else {
      return {
              TAG: "Continue",
              _0: (function (extra) {
                  return parseSExpression(state, extra);
                })
            };
    }
  };
  var initialState = function () {
    return {
            stack: [{
                contents: {
                  TAG: "L",
                  _0: []
                }
              }],
            word: {
              contents: ""
            },
            escaped: {
              contents: false
            },
            in_str: {
              contents: false
            }
          };
  };
  var processed = preprocess(string);
  if (processed.TAG === "Ok") {
    return parseSExpression(initialState(), processed._0);
  } else {
    return {
            TAG: "Error",
            _0: [
              "PreprocessError",
              string
            ]
          };
  }
}

function parse(input) {
  var resultAccum = {
    contents: []
  };
  var continuation = {
    contents: undefined
  };
  splitToLines(input).forEach(function (line) {
        var $$continue = Core__Option.getOr(continuation.contents, parseWithContinuation);
        var err = $$continue(line);
        switch (err.TAG) {
          case "Error" :
              resultAccum.contents.push({
                    TAG: "Error",
                    _0: err._0
                  });
              return ;
          case "Continue" :
              continuation.contents = err._0;
              return ;
          case "Done" :
              resultAccum.contents.push({
                    TAG: "Ok",
                    _0: err._0
                  });
              continuation.contents = undefined;
              return ;
          
        }
      });
  return resultAccum.contents;
}

function makeIncr(callback) {
  return make(parseWithContinuation, callback);
}

var SExpression = {
  toString: toString$1,
  preprocess: preprocess,
  flatten: flatten,
  parseWithContinuation: parseWithContinuation,
  parse: parse,
  makeIncr: makeIncr
};

function toString$2(x) {
  if (x.TAG === "SExpression") {
    return "Something went wrong when parsing S-expressions. Error code " + (toString(x._0) + (" \"" + (x._1 + "\"")));
  } else {
    return "Perhaps the underlying protocol used by Agda for communicating with agda-mode has changed.\nPlease report which version of Agda you are using.\nError code: R" + (String(x._0) + (" \"" + (toString$1(x._1) + "\"")));
  }
}

var $$Error = {
  toString: toString$2
};

function removedBidi(raw) {
  if (raw.charCodeAt(0) === 8234.0) {
    return raw.slice(1);
  } else {
    return raw;
  }
}

function make$1(raw) {
  var replaceSeparator = function (s) {
    return s.replaceAll(/[\\/]/g, Nodepath.sep);
  };
  var path = replaceSeparator(Nodepath.normalize(removedBidi(raw)));
  var obj = Nodepath.parse(path);
  var rootLength = obj.root.length;
  var oldRoot = path.slice(0, rootLength);
  var rest = path.slice(rootLength);
  var newRoot = oldRoot.toUpperCase();
  return newRoot + rest;
}

function toString$3(x) {
  return x;
}

var Filepath = {
  make: make$1,
  toString: toString$3
};

function filepath(s) {
  console.log("Parser.filepath: Input " + s);
  var removedBidi = s.charCodeAt(0) === 8234.0 ? s.slice(1) : s;
  console.log("Parser.filepath: After removing Bidi " + removedBidi);
  var normalized = Nodepath.normalize(removedBidi);
  console.log("Parser.filepath: After normalize " + normalized);
  var makeRootsUpperCaseOnWindows = function (path) {
    var obj = Nodepath.parse(path);
    var rootLength = obj.root.length;
    var oldRoot = path.slice(0, rootLength);
    var rest = path.slice(rootLength);
    var newRoot = oldRoot.toUpperCase();
    return newRoot + rest;
  };
  var upperCased;
  if (OS$AgdaModeVscode.onUnix) {
    console.log("Parser.filepath: No uppercasing (Unix) " + normalized);
    upperCased = normalized;
  } else {
    var result = makeRootsUpperCaseOnWindows(normalized);
    console.log("Parser.filepath: After uppercasing (Windows) " + result);
    upperCased = result;
  }
  var replaced = upperCased.replace(/\\/g, "/");
  console.log("Parser.filepath: Final result " + replaced);
  return replaced;
}

function $$escape(s) {
  return s.replace(/\\/g, "\\\\").replace(/\"/g, "\\\"").replace(/\r\n/g, "\\r\\n").replace(/\n/g, "\\n");
}

function unescapeEOL(s) {
  return s.replace(/\\r\\n/g, "\r\n").replace(/\\n/g, "\n");
}

exports.splitToLines = splitToLines;
exports.Incr = Incr;
exports.SExprParseError = SExprParseError;
exports.SExpression = SExpression;
exports.$$Error = $$Error;
exports.Filepath = Filepath;
exports.filepath = filepath;
exports.$$escape = $$escape;
exports.unescapeEOL = unescapeEOL;
/* node:path Not a pure module */
