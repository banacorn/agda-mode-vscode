// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Caml_option = require("rescript/lib/js/caml_option.js");
var Core__Array = require("@rescript/core/lib/js/src/Core__Array.bs.js");
var PervasivesU = require("rescript/lib/js/pervasivesU.js");
var Common$AgdaModeVscode = require("./View/Common.bs.js");
var Config$AgdaModeVscode = require("./Config.bs.js");
var Editor$AgdaModeVscode = require("./Editor.bs.js");
var Parser$AgdaModeVscode = require("./Parser/Parser.bs.js");
var Tokens$AgdaModeVscode = require("./Tokens.bs.js");
var Resource$AgdaModeVscode = require("./Resource.bs.js");
var Highlighting__SemanticToken$AgdaModeVscode = require("./Highlighting/Highlighting__SemanticToken.bs.js");

function decorateHole(editor, interval, index) {
  var $$document = editor.document;
  var backgroundRange = Common$AgdaModeVscode.Interval.toVSCodeRange($$document, interval);
  var background = Editor$AgdaModeVscode.Decoration.highlightBackground(editor, "editor.selectionHighlightBackground", [backgroundRange]);
  var indexText = String(index);
  var innerInterval_0 = interval[0];
  var innerInterval_1 = interval[1] - 2 | 0;
  var innerInterval = [
    innerInterval_0,
    innerInterval_1
  ];
  var indexRange = Common$AgdaModeVscode.Interval.toVSCodeRange($$document, innerInterval);
  var index$1 = Editor$AgdaModeVscode.Decoration.overlayText(editor, "editorLightBulb.foreground", indexText, indexRange);
  return [
          background,
          index$1
        ];
}

function make(semanticTokens) {
  return {
          decorations: [],
          semanticTokens: semanticTokens !== undefined ? Caml_option.valFromOption(semanticTokens) : Resource$AgdaModeVscode.make()
        };
}

function clear(self) {
  self.decorations.forEach(function (param) {
        Editor$AgdaModeVscode.Decoration.destroy(param[0]);
      });
  self.decorations = [];
}

function destroy(self) {
  clear(self);
}

function redecorate(self, editor) {
  self.decorations.forEach(function (param) {
        Editor$AgdaModeVscode.Decoration.decorate(editor, param[0], param[1]);
      });
}

function classify(change, token) {
  var removedRange = change.range;
  var lines = Parser$AgdaModeVscode.splitToLines(change.text);
  var lineDetalOfRemovedRange = removedRange.end.line - removedRange.start.line | 0;
  var lineDelta = (lines.length - 1 | 0) - lineDetalOfRemovedRange | 0;
  var match;
  if (lineDelta > 0) {
    match = [
      lineDelta,
      -removedRange.end.character | 0
    ];
  } else if (lineDelta < 0) {
    var columnDelta = removedRange.end.character - removedRange.start.character | 0;
    match = [
      lineDelta,
      -columnDelta | 0
    ];
  } else {
    var columnDeltaOfRemovedRange = removedRange.end.character - removedRange.start.character | 0;
    var line = lines[lineDelta];
    var columnDelta$1 = line !== undefined ? line.length - columnDeltaOfRemovedRange | 0 : 0;
    match = [
      0,
      columnDelta$1
    ];
  }
  var lineDelta$1 = match[0];
  var tokenRange = Highlighting__SemanticToken$AgdaModeVscode.Module.SingleLineRange.toVsCodeRange(token.range);
  if (tokenRange.end.isBeforeOrEqual(removedRange.start)) {
    return "NoOp";
  } else if (removedRange.contains(tokenRange) || tokenRange.start.isBefore(removedRange.start) && tokenRange.end.isAfter(removedRange.end)) {
    return "Remove";
  } else if (token.range.line === removedRange.end.line) {
    return {
            TAG: "Move",
            _0: lineDelta$1,
            _1: match[1],
            [Symbol.for("name")]: "Move"
          };
  } else if (lineDelta$1 === 0) {
    return "NoOp";
  } else {
    return {
            TAG: "MoveLinesOnly",
            _0: lineDelta$1,
            [Symbol.for("name")]: "MoveLinesOnly"
          };
  }
}

async function updateSemanticHighlighting(self, $$event) {
  var changes = $$event.contentChanges;
  var applyChange = function (tokens, change) {
    return tokens.map(function (token) {
                  var action = classify(change, token);
                  if (typeof action !== "object") {
                    if (action === "NoOp") {
                      return [token];
                    } else {
                      return [];
                    }
                  }
                  if (action.TAG !== "Move") {
                    return [{
                              range: {
                                line: token.range.line + action._0 | 0,
                                column: token.range.column
                              },
                              type_: token.type_,
                              modifiers: token.modifiers
                            }];
                  }
                  var columnDelta = action._1;
                  return [{
                            range: {
                              line: token.range.line + action._0 | 0,
                              column: [
                                PervasivesU.abs(token.range.column[0] + columnDelta | 0),
                                PervasivesU.abs(token.range.column[1] + columnDelta | 0)
                              ]
                            },
                            type_: token.type_,
                            modifiers: token.modifiers
                          }];
                }).flat();
  };
  var tokens = await Resource$AgdaModeVscode.get(self.semanticTokens);
  return Resource$AgdaModeVscode.set(self.semanticTokens, Core__Array.reduce(changes, tokens, applyChange));
}

function getSemanticTokens(self) {
  return self.semanticTokens;
}

async function apply(self, tokens, editor) {
  if (Config$AgdaModeVscode.Highlighting.getHighlightWithThemeColors()) {
    var match = Tokens$AgdaModeVscode.toDecorationsAndSemanticTokens(tokens, editor);
    Resource$AgdaModeVscode.set(self.semanticTokens, match[1]);
    self.decorations = self.decorations.concat(match[0]);
    return ;
  }
  var decorations = Tokens$AgdaModeVscode.toDecorations(tokens, editor);
  self.decorations = self.decorations.concat(decorations);
}

var Module = {
  make: make,
  destroy: destroy,
  decorateHole: decorateHole,
  apply: apply,
  clear: clear,
  redecorate: redecorate,
  updateSemanticHighlighting: updateSemanticHighlighting,
  getSemanticTokens: getSemanticTokens
};

var Decoration;

var SemanticToken;

exports.Decoration = Decoration;
exports.SemanticToken = SemanticToken;
exports.Module = Module;
exports.make = make;
exports.destroy = destroy;
exports.decorateHole = decorateHole;
exports.apply = apply;
exports.clear = clear;
exports.redecorate = redecorate;
exports.updateSemanticHighlighting = updateSemanticHighlighting;
exports.getSemanticTokens = getSemanticTokens;
/* Common-AgdaModeVscode Not a pure module */
