// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Caml_option = require("rescript/lib/js/caml_option.js");
var Core__Option = require("@rescript/core/lib/js/src/Core__Option.bs.js");

var Any = {};

function make(memento) {
  if (memento !== undefined) {
    return {
            TAG: "Memento",
            _0: Caml_option.valFromOption(memento)
          };
  } else {
    return {
            TAG: "Mock",
            _0: {}
          };
  }
}

function get(context, key) {
  if (context.TAG === "Memento") {
    return context._0.get(key);
  } else {
    return context._0[key];
  }
}

function getWithDefault(context, key, defaultValue) {
  if (context.TAG === "Memento") {
    return context._0.get(key, defaultValue);
  }
  var value = context._0[key];
  if (value !== undefined) {
    return Caml_option.valFromOption(value);
  } else {
    return defaultValue;
  }
}

function set(context, key, value) {
  if (context.TAG === "Memento") {
    return context._0.update(key, value);
  } else {
    return Promise.resolve((context._0[key] = value, undefined));
  }
}

function toString(context) {
  if (context.TAG === "Memento") {
    var context$1 = context._0;
    var entries = context$1.keys().map(function (key) {
          var value = context$1.get(key);
          if (value !== undefined) {
            return key + ": " + Caml_option.valFromOption(value);
          } else {
            return key + ": None";
          }
        });
    return "Memento: {\n" + entries.join("\n") + "}";
  }
  var entries$1 = Object.entries(context._0).map(function (param) {
        return param[0] + ": " + String(param[1]);
      });
  return "Mock: {\n" + entries$1.join("\n") + "}";
}

function endpointToString(endpoint) {
  if (typeof endpoint !== "object") {
    return "Unknown";
  }
  if (endpoint.TAG === "Agda") {
    var version = endpoint._0;
    if (version !== undefined) {
      return "Agda v" + version;
    } else {
      return "Agda (version unknown)";
    }
  }
  var match = endpoint._0;
  if (match !== undefined) {
    return "Agda v" + match[1] + " Language Server v" + match[0];
  } else {
    return "Agda Language Server (version unknown)";
  }
}

var key = "endpointVersion";

function entries(memento) {
  if (memento.TAG === "Memento") {
    return memento._0.get(key, {});
  }
  var value = memento._0[key];
  if (value !== undefined) {
    return Caml_option.valFromOption(value);
  } else {
    return {};
  }
}

function get$1(memento, filepath) {
  var cache = getWithDefault(memento, key, {});
  return cache[filepath];
}

async function setVersion(memento, filepath, endpoint) {
  var cache = getWithDefault(memento, key, {});
  var entry_timestamp = new Date();
  var entry = {
    endpoint: endpoint,
    timestamp: entry_timestamp,
    error: undefined
  };
  cache[filepath] = entry;
  return await set(memento, key, cache);
}

async function setError(memento, filepath, error) {
  var cache = getWithDefault(memento, key, {});
  var existingEntry = cache[filepath];
  var existingEndpoint = existingEntry !== undefined ? existingEntry.endpoint : "Unknown";
  var entry_timestamp = new Date();
  var entry_error = error;
  var entry = {
    endpoint: existingEndpoint,
    timestamp: entry_timestamp,
    error: entry_error
  };
  cache[filepath] = entry;
  return await set(memento, key, cache);
}

async function syncWithPaths(memento, discoveredEndpoints) {
  var cache = getWithDefault(memento, key, {});
  var newCache = {};
  Object.entries(discoveredEndpoints).forEach(function (param) {
        var discoveredEndpoint = param[1];
        var path = param[0];
        var existingEntry = cache[path];
        if (existingEntry !== undefined) {
          var match = existingEntry.endpoint;
          var updatedEndpoint;
          updatedEndpoint = typeof match !== "object" && discoveredEndpoint !== "Unknown" ? discoveredEndpoint : match;
          var updatedEntry_timestamp = new Date();
          var updatedEntry_error = existingEntry.error;
          var updatedEntry = {
            endpoint: updatedEndpoint,
            timestamp: updatedEntry_timestamp,
            error: updatedEntry_error
          };
          newCache[path] = updatedEntry;
          return ;
        }
        var entry_timestamp = new Date();
        var entry = {
          endpoint: discoveredEndpoint,
          timestamp: entry_timestamp,
          error: undefined
        };
        newCache[path] = entry;
      });
  return await set(memento, key, newCache);
}

async function clear(memento) {
  return await set(memento, key, {});
}

function makeTimestampKey(username, repository) {
  return "alsReleaseCacheTimestamp_" + username + "/" + repository;
}

function makeReleasesKey(username, repository) {
  return "alsReleaseCache_" + username + "/" + repository;
}

function getTimestamp(memento, username, repository) {
  var key = makeTimestampKey(username, repository);
  return Core__Option.map(get(memento, key), (function (prim) {
                return new Date(prim);
              }));
}

async function setTimestamp(memento, username, repository, timestamp) {
  var key = makeTimestampKey(username, repository);
  return await set(memento, key, timestamp.toString());
}

function getReleases(memento, username, repository) {
  var key = makeReleasesKey(username, repository);
  return get(memento, key);
}

async function setReleases(memento, username, repository, releases) {
  var key = makeReleasesKey(username, repository);
  return await set(memento, key, releases);
}

function getCacheAgeInSecs(memento, username, repository) {
  var timestamp = getTimestamp(memento, username, repository);
  if (timestamp === undefined) {
    return ;
  }
  var now = new Date();
  var ageInMs = now.getTime() - Caml_option.valFromOption(timestamp).getTime();
  return ageInMs / 1000.0 | 0;
}

async function clear$1(memento, username, repository) {
  var timestampKey = makeTimestampKey(username, repository);
  var releasesKey = makeReleasesKey(username, repository);
  await set(memento, timestampKey, undefined);
  return await set(memento, releasesKey, undefined);
}

var key$1 = "pickedConnection";

function get$2(memento) {
  return get(memento, key$1);
}

async function set$1(memento, path) {
  return await set(memento, key$1, path);
}

async function clear$2(memento) {
  return await set$1(memento, undefined);
}

var Module_Endpoints = {
  endpointToString: endpointToString,
  entries: entries,
  get: get$1,
  setVersion: setVersion,
  setError: setError,
  syncWithPaths: syncWithPaths,
  clear: clear
};

var Module_ALSReleaseCache = {
  getTimestamp: getTimestamp,
  setTimestamp: setTimestamp,
  getReleases: getReleases,
  setReleases: setReleases,
  getCacheAgeInSecs: getCacheAgeInSecs,
  clear: clear$1
};

var Module_PickedConnection = {
  get: get$2,
  set: set$1,
  clear: clear$2
};

var Module = {
  make: make,
  toString: toString,
  Endpoints: Module_Endpoints,
  ALSReleaseCache: Module_ALSReleaseCache,
  PickedConnection: Module_PickedConnection
};

var Endpoints = Module_Endpoints;

var ALSReleaseCache = Module_ALSReleaseCache;

var PickedConnection = Module_PickedConnection;

exports.Any = Any;
exports.Module = Module;
exports.make = make;
exports.toString = toString;
exports.Endpoints = Endpoints;
exports.ALSReleaseCache = ALSReleaseCache;
exports.PickedConnection = PickedConnection;
/* No side effect */
