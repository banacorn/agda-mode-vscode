// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Js_array = require("rescript/lib/js/js_array.js");
var Js_string = require("rescript/lib/js/js_string.js");
var Core__Array = require("@rescript/core/lib/js/src/Core__Array.bs.js");
var PervasivesU = require("rescript/lib/js/pervasivesU.js");
var Core__Option = require("@rescript/core/lib/js/src/Core__Option.bs.js");
var Common$AgdaModeVscode = require("./View/Common.bs.js");
var RichText$AgdaModeVscode = require("./View/Component/RichText.bs.js");
var Emacs__Parser$AgdaModeVscode = require("./View/Panel/Emacs/Emacs__Parser.bs.js");

function render(x) {
  switch (x.TAG) {
    case "QuestionMark" :
        return RichText$AgdaModeVscode.hole(x._0);
    case "Plain" :
    case "Underscore" :
        return RichText$AgdaModeVscode.string(x._0);
    
  }
}

var Term = {
  render: render
};

function parse(raw) {
  return Core__Array.filterMap((function (__x) {
                    return Js_string.splitByRe(/(\?\d+)|(\_\d+[^\}\)\s]*)/, __x);
                  })(raw.trim()).map(function (token, i) {
                  var match = i % 3;
                  if (match !== 1) {
                    if (match !== 2) {
                      return Core__Option.flatMap(token, (function (x) {
                                    if (x === "") {
                                      return ;
                                    } else {
                                      return {
                                              TAG: "Plain",
                                              _0: x,
                                              [Symbol.for("name")]: "Plain"
                                            };
                                    }
                                  }));
                    } else {
                      return Core__Option.map(token, (function (x) {
                                    return {
                                            TAG: "Underscore",
                                            _0: x,
                                            [Symbol.for("name")]: "Underscore"
                                          };
                                  }));
                    }
                  } else {
                    return Core__Option.map(Core__Option.flatMap(Core__Option.map(token, (function (none) {
                                          return none.slice(1);
                                        })), PervasivesU.int_of_string_opt), (function (x) {
                                  return {
                                          TAG: "QuestionMark",
                                          _0: x,
                                          [Symbol.for("name")]: "QuestionMark"
                                        };
                                }));
                  }
                }), (function (x) {
                return x;
              }));
}

function render$1(xs) {
  return RichText$AgdaModeVscode.concatMany(xs.map(render));
}

var Expr = {
  parse: parse,
  render: render$1
};

function parseOfType(extra) {
  return Emacs__Parser$AgdaModeVscode.captures(/^([^\:]*) \: ((?:\r\n|\n|.)+)/, (function (captured) {
                return Core__Option.flatMap(Emacs__Parser$AgdaModeVscode.at(captured, 2, parse), (function (type_) {
                              return Core__Option.flatMap(Emacs__Parser$AgdaModeVscode.at(captured, 1, parse), (function (term) {
                                            return {
                                                    TAG: "OfType",
                                                    _0: render$1(term),
                                                    _1: render$1(type_),
                                                    [Symbol.for("name")]: "OfType"
                                                  };
                                          }));
                            }));
              }), extra);
}

function parseJustType(extra) {
  return Emacs__Parser$AgdaModeVscode.captures(/^Type ((?:\r\n|\n|.)+)/, (function (captured) {
                return Core__Option.map(Emacs__Parser$AgdaModeVscode.at(captured, 1, parse), (function (type_) {
                              return {
                                      TAG: "JustType",
                                      _0: render$1(type_),
                                      [Symbol.for("name")]: "JustType"
                                    };
                            }));
              }), extra);
}

function parseJustSort(extra) {
  return Emacs__Parser$AgdaModeVscode.captures(/^Sort ((?:\r\n|\n|.)+)/, (function (captured) {
                return Core__Option.map(Emacs__Parser$AgdaModeVscode.at(captured, 1, parse), (function (sort) {
                              return {
                                      TAG: "JustSort",
                                      _0: render$1(sort),
                                      [Symbol.for("name")]: "JustSort"
                                    };
                            }));
              }), extra);
}

function parseOthers(raw) {
  return Core__Option.map(parse(raw), (function (raw$p) {
                return {
                        TAG: "Others",
                        _0: render$1(raw$p),
                        [Symbol.for("name")]: "Others"
                      };
              }));
}

function parse$1(extra) {
  return Emacs__Parser$AgdaModeVscode.choice([
              parseOfType,
              parseJustType,
              parseJustSort,
              parseOthers
            ], extra);
}

function renderItem(value, $$location) {
  var inlines;
  switch (value.TAG) {
    case "OfType" :
        inlines = RichText$AgdaModeVscode.concatMany([
              value._0,
              RichText$AgdaModeVscode.string(" : "),
              value._1
            ]);
        break;
    case "JustType" :
        inlines = RichText$AgdaModeVscode.concatMany([
              RichText$AgdaModeVscode.string("Type "),
              value._0
            ]);
        break;
    case "JustSort" :
        inlines = RichText$AgdaModeVscode.concatMany([
              RichText$AgdaModeVscode.string("Sort "),
              value._0
            ]);
        break;
    case "Others" :
        inlines = RichText$AgdaModeVscode.concatMany([value._0]);
        break;
    
  }
  return {
          TAG: "Unlabeled",
          _0: inlines,
          _1: undefined,
          _2: $$location,
          [Symbol.for("name")]: "Unlabeled"
        };
}

var OutputConstraint = {
  parse: parse$1,
  renderItem: renderItem
};

function parseOutputWithoutLocation(raw) {
  return Core__Option.map(parse$1(raw), (function (x) {
                return {
                        TAG: "Output",
                        _0: x,
                        _1: undefined,
                        [Symbol.for("name")]: "Output"
                      };
              }));
}

function parseOutputWithLocation(extra) {
  return Emacs__Parser$AgdaModeVscode.captures(/((?:\n|.)*\S+)\s*\[ at ([^\]]+) \]/, (function (captured) {
                return Core__Option.map(Core__Option.flatMap(Core__Option.flatMap(captured[1], (function (x) {
                                      return x;
                                    })), parse$1), (function (oc) {
                              var r = Core__Option.flatMap(Core__Option.flatMap(captured[2], (function (x) {
                                          return x;
                                        })), Common$AgdaModeVscode.AgdaRange.parse);
                              return {
                                      TAG: "Output",
                                      _0: oc,
                                      _1: r,
                                      [Symbol.for("name")]: "Output"
                                    };
                            }));
              }), extra);
}

function parse$2(raw) {
  var locRe = /\[ at (\S+\:(?:\d+\,\d+\-\d+\,\d+|\d+\,\d+\-\d+|\d+\,\d+)) \]$/;
  var hasLocation = locRe.test(raw);
  if (hasLocation) {
    return parseOutputWithLocation(raw);
  } else {
    return parseOutputWithoutLocation(raw);
  }
}

function renderItem$1(value) {
  return renderItem(value._0, value._1);
}

var Output = {
  parseOutputWithoutLocation: parseOutputWithoutLocation,
  parseOutputWithLocation: parseOutputWithLocation,
  parse: parse$2,
  renderItem: renderItem$1
};

function make(indicesUTF16) {
  var indicesUTF8 = indicesUTF16.map(function (x, i) {
        return x - i | 0;
      });
  var intervals = indicesUTF8.map(function (rightEndpoint, i) {
        var x = indicesUTF8[i - 1 | 0];
        var leftEndpoint = x !== undefined ? x + 1 | 0 : 0;
        return [
                leftEndpoint,
                rightEndpoint
              ];
      });
  var lastInterval = Core__Option.mapWithDefault(intervals[intervals.length - 1 | 0], 0, (function (param) {
          return param[1] + 1 | 0;
        }));
  return {
          intervals: intervals,
          lastInterval: lastInterval,
          cursor: 0
        };
}

function convert(self, index) {
  while(true) {
    var match = self.intervals[self.cursor];
    if (match !== undefined) {
      if (index < match[0]) {
        self.cursor = 0;
        continue ;
      }
      if (index <= match[1]) {
        return index + self.cursor | 0;
      }
      self.cursor = self.cursor + 1 | 0;
      continue ;
    }
    if (index >= self.lastInterval) {
      return index + self.cursor | 0;
    }
    self.cursor = 0;
    continue ;
  };
}

function expose(self) {
  return [
          self.intervals,
          self.cursor
        ];
}

var Indices = {
  make: make,
  convert: convert,
  expose: expose
};

var characterWidth = (function (string) {return [...string].length});

function computeUTF16SurrogatePairIndices(text) {
  var surrogatePairs = [];
  var lengthInCodeUnits = text.length;
  var i = 0;
  while(i < lengthInCodeUnits) {
    var charCode = Js_string.charCodeAt(i, text) | 0;
    var notFinal = (i + 1 | 0) < lengthInCodeUnits;
    if (charCode >= 55296 && charCode <= 56319 && notFinal) {
      var nextCharCode = Js_string.charCodeAt(i + 1 | 0, text) | 0;
      if (nextCharCode >= 56320 && charCode <= 57343) {
        Js_array.push(i, surrogatePairs);
      }
      i = i + 2 | 0;
    } else {
      i = i + 1 | 0;
    }
  };
  return surrogatePairs;
}

function computeCRLFIndices(text) {
  var regexp = /\r\n/g;
  var matchAll = (function (regexp, string) {
          let match;
          let result = [];
          while ((match = regexp.exec(string)) !== null) {
            result.push(match.index);
          }
          return result;
        });
  return matchAll(regexp, text);
}

function make$1(text) {
  return {
          utf16indices: make(computeUTF16SurrogatePairIndices(text)),
          eolIndices: make(computeCRLFIndices(text))
        };
}

function convert$1(self, offset) {
  var offset$1 = convert(self.utf16indices, offset);
  return convert(self.eolIndices, offset$1);
}

var OffsetConverter = {
  make: make$1,
  convert: convert$1,
  characterWidth: characterWidth,
  computeUTF16SurrogatePairIndices: computeUTF16SurrogatePairIndices,
  computeCRLFIndices: computeCRLFIndices
};

exports.Term = Term;
exports.Expr = Expr;
exports.OutputConstraint = OutputConstraint;
exports.Output = Output;
exports.Indices = Indices;
exports.OffsetConverter = OffsetConverter;
/* Common-AgdaModeVscode Not a pure module */
