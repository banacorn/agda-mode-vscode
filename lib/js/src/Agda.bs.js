// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Core__Array = require("@rescript/core/lib/js/src/Core__Array.bs.js");
var PervasivesU = require("rescript/lib/js/pervasivesU.js");
var Core__Option = require("@rescript/core/lib/js/src/Core__Option.bs.js");
var Common$AgdaModeVscode = require("./View/Common.bs.js");
var RichText$AgdaModeVscode = require("./View/Component/RichText.bs.js");
var Emacs__Parser$AgdaModeVscode = require("./View/Panel/Emacs/Emacs__Parser.bs.js");

function render(x) {
  switch (x.TAG) {
    case "QuestionMark" :
        return RichText$AgdaModeVscode.hole(x._0);
    case "Plain" :
    case "Underscore" :
        return RichText$AgdaModeVscode.string(x._0);
    
  }
}

var Term = {
  render: render
};

function parse(raw) {
  return Core__Array.filterMap(raw.trim().split(/(\?\d+)|(\_\d+[^\}\)\s]*)/).map(function (token, i) {
                  var match = i % 3;
                  if (match !== 1) {
                    if (match !== 2) {
                      return Core__Option.flatMap(token, (function (x) {
                                    if (x === "") {
                                      return ;
                                    } else {
                                      return {
                                              TAG: "Plain",
                                              _0: x
                                            };
                                    }
                                  }));
                    } else {
                      return Core__Option.map(token, (function (x) {
                                    return {
                                            TAG: "Underscore",
                                            _0: x
                                          };
                                  }));
                    }
                  } else {
                    return Core__Option.map(Core__Option.flatMap(Core__Option.map(token, (function (none) {
                                          return none.slice(1);
                                        })), PervasivesU.int_of_string_opt), (function (x) {
                                  return {
                                          TAG: "QuestionMark",
                                          _0: x
                                        };
                                }));
                  }
                }), (function (x) {
                return x;
              }));
}

function render$1(xs) {
  return RichText$AgdaModeVscode.concatMany(xs.map(render));
}

var Expr = {
  parse: parse,
  render: render$1
};

function parseOfType(extra) {
  return Emacs__Parser$AgdaModeVscode.captures(/^([^\:]*) \: ((?:\r\n|\n|.)+)/, (function (captured) {
                return Core__Option.flatMap(Emacs__Parser$AgdaModeVscode.at(captured, 2, parse), (function (type_) {
                              return Core__Option.flatMap(Emacs__Parser$AgdaModeVscode.at(captured, 1, parse), (function (term) {
                                            return {
                                                    TAG: "OfType",
                                                    _0: render$1(term),
                                                    _1: render$1(type_)
                                                  };
                                          }));
                            }));
              }), extra);
}

function parseJustType(extra) {
  return Emacs__Parser$AgdaModeVscode.captures(/^Type ((?:\r\n|\n|.)+)/, (function (captured) {
                return Core__Option.map(Emacs__Parser$AgdaModeVscode.at(captured, 1, parse), (function (type_) {
                              return {
                                      TAG: "JustType",
                                      _0: render$1(type_)
                                    };
                            }));
              }), extra);
}

function parseJustSort(extra) {
  return Emacs__Parser$AgdaModeVscode.captures(/^Sort ((?:\r\n|\n|.)+)/, (function (captured) {
                return Core__Option.map(Emacs__Parser$AgdaModeVscode.at(captured, 1, parse), (function (sort) {
                              return {
                                      TAG: "JustSort",
                                      _0: render$1(sort)
                                    };
                            }));
              }), extra);
}

function parseOthers(raw) {
  return Core__Option.map(parse(raw), (function (raw$p) {
                return {
                        TAG: "Others",
                        _0: render$1(raw$p)
                      };
              }));
}

function parse$1(extra) {
  return Emacs__Parser$AgdaModeVscode.choice([
              parseOfType,
              parseJustType,
              parseJustSort,
              parseOthers
            ], extra);
}

function renderItem(value, $$location) {
  var inlines;
  switch (value.TAG) {
    case "OfType" :
        inlines = RichText$AgdaModeVscode.concatMany([
              value._0,
              RichText$AgdaModeVscode.string(" : "),
              value._1
            ]);
        break;
    case "JustType" :
        inlines = RichText$AgdaModeVscode.concatMany([
              RichText$AgdaModeVscode.string("Type "),
              value._0
            ]);
        break;
    case "JustSort" :
        inlines = RichText$AgdaModeVscode.concatMany([
              RichText$AgdaModeVscode.string("Sort "),
              value._0
            ]);
        break;
    case "Others" :
        inlines = RichText$AgdaModeVscode.concatMany([value._0]);
        break;
    
  }
  return {
          TAG: "Unlabeled",
          _0: inlines,
          _1: undefined,
          _2: $$location
        };
}

var OutputConstraint = {
  parse: parse$1,
  renderItem: renderItem
};

function parseOutputWithoutLocation(raw) {
  return Core__Option.map(parse$1(raw), (function (x) {
                return {
                        TAG: "Output",
                        _0: x,
                        _1: undefined
                      };
              }));
}

function parseOutputWithLocation(extra) {
  return Emacs__Parser$AgdaModeVscode.captures(/((?:\n|.)*\S+)\s*\[ at ([^\]]+) \]/, (function (captured) {
                return Core__Option.map(Core__Option.flatMap(Core__Option.flatMap(captured[1], (function (x) {
                                      return x;
                                    })), parse$1), (function (oc) {
                              var r = Core__Option.flatMap(Core__Option.flatMap(captured[2], (function (x) {
                                          return x;
                                        })), Common$AgdaModeVscode.AgdaRange.parse);
                              return {
                                      TAG: "Output",
                                      _0: oc,
                                      _1: r
                                    };
                            }));
              }), extra);
}

function parse$2(raw) {
  var locRe = /\[ at (\S+\:(?:\d+\,\d+\-\d+\,\d+|\d+\,\d+\-\d+|\d+\,\d+)) \]$/;
  var hasLocation = locRe.test(raw);
  if (hasLocation) {
    return parseOutputWithLocation(raw);
  } else {
    return parseOutputWithoutLocation(raw);
  }
}

function renderItem$1(value) {
  return renderItem(value._0, value._1);
}

var Output = {
  parseOutputWithoutLocation: parseOutputWithoutLocation,
  parseOutputWithLocation: parseOutputWithLocation,
  parse: parse$2,
  renderItem: renderItem$1
};

function make(indicesUTF16) {
  var indicesCodepoint = indicesUTF16.map(function (x, i) {
        return x - i | 0;
      });
  var intervals = indicesCodepoint.map(function (rightEndpoint, i) {
        var x = indicesCodepoint[i - 1 | 0];
        var leftEndpoint = x !== undefined ? x + 1 | 0 : 0;
        return [
                leftEndpoint,
                rightEndpoint
              ];
      });
  var lastInterval = Core__Option.mapOr(intervals[intervals.length - 1 | 0], 0, (function (param) {
          return param[1] + 1 | 0;
        }));
  return {
          intervals: intervals,
          lastInterval: lastInterval,
          cursor: 0
        };
}

function convert(self, index) {
  while(true) {
    var match = self.intervals[self.cursor];
    if (match !== undefined) {
      if (index < match[0]) {
        self.cursor = 0;
        continue ;
      }
      if (index <= match[1]) {
        return index + self.cursor | 0;
      }
      self.cursor = self.cursor + 1 | 0;
      continue ;
    }
    if (index >= self.lastInterval) {
      return index + self.cursor | 0;
    }
    self.cursor = 0;
    continue ;
  };
}

function expose(self) {
  return [
          self.intervals,
          self.cursor
        ];
}

var Indices = {
  make: make,
  convert: convert,
  expose: expose
};

var characterWidth = (function (string) {return [...string].length});

function computeUTF16SurrogatePairIndices(text) {
  var surrogatePairs = [];
  var lengthInCodeUnits = text.length;
  var i = 0;
  while(i < lengthInCodeUnits) {
    var charCode = text.charCodeAt(i) | 0;
    var notFinal = (i + 1 | 0) < lengthInCodeUnits;
    if (charCode >= 55296 && charCode <= 56319 && notFinal) {
      var nextCharCode = text.charCodeAt(i + 1 | 0) | 0;
      if (nextCharCode >= 56320 && nextCharCode <= 57343) {
        surrogatePairs.push(i);
      }
      i = i + 2 | 0;
    } else {
      i = i + 1 | 0;
    }
  };
  return surrogatePairs;
}

function computeCRLFIndices(text) {
  var regexp = /\r\n/g;
  var matchAll = (function (regexp, string) {
          let match;
          let result = [];
          while ((match = regexp.exec(string)) !== null) {
            result.push(match.index);
          }
          return result;
        });
  return matchAll(regexp, text);
}

function make$1(text) {
  var surrogatePairIndices = computeUTF16SurrogatePairIndices(text);
  var crlfIndices = computeCRLFIndices(text);
  var result = [];
  var surrogateLength = surrogatePairIndices.length;
  var crlfLength = crlfIndices.length;
  var i = 0;
  var j = 0;
  var $$continue = true;
  while($$continue && i < surrogateLength && j < crlfLength) {
    var match = surrogatePairIndices[i];
    var match$1 = crlfIndices[j];
    if (match !== undefined && match$1 !== undefined) {
      if (match <= match$1) {
        result.push(match);
        i = i + 1 | 0;
      } else {
        result.push(match$1);
        j = j + 1 | 0;
      }
    } else {
      $$continue = false;
    }
  };
  while(i < surrogateLength) {
    var surrogateIndex = surrogatePairIndices[i];
    if (surrogateIndex !== undefined) {
      result.push(surrogateIndex);
      i = i + 1 | 0;
    } else {
      i = surrogateLength;
    }
  };
  while(j < crlfLength) {
    var crlfIndex = crlfIndices[j];
    if (crlfIndex !== undefined) {
      result.push(crlfIndex);
      j = j + 1 | 0;
    } else {
      j = crlfLength;
    }
  };
  return make(result);
}

function convert$1(self, offset) {
  return convert(self, offset);
}

var OffsetConverter = {
  make: make$1,
  convert: convert$1,
  characterWidth: characterWidth,
  computeUTF16SurrogatePairIndices: computeUTF16SurrogatePairIndices,
  computeCRLFIndices: computeCRLFIndices
};

exports.Term = Term;
exports.Expr = Expr;
exports.OutputConstraint = OutputConstraint;
exports.Output = Output;
exports.Indices = Indices;
exports.OffsetConverter = OffsetConverter;
/* Common-AgdaModeVscode Not a pure module */
