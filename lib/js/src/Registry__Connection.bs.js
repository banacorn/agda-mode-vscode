// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Belt_SetString = require("rescript/lib/js/belt_SetString.js");
var Chan$AgdaModeVscode = require("./Util/Chan.bs.js");
var Util$AgdaModeVscode = require("./Util/Util.bs.js");
var Connection$AgdaModeVscode = require("./Connection/Connection.bs.js");
var Connection__Error$AgdaModeVscode = require("./Connection/Shared/Connection__Error.bs.js");

var Resource = {};

var status = {
  contents: "Empty"
};

var makeCount = {
  contents: 0
};

function inspect() {
  var resource = status.contents;
  if (typeof resource !== "object") {
    return {
            status: "Empty",
            userCount: 0,
            currentOwnerId: undefined,
            makeCount: makeCount.contents
          };
  }
  switch (resource.TAG) {
    case "Connecting" :
        return {
                status: "Connecting",
                userCount: 0,
                currentOwnerId: undefined,
                makeCount: makeCount.contents
              };
    case "Active" :
        var resource$1 = resource._0;
        return {
                status: "Active",
                userCount: Belt_SetString.size(resource$1.users),
                currentOwnerId: resource$1.currentOwnerId,
                makeCount: makeCount.contents
              };
    case "Closing" :
        return {
                status: "Closing",
                userCount: 0,
                currentOwnerId: undefined,
                makeCount: makeCount.contents
              };
    
  }
}

async function terminate(resource) {
  var connectionDestroyed = status.contents;
  if (typeof connectionDestroyed === "object" && connectionDestroyed.TAG === "Closing") {
    return await connectionDestroyed._0;
  }
  var match = Util$AgdaModeVscode.Promise_.pending();
  status.contents = {
    TAG: "Closing",
    _0: match[0]
  };
  await Connection$AgdaModeVscode.destroy(resource.connection, Chan$AgdaModeVscode.make());
  status.contents = "Empty";
  makeCount.contents = 0;
  return match[1]();
}

async function acquire(id, make) {
  var connect = async function () {
    var match = Util$AgdaModeVscode.Promise_.pending();
    status.contents = {
      TAG: "Connecting",
      _0: match[0]
    };
    makeCount.contents = makeCount.contents + 1 | 0;
    var result = await make();
    if (result.TAG === "Ok") {
      var resource = {
        connection: result._0,
        users: Belt_SetString.fromArray([id]),
        currentOwnerId: undefined,
        queue: Promise.resolve()
      };
      status.contents = {
        TAG: "Active",
        _0: resource
      };
    } else {
      status.contents = "Empty";
    }
    match[1](result);
    return result;
  };
  var wait = async function (connectionEstablished) {
    var result = await connectionEstablished;
    if (result.TAG !== "Ok") {
      return result;
    }
    var resource = status.contents;
    if (typeof resource !== "object") {
      return await acquire(id, make);
    }
    if (resource.TAG !== "Active") {
      return await acquire(id, make);
    }
    var resource$1 = resource._0;
    resource$1.users = Belt_SetString.add(resource$1.users, id);
    return result;
  };
  var join = function (resource) {
    resource.users = Belt_SetString.add(resource.users, id);
    return Promise.resolve({
                TAG: "Ok",
                _0: resource.connection
              });
  };
  var connectionEstablished = status.contents;
  if (typeof connectionEstablished !== "object") {
    return await connect();
  }
  switch (connectionEstablished.TAG) {
    case "Connecting" :
        return await wait(connectionEstablished._0);
    case "Active" :
        return await join(connectionEstablished._0);
    case "Closing" :
        await connectionEstablished._0;
        return await acquire(id, make);
    
  }
}

async function release(id) {
  var resource = status.contents;
  if (typeof resource !== "object") {
    return ;
  }
  if (resource.TAG !== "Active") {
    return ;
  }
  var resource$1 = resource._0;
  resource$1.users = Belt_SetString.remove(resource$1.users, id);
  if (Belt_SetString.isEmpty(resource$1.users)) {
    return await terminate(resource$1);
  }
  
}

async function shutdown() {
  var resource = status.contents;
  if (typeof resource !== "object") {
    return ;
  }
  switch (resource.TAG) {
    case "Connecting" :
        await resource._0;
        return await shutdown();
    case "Active" :
        return await terminate(resource._0);
    case "Closing" :
        return await resource._0;
    
  }
}

async function execute(id, task) {
  var runSerialized = async function (resource) {
    var previousTaskDone = resource.queue;
    var match = Util$AgdaModeVscode.Promise_.pending();
    resource.queue = match[0];
    await previousTaskDone;
    resource.currentOwnerId = id;
    var result = await task(resource.connection);
    resource.currentOwnerId = undefined;
    match[1]();
    return result;
  };
  var resource = status.contents;
  if (typeof resource === "object" && resource.TAG === "Active") {
    var resource$1 = resource._0;
    if (Caml_obj.equal(resource$1.currentOwnerId, id)) {
      return await task(resource$1.connection);
    } else {
      return await runSerialized(resource$1);
    }
  }
  var err = {
    TAG: "Establish",
    _0: Connection__Error$AgdaModeVscode.Establish.mergeMany([])
  };
  return {
          TAG: "Error",
          _0: err
        };
}

exports.Resource = Resource;
exports.status = status;
exports.makeCount = makeCount;
exports.inspect = inspect;
exports.terminate = terminate;
exports.acquire = acquire;
exports.release = release;
exports.shutdown = shutdown;
exports.execute = execute;
/* Chan-AgdaModeVscode Not a pure module */
