// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Vscode = require("vscode");
var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Nodepath = require("node:path");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Core__Array = require("@rescript/core/lib/js/src/Core__Array.bs.js");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");
var Util$AgdaModeVscode = require("../Util/Util.bs.js");
var Memento$AgdaModeVscode = require("../Memento.bs.js");
var Connection__URI$AgdaModeVscode = require("../Connection/Shared/Connection__URI.bs.js");
var Connection__Endpoint$AgdaModeVscode = require("../Connection/Endpoint/Connection__Endpoint.bs.js");

function formatEndpoint(filename, entry) {
  var match = entry.endpoint;
  var match$1 = entry.error;
  if (typeof match !== "object") {
    if (match$1 !== undefined) {
      return [
              "$(error) " + filename,
              "Error: " + match$1
            ];
    } else {
      return [
              "$(question) " + filename,
              "Unknown executable"
            ];
    }
  }
  if (match.TAG === "Agda") {
    var version = match._0;
    if (version !== undefined) {
      return [
              "Agda",
              "v" + version
            ];
    } else {
      return [
              "Agda",
              "version unknown"
            ];
    }
  }
  var match$2 = match._0;
  if (match$2 !== undefined) {
    return [
            "$(squirrel)  ALS",
            "v" + match$2[0] + ", Agda v" + match$2[1]
          ];
  } else {
    return [
            "$(squirrel)  ALS",
            "version unknown"
          ];
  }
}

function createEndpointItem(path, entry, extensionUri) {
  var filename = Nodepath.basename(path);
  var match = formatEndpoint(filename, entry);
  var match$1 = entry.endpoint;
  var iconPath;
  iconPath = typeof match$1 !== "object" || match$1.TAG !== "Agda" ? undefined : ({
        dark: Vscode.Uri.joinPath(extensionUri, "asset/dark.png"),
        light: Vscode.Uri.joinPath(extensionUri, "asset/light.png")
      });
  var baseItem_description = match[1];
  var baseItem_detail = path;
  var baseItem_label = match[0];
  var baseItem = {
    description: baseItem_description,
    detail: baseItem_detail,
    label: baseItem_label
  };
  if (iconPath === undefined) {
    return baseItem;
  }
  var newrecord = Caml_obj.obj_dup(baseItem);
  newrecord.iconPath = Caml_option.some(Caml_option.valFromOption(iconPath));
  return newrecord;
}

function createSeparatorItem(label) {
  return {
          kind: -1,
          label: label
        };
}

function createNoInstallationsItem() {
  return {
          description: "Try installing Agda or ALS first",
          detail: "No executable paths detected",
          label: "$(info) No installations found"
        };
}

var ItemCreation = {
  formatEndpoint: formatEndpoint,
  createEndpointItem: createEndpointItem,
  createSeparatorItem: createSeparatorItem,
  createNoInstallationsItem: createNoInstallationsItem
};

function make() {
  return {
          quickPick: Vscode.window.createQuickPick(),
          subscriptions: [],
          items: []
        };
}

function setPlaceholder(self, placeholder) {
  self.quickPick.placeholder = placeholder;
}

function updateItems(self, items) {
  self.items = items;
  self.quickPick.items = items;
}

function show(self) {
  self.quickPick.show();
}

function onSelection(self, handler) {
  Util$AgdaModeVscode.Disposable.add(self.quickPick.onDidChangeSelection(handler), self.subscriptions);
}

function onHide(self, handler) {
  Util$AgdaModeVscode.Disposable.add(self.quickPick.onDidHide(handler), self.subscriptions);
}

function destroy(self) {
  self.quickPick.dispose();
  self.subscriptions.forEach(function (sub) {
        sub.dispose();
      });
}

var QuickPickManager = {
  make: make,
  setPlaceholder: setPlaceholder,
  updateItems: updateItems,
  show: show,
  onSelection: onSelection,
  onHide: onHide,
  destroy: destroy
};

function make$1(state) {
  return {
          entries: Memento$AgdaModeVscode.Module.Endpoints.entries(state.memento),
          extensionUri: state.extensionUri
        };
}

function toItems(self) {
  var pathItems = Object.entries(self.entries).map(function (param) {
        return createEndpointItem(param[0], param[1], self.extensionUri);
      });
  if (pathItems.length > 0) {
    return [{
                kind: -1,
                label: "Installed"
              }].concat(pathItems);
  } else {
    return [{
              description: "Try installing Agda or ALS first",
              detail: "No executable paths detected",
              label: "$(info) No installations found"
            }];
  }
}

function refreshFromMemento(self, memento) {
  var newEntries = Memento$AgdaModeVscode.Module.Endpoints.entries(memento);
  var changed = newEntries !== self.entries;
  if (changed) {
    self.entries = newEntries;
  }
  return changed;
}

async function syncWithFilesystem(self, state, platformDeps) {
  var discoveredEndpoints = await platformDeps.getInstalledEndpointsAndPersistThem2(state.globalStorageUri);
  await Memento$AgdaModeVscode.Module.Endpoints.syncWithPaths(state.memento, discoveredEndpoints);
  return refreshFromMemento(self, state.memento);
}

async function probeVersions(self, state) {
  var pathsToProbe = Core__Array.filterMap(Object.entries(self.entries), (function (param) {
          var match = param[1].endpoint;
          if (typeof match !== "object") {
            return ;
          }
          match.TAG === "Agda";
          if (match._0 !== undefined) {
            return ;
          } else {
            return param[0];
          }
        }));
  if (pathsToProbe.length === 0) {
    return false;
  }
  var probePromises = pathsToProbe.map(async function (path) {
        var uri = Connection__URI$AgdaModeVscode.parse(path);
        var error = await Connection__Endpoint$AgdaModeVscode.probeFilepath(uri);
        if (error.TAG === "Ok") {
          var match = error._0;
          if (match.TAG === "Agda") {
            await Memento$AgdaModeVscode.Module.Endpoints.setVersion(state.memento, path, {
                  TAG: "Agda",
                  _0: match._0
                });
            return path;
          }
          await Memento$AgdaModeVscode.Module.Endpoints.setVersion(state.memento, path, {
                TAG: "ALS",
                _0: [
                  match._0,
                  match._1
                ]
              });
          return path;
        }
        await Memento$AgdaModeVscode.Module.Endpoints.setError(state.memento, path, Connection__Endpoint$AgdaModeVscode.$$Error.toString(error._0));
        return path;
      });
  var updateResults = await Promise.all(probePromises);
  var updatedPaths = Core__Array.filterMap(updateResults, (function (x) {
          return x;
        }));
  if (updatedPaths.length > 0) {
    refreshFromMemento(self, state.memento);
    return true;
  } else {
    return false;
  }
}

var EndpointManager = {
  make: make$1,
  toItems: toItems,
  refreshFromMemento: refreshFromMemento,
  syncWithFilesystem: syncWithFilesystem,
  probeVersions: probeVersions
};

async function run(state, platformDeps) {
  var qp = make();
  var endpointManager = make$1(state);
  setPlaceholder(qp, "Switch Version (v2)");
  var initialItems = toItems(endpointManager);
  updateItems(qp, initialItems);
  qp.quickPick.show();
  onSelection(qp, (function (_selectedItems) {
          destroy(qp);
        }));
  onHide(qp, (function () {
          destroy(qp);
        }));
  var backgroundUpdate = async function () {
    try {
      var phase2Changed = await syncWithFilesystem(endpointManager, state, platformDeps);
      if (phase2Changed) {
        var updatedItems = toItems(endpointManager);
        updateItems(qp, updatedItems);
      }
      var phase3Changed = await probeVersions(endpointManager, state);
      if (!phase3Changed) {
        return ;
      }
      var finalItems = toItems(endpointManager);
      return updateItems(qp, finalItems);
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      console.log("Background update failed: " + String(exn));
      return ;
    }
  };
  backgroundUpdate();
}

exports.ItemCreation = ItemCreation;
exports.QuickPickManager = QuickPickManager;
exports.EndpointManager = EndpointManager;
exports.run = run;
/* vscode Not a pure module */
