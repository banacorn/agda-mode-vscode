// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Vscode = require("vscode");
var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Nodepath = require("node:path");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Core__Array = require("@rescript/core/lib/js/src/Core__Array.bs.js");
var Util$AgdaModeVscode = require("../Util/Util.bs.js");
var Memento$AgdaModeVscode = require("../Memento.bs.js");
var Connection__URI$AgdaModeVscode = require("../Connection/Shared/Connection__URI.bs.js");
var Connection__Endpoint$AgdaModeVscode = require("../Connection/Endpoint/Connection__Endpoint.bs.js");

function formatEndpointInfo(filename, endpointInfo, isPicked) {
  var match = endpointInfo.endpoint;
  var match$1 = endpointInfo.error;
  var match$2;
  if (typeof match !== "object") {
    match$2 = match$1 !== undefined ? [
        "$(error) " + filename,
        "Error: " + match$1
      ] : [
        "$(question) " + filename,
        "Unknown executable"
      ];
  } else if (match.TAG === "Agda") {
    var version = match._0;
    match$2 = version !== undefined ? [
        "Agda",
        "v" + version
      ] : [
        "Agda",
        "version unknown"
      ];
  } else {
    var match$3 = match._0;
    match$2 = match$3 !== undefined ? [
        "$(squirrel)  ALS",
        "v" + match$3[0] + ", Agda v" + match$3[1]
      ] : [
        "$(squirrel)  ALS",
        "version unknown"
      ];
  }
  var baseDescription = match$2[1];
  var description = isPicked ? baseDescription + " (Selected)" : baseDescription;
  return [
          match$2[0],
          description
        ];
}

function shouldHaveIcon(endpoint) {
  if (typeof endpoint !== "object" || endpoint.TAG !== "Agda") {
    return false;
  } else {
    return true;
  }
}

function formatEndpoint(filename, entry, isPicked) {
  return formatEndpointInfo(filename, {
              endpoint: entry.endpoint,
              error: entry.error
            }, isPicked);
}

var ItemFormatting = {
  formatEndpointInfo: formatEndpointInfo,
  shouldHaveIcon: shouldHaveIcon,
  formatEndpoint: formatEndpoint
};

function formatEndpoint$1(filename, entry, isPicked) {
  return formatEndpoint(filename, entry, isPicked);
}

function createEndpointItem(path, entry, extensionUri, isPicked) {
  var filename = Nodepath.basename(path);
  var match = formatEndpoint$1(filename, entry, isPicked);
  var iconPath = shouldHaveIcon(entry.endpoint) ? ({
        dark: Vscode.Uri.joinPath(extensionUri, "asset/dark.png"),
        light: Vscode.Uri.joinPath(extensionUri, "asset/light.png")
      }) : undefined;
  var baseItem_description = match[1];
  var baseItem_detail = path;
  var baseItem_label = match[0];
  var baseItem = {
    description: baseItem_description,
    detail: baseItem_detail,
    label: baseItem_label
  };
  if (iconPath === undefined) {
    return baseItem;
  }
  var newrecord = Caml_obj.obj_dup(baseItem);
  newrecord.iconPath = Caml_option.some(Caml_option.valFromOption(iconPath));
  return newrecord;
}

function createSeparatorItem(label) {
  return {
          kind: -1,
          label: label
        };
}

function createNoInstallationsItem() {
  return {
          description: "Try installing Agda or ALS first",
          detail: "No executable paths detected",
          label: "$(info) No installations found"
        };
}

var ItemCreation = {
  formatEndpoint: formatEndpoint$1,
  createEndpointItem: createEndpointItem,
  createSeparatorItem: createSeparatorItem,
  createNoInstallationsItem: createNoInstallationsItem
};

function make() {
  return {
          quickPick: Vscode.window.createQuickPick(),
          subscriptions: [],
          items: []
        };
}

function setPlaceholder(self, placeholder) {
  self.quickPick.placeholder = placeholder;
}

function updateItems(self, items) {
  self.items = items;
  self.quickPick.items = items;
}

function show(self) {
  self.quickPick.show();
}

function onSelection(self, handler) {
  Util$AgdaModeVscode.Disposable.add(self.quickPick.onDidChangeSelection(handler), self.subscriptions);
}

function onHide(self, handler) {
  Util$AgdaModeVscode.Disposable.add(self.quickPick.onDidHide(handler), self.subscriptions);
}

function destroy(self) {
  self.quickPick.dispose();
  self.subscriptions.forEach(function (sub) {
        sub.dispose();
      });
}

var QuickPickManager = {
  make: make,
  setPlaceholder: setPlaceholder,
  updateItems: updateItems,
  show: show,
  onSelection: onSelection,
  onHide: onHide,
  destroy: destroy
};

function getPickedPath(memento) {
  return Memento$AgdaModeVscode.Module.PickedConnection.get(memento);
}

function entriesToItems(entries, extensionUri, pickedPath) {
  var pathItems = Object.entries(entries).map(function (param) {
        var path = param[0];
        var isPicked = pickedPath !== undefined ? pickedPath === path : false;
        return createEndpointItem(path, param[1], extensionUri, isPicked);
      });
  if (pathItems.length > 0) {
    return [{
                kind: -1,
                label: "Installed"
              }].concat(pathItems);
  } else {
    return [{
              description: "Try installing Agda or ALS first",
              detail: "No executable paths detected",
              label: "$(info) No installations found"
            }];
  }
}

function getPathsNeedingProbe(entries) {
  return Core__Array.filterMap(Object.entries(entries), (function (param) {
                var match = param[1].endpoint;
                if (typeof match !== "object") {
                  return ;
                }
                match.TAG === "Agda";
                if (match._0 !== undefined) {
                  return ;
                } else {
                  return param[0];
                }
              }));
}

function entriesChanged(oldEntries, newEntries) {
  return newEntries !== oldEntries;
}

var EndpointLogic = {
  getPickedPath: getPickedPath,
  entriesToItems: entriesToItems,
  getPathsNeedingProbe: getPathsNeedingProbe,
  entriesChanged: entriesChanged
};

function make$1(state) {
  return {
          entries: Memento$AgdaModeVscode.Module.Endpoints.entries(state.memento),
          extensionUri: state.extensionUri
        };
}

function toItems(self, memento) {
  var pickedPath = getPickedPath(memento);
  return entriesToItems(self.entries, self.extensionUri, pickedPath);
}

function updateItems$1(self, qp, memento) {
  var items = toItems(self, memento);
  updateItems(qp, items);
}

function refreshFromMemento(self, memento) {
  var newEntries = Memento$AgdaModeVscode.Module.Endpoints.entries(memento);
  var changed = newEntries !== self.entries;
  if (changed) {
    self.entries = newEntries;
  }
  return changed;
}

async function syncWithFilesystem(self, state, platformDeps) {
  var discoveredEndpoints = await platformDeps.getInstalledEndpointsAndPersistThem2(state.globalStorageUri);
  await Memento$AgdaModeVscode.Module.Endpoints.syncWithPaths(state.memento, discoveredEndpoints);
  return refreshFromMemento(self, state.memento);
}

async function probeVersions(self, state) {
  var pathsToProbe = getPathsNeedingProbe(self.entries);
  if (pathsToProbe.length === 0) {
    return false;
  }
  var probePromises = pathsToProbe.map(async function (path) {
        var uri = Connection__URI$AgdaModeVscode.parse(path);
        var error = await Connection__Endpoint$AgdaModeVscode.probeFilepath(uri);
        if (error.TAG === "Ok") {
          var match = error._0;
          if (match.TAG === "Agda") {
            await Memento$AgdaModeVscode.Module.Endpoints.setVersion(state.memento, path, {
                  TAG: "Agda",
                  _0: match._0
                });
            return path;
          }
          await Memento$AgdaModeVscode.Module.Endpoints.setVersion(state.memento, path, {
                TAG: "ALS",
                _0: [
                  match._0,
                  match._1
                ]
              });
          return path;
        }
        await Memento$AgdaModeVscode.Module.Endpoints.setError(state.memento, path, Connection__Endpoint$AgdaModeVscode.$$Error.toString(error._0));
        return path;
      });
  var updateResults = await Promise.all(probePromises);
  var updatedPaths = Core__Array.filterMap(updateResults, (function (x) {
          return x;
        }));
  if (updatedPaths.length > 0) {
    refreshFromMemento(self, state.memento);
    return true;
  } else {
    return false;
  }
}

var EndpointManager = {
  make: make$1,
  toItems: toItems,
  updateItems: updateItems$1,
  refreshFromMemento: refreshFromMemento,
  syncWithFilesystem: syncWithFilesystem,
  probeVersions: probeVersions
};

async function run(state, platformDeps) {
  var qp = make();
  var endpointManager = make$1(state);
  setPlaceholder(qp, "Switch Version (v2)");
  updateItems$1(endpointManager, qp, state.memento);
  qp.quickPick.show();
  onSelection(qp, (function (selectedItems) {
          destroy(qp);
          var selectedItem = selectedItems[0];
          if (selectedItem === undefined) {
            return ;
          }
          var selectedPath = selectedItem.detail;
          if (selectedPath !== undefined) {
            Memento$AgdaModeVscode.Module.PickedConnection.set(state.memento, selectedPath);
            return ;
          }
          
        }));
  onHide(qp, (function () {
          destroy(qp);
        }));
  var backgroundUpdate = async function () {
    try {
      var phase2Changed = await syncWithFilesystem(endpointManager, state, platformDeps);
      if (phase2Changed) {
        updateItems$1(endpointManager, qp, state.memento);
      }
      var phase3Changed = await probeVersions(endpointManager, state);
      if (phase3Changed) {
        return updateItems$1(endpointManager, qp, state.memento);
      } else {
        return ;
      }
    }
    catch (_exn){
      return ;
    }
  };
  backgroundUpdate();
}

exports.ItemFormatting = ItemFormatting;
exports.ItemCreation = ItemCreation;
exports.QuickPickManager = QuickPickManager;
exports.EndpointLogic = EndpointLogic;
exports.EndpointManager = EndpointManager;
exports.run = run;
/* vscode Not a pure module */
