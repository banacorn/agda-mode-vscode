// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Vscode = require("vscode");
var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Nodepath = require("node:path");
var Core__Array = require("@rescript/core/lib/js/src/Core__Array.bs.js");
var Core__Option = require("@rescript/core/lib/js/src/Core__Option.bs.js");
var Chan$AgdaModeVscode = require("../Util/Chan.bs.js");
var Item$AgdaModeVscode = require("../View/Component/Item.bs.js");
var Util$AgdaModeVscode = require("../Util/Util.bs.js");
var Config$AgdaModeVscode = require("../Config.bs.js");
var Memento$AgdaModeVscode = require("../Memento.bs.js");
var Connection$AgdaModeVscode = require("../Connection/Connection.bs.js");
var State__View$AgdaModeVscode = require("./State__View.bs.js");
var Connection__URI$AgdaModeVscode = require("../Connection/Shared/Connection__URI.bs.js");
var Connection__Error$AgdaModeVscode = require("../Connection/Shared/Connection__Error.bs.js");
var Connection__Download$AgdaModeVscode = require("../Connection/Resolver/Connection__Download.bs.js");
var Connection__Endpoint$AgdaModeVscode = require("../Connection/Endpoint/Connection__Endpoint.bs.js");
var State__SwitchVersion$AgdaModeVscode = require("./State__SwitchVersion.bs.js");
var Connection__LatestALS$AgdaModeVscode = require("../Connection/Resolver/Connection__LatestALS.bs.js");

var agdaVersionPrefix = "Agda v";

var alsWithSquirrel = "$(squirrel)  ALS v";

var downloadLatestALS = "$(cloud-download)  Download the latest Agda Language Server";

var openDownloadFolder = "$(folder-opened)  Open download folder";

var downloadedAndInstalled = "Downloaded and installed";

var Constants = {
  agdaVersionPrefix: agdaVersionPrefix,
  alsWithSquirrel: alsWithSquirrel,
  downloadLatestALS: downloadLatestALS,
  openDownloadFolder: openDownloadFolder,
  downloadedAndInstalled: downloadedAndInstalled
};

function shouldEndpointHaveIcon(endpoint) {
  if (typeof endpoint !== "object" || endpoint.TAG !== "Agda") {
    return false;
  } else {
    return true;
  }
}

function getEndpointDisplayInfo(filename, entry) {
  var match = entry.endpoint;
  var match$1 = entry.error;
  if (typeof match !== "object") {
    if (match$1 !== undefined) {
      return [
              "$(error) " + filename,
              "Error: " + match$1
            ];
    } else {
      return [
              "$(question) " + filename,
              "Unknown executable"
            ];
    }
  }
  if (match.TAG === "Agda") {
    var version = match._0;
    if (version !== undefined) {
      return [
              agdaVersionPrefix + version,
              undefined
            ];
    } else {
      return [
              "Agda (version unknown)",
              undefined
            ];
    }
  }
  var match$2 = match._0;
  if (match$2 !== undefined) {
    return [
            alsWithSquirrel + match$2[0] + ", " + agdaVersionPrefix + match$2[1],
            undefined
          ];
  } else {
    return [
            alsWithSquirrel + "(version unknown)",
            undefined
          ];
  }
}

function entriesToItemData(entries, pickedPath, downloadItem, folderPath) {
  var entriesArray = Object.entries(entries);
  var hasEndpoints = entriesArray.length > 0;
  var endpointItems = pickedPath !== undefined ? entriesArray.map(function (param) {
          var path = param[0];
          return {
                  itemType: {
                    TAG: "Endpoint",
                    _0: path,
                    _1: param[1]
                  },
                  isSelected: pickedPath === path
                };
        }) : entriesArray.map(function (param) {
          return {
                  itemType: {
                    TAG: "Endpoint",
                    _0: param[0],
                    _1: param[1]
                  },
                  isSelected: false
                };
        });
  var sectionsWithInstalled = hasEndpoints ? [{
          itemType: {
            TAG: "Separator",
            _0: "Installed"
          },
          isSelected: false
        }].concat(endpointItems) : [{
        itemType: "NoInstallations",
        isSelected: false
      }];
  var sectionsWithDownload = downloadItem !== undefined ? sectionsWithInstalled.concat([
          {
            itemType: {
              TAG: "Separator",
              _0: "Download"
            },
            isSelected: false
          },
          {
            itemType: {
              TAG: "DownloadAction",
              _0: downloadItem[0],
              _1: downloadItem[1]
            },
            isSelected: false
          }
        ]) : sectionsWithInstalled;
  return sectionsWithDownload.concat([
              {
                itemType: {
                  TAG: "Separator",
                  _0: "Misc"
                },
                isSelected: false
              },
              {
                itemType: {
                  TAG: "OpenFolder",
                  _0: folderPath
                },
                isSelected: false
              }
            ]);
}

var ItemData = {
  shouldEndpointHaveIcon: shouldEndpointHaveIcon,
  getEndpointDisplayInfo: getEndpointDisplayInfo,
  entriesToItemData: entriesToItemData
};

function createQuickPickItem(label, description, detail) {
  if (description !== undefined) {
    if (detail !== undefined) {
      return {
              description: description,
              detail: detail,
              label: label
            };
    } else {
      return {
              description: description,
              label: label
            };
    }
  } else if (detail !== undefined) {
    return {
            detail: detail,
            label: label
          };
  } else {
    return {
            label: label
          };
  }
}

function fromItemData(itemData, extensionUri) {
  var folderPath = itemData.itemType;
  var match;
  if (typeof folderPath !== "object") {
    match = [
      "$(info) No installations found",
      "Try installing Agda or ALS first",
      "No executable paths detected"
    ];
  } else {
    switch (folderPath.TAG) {
      case "Endpoint" :
          var path = folderPath._0;
          var filename = Nodepath.basename(path);
          var match$1 = getEndpointDisplayInfo(filename, folderPath._1);
          var errorDescription = match$1[1];
          var match$2 = itemData.isSelected;
          var description = match$2 ? (
              errorDescription !== undefined ? errorDescription : "Selected"
            ) : (
              errorDescription !== undefined ? errorDescription : ""
            );
          match = [
            match$1[0],
            description,
            path
          ];
          break;
      case "DownloadAction" :
          var description$1 = folderPath._0 ? downloadedAndInstalled : "";
          match = [
            downloadLatestALS,
            description$1,
            folderPath._1
          ];
          break;
      case "OpenFolder" :
          match = [
            openDownloadFolder,
            "Where the language servers are downloaded to",
            folderPath._0
          ];
          break;
      case "Separator" :
          match = [
            folderPath._0,
            undefined,
            undefined
          ];
          break;
      
    }
  }
  var detail = match[2];
  var description$2 = match[1];
  var label = match[0];
  var match$3 = itemData.itemType;
  if (typeof match$3 !== "object") {
    return createQuickPickItem(label, description$2, detail);
  }
  switch (match$3.TAG) {
    case "Endpoint" :
        var baseItem = createQuickPickItem(label, description$2, detail);
        if (!shouldEndpointHaveIcon(match$3._1.endpoint)) {
          return baseItem;
        }
        var newrecord = Caml_obj.obj_dup(baseItem);
        newrecord.iconPath = {
          dark: Vscode.Uri.joinPath(extensionUri, "asset/dark.png"),
          light: Vscode.Uri.joinPath(extensionUri, "asset/light.png")
        };
        return newrecord;
    case "Separator" :
        return {
                kind: -1,
                label: label
              };
    default:
      return createQuickPickItem(label, description$2, detail);
  }
}

function fromItemDataArray(itemDataArray, extensionUri) {
  return itemDataArray.map(function (itemData) {
              return fromItemData(itemData, extensionUri);
            });
}

var Item = {
  createQuickPickItem: createQuickPickItem,
  fromItemData: fromItemData,
  fromItemDataArray: fromItemDataArray
};

function make() {
  return {
          quickPick: Vscode.window.createQuickPick(),
          subscriptions: [],
          items: []
        };
}

function setPlaceholder(self, placeholder) {
  self.quickPick.placeholder = placeholder;
}

function updateItems(self, items) {
  self.items = items;
  self.quickPick.items = items;
}

function show(self) {
  self.quickPick.show();
}

function onSelection(self, handler) {
  Util$AgdaModeVscode.Disposable.add(self.quickPick.onDidChangeSelection(handler), self.subscriptions);
}

function onHide(self, handler) {
  Util$AgdaModeVscode.Disposable.add(self.quickPick.onDidHide(handler), self.subscriptions);
}

function destroy(self) {
  self.quickPick.dispose();
  self.subscriptions.forEach(function (sub) {
        sub.dispose();
      });
}

var View = {
  make: make,
  setPlaceholder: setPlaceholder,
  updateItems: updateItems,
  show: show,
  onSelection: onSelection,
  onHide: onHide,
  destroy: destroy
};

function make$1(state) {
  return {
          entries: Memento$AgdaModeVscode.Module.Endpoints.entries(state.memento),
          memento: state.memento,
          globalStorageUri: state.globalStorageUri
        };
}

async function getItemData(self, downloadInfo) {
  var storedPath = Memento$AgdaModeVscode.Module.PickedConnection.get(self.memento);
  var currentPath = await Connection__Endpoint$AgdaModeVscode.getPickedRaw(self.memento, Config$AgdaModeVscode.Connection.getAgdaPaths2());
  var pickedPath = storedPath !== undefined ? (
      storedPath.startsWith("file://") ? Vscode.Uri.parse(storedPath).fsPath : storedPath
    ) : Core__Option.map(currentPath, (function (path) {
            if (path.startsWith("file://")) {
              return Vscode.Uri.parse(path).fsPath;
            } else {
              return path;
            }
          }));
  var folderPath = self.globalStorageUri.fsPath;
  return entriesToItemData(self.entries, pickedPath, downloadInfo, folderPath);
}

function refreshFromMemento(self) {
  var newEntries = Memento$AgdaModeVscode.Module.Endpoints.entries(self.memento);
  var changed = newEntries !== self.entries;
  if (changed) {
    self.entries = newEntries;
  }
  return changed;
}

async function syncWithFilesystem(self, platformDeps) {
  var discoveredEndpoints = await platformDeps.getInstalledEndpointsAndPersistThem2(self.globalStorageUri);
  await Memento$AgdaModeVscode.Module.Endpoints.syncWithPaths(self.memento, discoveredEndpoints);
  return refreshFromMemento(self);
}

async function probeVersions(self) {
  var pathsToProbe = Core__Array.filterMap(Object.entries(self.entries), (function (param) {
          var match = param[1].endpoint;
          if (typeof match !== "object") {
            return ;
          }
          match.TAG === "Agda";
          if (match._0 !== undefined) {
            return ;
          } else {
            return param[0];
          }
        }));
  if (pathsToProbe.length === 0) {
    return false;
  }
  var probePromises = pathsToProbe.map(async function (path) {
        var uri = Connection__URI$AgdaModeVscode.parse(path);
        var error = await Connection__Endpoint$AgdaModeVscode.probeFilepath(uri);
        if (error.TAG === "Ok") {
          var match = error._0;
          if (match.TAG === "Agda") {
            await Memento$AgdaModeVscode.Module.Endpoints.setVersion(self.memento, path, {
                  TAG: "Agda",
                  _0: match._0
                });
            return path;
          }
          await Memento$AgdaModeVscode.Module.Endpoints.setVersion(self.memento, path, {
                TAG: "ALS",
                _0: [
                  match._0,
                  match._1
                ]
              });
          return path;
        }
        await Memento$AgdaModeVscode.Module.Endpoints.setError(self.memento, path, Connection__Endpoint$AgdaModeVscode.$$Error.toString(error._0));
        return path;
      });
  var updateResults = await Promise.all(probePromises);
  var updatedPaths = Core__Array.filterMap(updateResults, (function (x) {
          return x;
        }));
  if (updatedPaths.length > 0) {
    refreshFromMemento(self);
    return true;
  } else {
    return false;
  }
}

var SwitchVersionManager = {
  make: make$1,
  getItemData: getItemData,
  refreshFromMemento: refreshFromMemento,
  syncWithFilesystem: syncWithFilesystem,
  probeVersions: probeVersions
};

async function switchAgdaVersion(state) {
  await State__View$AgdaModeVscode.Panel.displayStatus(state, "");
  await State__View$AgdaModeVscode.Panel.display(state, {
        TAG: "Plain",
        _0: "Switching connection..."
      }, []);
  await Connection$AgdaModeVscode.destroy(state.connection);
  var configPaths = Config$AgdaModeVscode.Connection.getAgdaPaths2();
  var storedPathBeforeConnection = Memento$AgdaModeVscode.Module.PickedConnection.get(state.memento);
  var pathsFromSystem;
  if (storedPathBeforeConnection !== undefined) {
    var pathExists = configPaths.includes(storedPathBeforeConnection);
    pathsFromSystem = pathExists ? configPaths : [storedPathBeforeConnection].concat(configPaths);
  } else {
    pathsFromSystem = configPaths;
  }
  var conn = await Connection$AgdaModeVscode.make2(state.platformDeps, state.memento, state.globalStorageUri, pathsFromSystem, [
        "als",
        "agda"
      ]);
  if (conn.TAG === "Ok") {
    var conn$1 = conn._0;
    state.connection = conn$1;
    if (conn$1.TAG === "Agda") {
      var formattedVersion = State__SwitchVersion$AgdaModeVscode.VersionDisplay.formatAgdaVersion(conn$1._1);
      await State__View$AgdaModeVscode.Panel.displayStatus(state, formattedVersion);
      return await State__View$AgdaModeVscode.Panel.display(state, {
                  TAG: "Success",
                  _0: State__SwitchVersion$AgdaModeVscode.VersionDisplay.formatSwitchedMessage(formattedVersion)
                }, []);
    }
    var formattedVersion$1 = State__SwitchVersion$AgdaModeVscode.VersionDisplay.formatALSVersion(conn$1._1, conn$1._2);
    await State__View$AgdaModeVscode.Panel.displayStatus(state, formattedVersion$1);
    return await State__View$AgdaModeVscode.Panel.display(state, {
                TAG: "Success",
                _0: State__SwitchVersion$AgdaModeVscode.VersionDisplay.formatSwitchedMessage(formattedVersion$1)
              }, []);
  }
  var match = Connection__Error$AgdaModeVscode.toString(conn._0);
  var header = {
    TAG: "Error",
    _0: "Failed to switch to a different installation: " + match[0]
  };
  var body = [Item$AgdaModeVscode.plainText(match[1])];
  return await State__View$AgdaModeVscode.Panel.display(state, header, body);
}

async function getAvailableDownload(state, platformDeps) {
  var platform = await platformDeps.determinePlatform();
  if (platform.TAG !== "Ok") {
    return ;
  }
  var fetchSpec = await Connection__LatestALS$AgdaModeVscode.getFetchSpec(state.memento, state.globalStorageUri, platform._0);
  if (fetchSpec.TAG !== "Ok") {
    return ;
  }
  var fetchSpec$1 = fetchSpec._0;
  var installedEndpoints = await platformDeps.getInstalledEndpointsAndPersistThem(state.globalStorageUri);
  var installedPaths = Core__Array.filterMap(Object.values(installedEndpoints), (function (x) {
          if (x.TAG === "Ok") {
            return Connection__URI$AgdaModeVscode.toString(Connection__Endpoint$AgdaModeVscode.toURI(x._0));
          }
          
        }));
  var filename = Nodepath.join(state.globalStorageUri.fsPath, fetchSpec$1.saveAsFileName, "als");
  var filenameAsUri = Vscode.Uri.file(filename).toString();
  var downloaded = installedPaths.includes(filenameAsUri);
  var getAgdaVersion = function (asset) {
    return asset.name.replace(/als-Agda-/, "").replace(/-.*/, "");
  };
  var agdaVersion = getAgdaVersion(fetchSpec$1.asset);
  var alsVersion = Core__Option.getOr(Core__Array.last(fetchSpec$1.release.name.split(".")), fetchSpec$1.release.name);
  var versionString = State__SwitchVersion$AgdaModeVscode.VersionDisplay.formatALSVersion(alsVersion, agdaVersion);
  return [
          downloaded,
          versionString
        ];
}

var Download = {
  getAvailableDownload: getAvailableDownload
};

function onSelection$1(state, platformDeps, manager, updateUI, view, selectedItems) {
  Chan$AgdaModeVscode.emit(state.channels.log, {
        TAG: "SwitchVersionUI",
        _0: {
          TAG: "Others",
          _0: "Handler.onSelection called"
        }
      });
  destroy(view);
  Chan$AgdaModeVscode.emit(state.channels.log, {
        TAG: "SwitchVersionUI",
        _0: {
          TAG: "Others",
          _0: "View.destroy completed"
        }
      });
  ((async function () {
          var selectedItem = selectedItems[0];
          if (selectedItem === undefined) {
            return ;
          }
          if (selectedItem.label === openDownloadFolder) {
            var globalStorageUriAsFile = Vscode.Uri.file(state.globalStorageUri.fsPath);
            await Vscode.env.openExternal(globalStorageUriAsFile);
            return ;
          }
          if (selectedItem.label === downloadLatestALS) {
            var match = await getAvailableDownload(state, platformDeps);
            if (match !== undefined) {
              var versionString = match[1];
              if (match[0]) {
                await Vscode.window.showInformationMessage(versionString + " is already downloaded");
                return ;
              }
              var platform = await platformDeps.determinePlatform();
              if (platform.TAG === "Ok") {
                var error = await platformDeps.downloadLatestALS(state.memento, state.globalStorageUri)(platform._0);
                if (error.TAG === "Ok") {
                  var newDownloadInfo = await getAvailableDownload(state, platformDeps);
                  refreshFromMemento(manager);
                  await updateUI(newDownloadInfo);
                  await Vscode.window.showInformationMessage(versionString + " successfully downloaded");
                  return ;
                }
                await Vscode.window.showErrorMessage(Connection__Download$AgdaModeVscode.$$Error.toString(error._0));
                return ;
              }
              await Vscode.window.showErrorMessage("Failed to determine the platform for downloading the Agda Language Server");
              return ;
            }
            await Vscode.window.showErrorMessage("Download not available for this platform");
            return ;
          }
          var selectedPath = selectedItem.detail;
          if (selectedPath === undefined) {
            return ;
          }
          var original = await Connection__Endpoint$AgdaModeVscode.getPicked(state.memento, Config$AgdaModeVscode.Connection.getAgdaPaths());
          if (original.TAG === "Ok") {
            var originalPath = Connection__URI$AgdaModeVscode.toString(Connection__Endpoint$AgdaModeVscode.toURI(original._0));
            var originalFsPath = originalPath.startsWith("file://") ? Vscode.Uri.parse(originalPath).fsPath : originalPath;
            var selectionChanged = selectedPath !== originalFsPath;
            if (!selectionChanged) {
              return ;
            }
            var selectedPathAsUri = Vscode.Uri.file(selectedPath).toString();
            var uri = Connection__URI$AgdaModeVscode.parse(selectedPathAsUri);
            if (uri.TAG !== "FileURI") {
              return ;
            }
            var endpoint = await Connection__Endpoint$AgdaModeVscode.fromVSCodeUri(uri._1);
            if (endpoint.TAG !== "Ok") {
              return ;
            }
            var endpoint$1 = endpoint._0;
            await Connection__Endpoint$AgdaModeVscode.setPicked(state.memento, endpoint$1);
            await Config$AgdaModeVscode.Connection.addAgdaPath(Connection__Endpoint$AgdaModeVscode.toURI(endpoint$1));
            return await switchAgdaVersion(state);
          }
          var selectedPathAsUri$1 = Vscode.Uri.file(selectedPath).toString();
          var uri$1 = Connection__URI$AgdaModeVscode.parse(selectedPathAsUri$1);
          if (uri$1.TAG !== "FileURI") {
            return ;
          }
          var endpoint$2 = await Connection__Endpoint$AgdaModeVscode.fromVSCodeUri(uri$1._1);
          if (endpoint$2.TAG !== "Ok") {
            return ;
          }
          var endpoint$3 = endpoint$2._0;
          await Connection__Endpoint$AgdaModeVscode.setPicked(state.memento, endpoint$3);
          await Config$AgdaModeVscode.Connection.addAgdaPath(Connection__Endpoint$AgdaModeVscode.toURI(endpoint$3));
          return await switchAgdaVersion(state);
        })());
}

function onHide$1(state, view) {
  Chan$AgdaModeVscode.emit(state.channels.log, {
        TAG: "SwitchVersionUI",
        _0: {
          TAG: "Others",
          _0: "Handler.onHide called"
        }
      });
  destroy(view);
  Chan$AgdaModeVscode.emit(state.channels.log, {
        TAG: "SwitchVersionUI",
        _0: {
          TAG: "Others",
          _0: "View.destroy completed"
        }
      });
}

async function onActivate(state, platformDeps) {
  var manager = make$1(state);
  var view = make();
  var match = Memento$AgdaModeVscode.Module.PickedConnection.get(manager.memento);
  if (match === undefined) {
    var path = await Connection__Endpoint$AgdaModeVscode.getPickedRaw(manager.memento, Config$AgdaModeVscode.Connection.getAgdaPaths2());
    if (path !== undefined) {
      Memento$AgdaModeVscode.Module.PickedConnection.set(manager.memento, path);
    }
    
  }
  var updateUI = async function (downloadInfo) {
    var itemData = await getItemData(manager, downloadInfo);
    var endpointItemDatas = Core__Array.filterMap(itemData, (function (item) {
            var match = item.itemType;
            if (typeof match !== "object") {
              return ;
            }
            if (match.TAG !== "Endpoint") {
              return ;
            }
            var entry = match._1;
            return [
                    match._0,
                    entry.endpoint,
                    entry.error,
                    item.isSelected
                  ];
          }));
    Chan$AgdaModeVscode.emit(state.channels.log, {
          TAG: "SwitchVersionUI",
          _0: {
            TAG: "UpdateEndpoints",
            _0: endpointItemDatas
          }
        });
    var items = fromItemDataArray(itemData, state.extensionUri);
    return updateItems(view, items);
  };
  setPlaceholder(view, "Switch Agda Version");
  await updateUI(undefined);
  view.quickPick.show();
  Chan$AgdaModeVscode.emit(state.channels.log, {
        TAG: "SwitchVersionUI",
        _0: {
          TAG: "Others",
          _0: "QuickPick shown"
        }
      });
  var downloadInfoPromise = getAvailableDownload(state, platformDeps);
  onSelection(view, (function (selectedItems) {
          onSelection$1(state, platformDeps, manager, updateUI, view, selectedItems);
        }));
  onHide(view, (function () {
          onHide$1(state, view);
        }));
  var backgroundUpdate = async function () {
    try {
      var downloadInfo = await downloadInfoPromise;
      var phase2Changed = await syncWithFilesystem(manager, platformDeps);
      if (phase2Changed) {
        await updateUI(downloadInfo);
      }
      var phase3Changed = await probeVersions(manager);
      if (phase3Changed) {
        await updateUI(downloadInfo);
      }
      if (!phase2Changed && !phase3Changed) {
        return await updateUI(downloadInfo);
      } else {
        return ;
      }
    }
    catch (_exn){
      return ;
    }
  };
  backgroundUpdate();
}

var Handler = {
  onSelection: onSelection$1,
  onHide: onHide$1,
  onActivate: onActivate
};

var activate = onActivate;

exports.Constants = Constants;
exports.ItemData = ItemData;
exports.Item = Item;
exports.View = View;
exports.SwitchVersionManager = SwitchVersionManager;
exports.switchAgdaVersion = switchAgdaVersion;
exports.Download = Download;
exports.Handler = Handler;
exports.activate = activate;
/* vscode Not a pure module */
