// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Vscode = require("vscode");
var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Nodepath = require("node:path");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Core__Array = require("@rescript/core/lib/js/src/Core__Array.bs.js");
var PervasivesU = require("rescript/lib/js/pervasivesU.js");
var FS$AgdaModeVscode = require("../FS.bs.js");
var Chan$AgdaModeVscode = require("../Util/Chan.bs.js");
var Item$AgdaModeVscode = require("../View/Component/Item.bs.js");
var Util$AgdaModeVscode = require("../Util/Util.bs.js");
var Config$AgdaModeVscode = require("../Config.bs.js");
var Memento$AgdaModeVscode = require("../Memento.bs.js");
var Connection$AgdaModeVscode = require("../Connection/Connection.bs.js");
var State__View$AgdaModeVscode = require("./State__View.bs.js");
var Connection__URI$AgdaModeVscode = require("../Connection/Shared/Connection__URI.bs.js");
var Connection__Error$AgdaModeVscode = require("../Connection/Shared/Connection__Error.bs.js");
var Connection__Download$AgdaModeVscode = require("../Connection/Download/Connection__Download.bs.js");

var agdaVersionPrefix = "Agda v";

var alsWithSquirrel = "$(squirrel)  ALS v";

var downloadLatestALS = "$(cloud-download)  Download the latest Agda Language Server";

var deleteDownloads = "$(trash)  Delete downloads";

var downloadedAndInstalled = "Downloaded and installed";

var Constants = {
  agdaVersionPrefix: agdaVersionPrefix,
  alsWithSquirrel: alsWithSquirrel,
  downloadLatestALS: downloadLatestALS,
  deleteDownloads: deleteDownloads,
  downloadedAndInstalled: downloadedAndInstalled
};

function toString(item) {
  if (typeof item !== "object") {
    if (item === "DeleteDownloads") {
      return "DeleteDownloads";
    } else {
      return "NoInstallations";
    }
  }
  switch (item.TAG) {
    case "Endpoint" :
        return "Endpoint: " + item._0 + ", " + Memento$AgdaModeVscode.Module.Endpoints.endpointToString(item._1.endpoint) + (
                item._2 ? ", selected" : ""
              );
    case "DownloadAction" :
        return "DownloadAction: downloaded=" + PervasivesU.string_of_bool(item._0) + ", versionString=" + item._1 + ", type=" + item._2;
    case "Separator" :
        return "Separator: " + item._0;
    
  }
}

function shouldEndpointHaveIcon(endpoint) {
  if (typeof endpoint !== "object" || endpoint.TAG !== "Agda") {
    return false;
  } else {
    return true;
  }
}

function getEndpointDisplayInfo(filename, entry) {
  var match = entry.endpoint;
  var match$1 = entry.error;
  if (typeof match !== "object") {
    if (match$1 !== undefined) {
      return [
              "$(error) " + filename,
              "Error: " + match$1
            ];
    } else {
      return [
              "$(question) " + filename,
              "Unknown executable"
            ];
    }
  }
  if (match.TAG === "Agda") {
    var version = match._0;
    if (version !== undefined) {
      return [
              agdaVersionPrefix + version,
              undefined
            ];
    } else {
      return [
              "Agda (version unknown)",
              undefined
            ];
    }
  }
  var match$2 = match._0;
  if (match$2 !== undefined) {
    return [
            alsWithSquirrel + match$2[0] + ", " + agdaVersionPrefix + match$2[1],
            undefined
          ];
  } else {
    return [
            alsWithSquirrel + "(version unknown)",
            undefined
          ];
  }
}

function entriesToItemData(entries, pickedPath, downloadItems) {
  var entriesArray = Object.entries(entries);
  var hasEndpoints = entriesArray.length > 0;
  var endpointItems = pickedPath !== undefined ? entriesArray.map(function (param) {
          var path = param[0];
          return {
                  TAG: "Endpoint",
                  _0: path,
                  _1: param[1],
                  _2: pickedPath === path
                };
        }) : entriesArray.map(function (param) {
          return {
                  TAG: "Endpoint",
                  _0: param[0],
                  _1: param[1],
                  _2: false
                };
        });
  var sectionsWithInstalled = hasEndpoints ? [{
          TAG: "Separator",
          _0: "Installed"
        }].concat(endpointItems) : ["NoInstallations"];
  var sectionsWithDownload;
  if (downloadItems.length > 0) {
    var nonDevDownloads = downloadItems.filter(function (param) {
          return param[2] !== "dev";
        });
    var downloadSectionItems = nonDevDownloads.map(function (param) {
          return {
                  TAG: "DownloadAction",
                  _0: param[0],
                  _1: param[1],
                  _2: param[2]
                };
        });
    sectionsWithDownload = downloadSectionItems.length > 0 ? sectionsWithInstalled.concat([{
                TAG: "Separator",
                _0: "Download"
              }].concat(downloadSectionItems)) : sectionsWithInstalled;
  } else {
    sectionsWithDownload = sectionsWithInstalled;
  }
  return sectionsWithDownload.concat([
              {
                TAG: "Separator",
                _0: "Misc"
              },
              "DeleteDownloads"
            ]);
}

var ItemData = {
  toString: toString,
  shouldEndpointHaveIcon: shouldEndpointHaveIcon,
  getEndpointDisplayInfo: getEndpointDisplayInfo,
  entriesToItemData: entriesToItemData
};

function createQuickPickItem(label, description, detail) {
  if (description !== undefined) {
    if (detail !== undefined) {
      return {
              description: description,
              detail: detail,
              label: label
            };
    } else {
      return {
              description: description,
              label: label
            };
    }
  } else if (detail !== undefined) {
    return {
            detail: detail,
            label: label
          };
  } else {
    return {
            label: label
          };
  }
}

function fromItemData(itemData, extensionUri) {
  var match;
  if (typeof itemData !== "object") {
    match = itemData === "DeleteDownloads" ? [
        deleteDownloads,
        "Delete all downloaded files and clear cached release metadata",
        undefined
      ] : [
        "$(info) No installations found",
        "Try installing Agda or ALS first",
        "No executable paths detected"
      ];
  } else {
    switch (itemData.TAG) {
      case "Endpoint" :
          var path = itemData._0;
          var filename = Nodepath.basename(path);
          var match$1 = getEndpointDisplayInfo(filename, itemData._1);
          var errorDescription = match$1[1];
          var description = itemData._2 ? (
              errorDescription !== undefined ? errorDescription : "Selected"
            ) : (
              errorDescription !== undefined ? errorDescription : ""
            );
          match = [
            match$1[0],
            description,
            path
          ];
          break;
      case "DownloadAction" :
          var label = itemData._2 === "dev" ? "$(cloud-download)  Download the dev Agda Language Server" : downloadLatestALS;
          var description$1 = itemData._0 ? downloadedAndInstalled : "";
          match = [
            label,
            description$1,
            itemData._1
          ];
          break;
      case "Separator" :
          match = [
            itemData._0,
            undefined,
            undefined
          ];
          break;
      
    }
  }
  var detail = match[2];
  var description$2 = match[1];
  var label$1 = match[0];
  if (typeof itemData !== "object") {
    return createQuickPickItem(label$1, description$2, detail);
  }
  switch (itemData.TAG) {
    case "Endpoint" :
        var baseItem = createQuickPickItem(label$1, description$2, detail);
        if (!shouldEndpointHaveIcon(itemData._1.endpoint)) {
          return baseItem;
        }
        var newrecord = Caml_obj.obj_dup(baseItem);
        newrecord.iconPath = {
          dark: Vscode.Uri.joinPath(extensionUri, "asset/dark.png"),
          light: Vscode.Uri.joinPath(extensionUri, "asset/light.png")
        };
        return newrecord;
    case "Separator" :
        return {
                kind: -1,
                label: label$1
              };
    default:
      return createQuickPickItem(label$1, description$2, detail);
  }
}

function fromItemDataArray(itemDataArray, extensionUri) {
  return itemDataArray.map(function (itemData) {
              return fromItemData(itemData, extensionUri);
            });
}

var Item = {
  createQuickPickItem: createQuickPickItem,
  fromItemData: fromItemData,
  fromItemDataArray: fromItemDataArray
};

function make(log) {
  return {
          log: log,
          quickPick: Vscode.window.createQuickPick(),
          subscriptions: [],
          items: []
        };
}

function setPlaceholder(self, placeholder) {
  self.quickPick.placeholder = placeholder;
}

function updateItems(self, items) {
  self.items = items;
  self.quickPick.items = items;
}

function show(self) {
  self.quickPick.show();
}

function onSelection(self, handler) {
  Util$AgdaModeVscode.Disposable.add(self.quickPick.onDidChangeSelection(handler), self.subscriptions);
}

function onHide(self, handler) {
  Util$AgdaModeVscode.Disposable.add(self.quickPick.onDidHide(handler), self.subscriptions);
}

function destroy(self) {
  self.quickPick.dispose();
  self.subscriptions.forEach(function (sub) {
        sub.dispose();
      });
  Chan$AgdaModeVscode.emit(self.log, {
        TAG: "SwitchVersionUI",
        _0: "Destroyed"
      });
}

var View = {
  make: make,
  setPlaceholder: setPlaceholder,
  updateItems: updateItems,
  show: show,
  onSelection: onSelection,
  onHide: onHide,
  destroy: destroy
};

function make$1(state) {
  return {
          entries: Memento$AgdaModeVscode.Module.Endpoints.entries(state.memento),
          memento: state.memento,
          globalStorageUri: state.globalStorageUri
        };
}

async function getItemData(self, state, downloadItems) {
  var storedPath = Memento$AgdaModeVscode.Module.PickedConnection.get(self.memento);
  var pickedPath;
  if (storedPath !== undefined) {
    pickedPath = storedPath.startsWith("file://") ? Vscode.Uri.parse(storedPath).fsPath : storedPath;
  } else {
    var connection = state.connection;
    pickedPath = connection !== undefined ? Connection$AgdaModeVscode.getPath(connection) : undefined;
  }
  return entriesToItemData(self.entries, pickedPath, downloadItems);
}

function refreshFromMemento(self) {
  var newEntries = Memento$AgdaModeVscode.Module.Endpoints.entries(self.memento);
  var changed = newEntries !== self.entries;
  if (changed) {
    self.entries = newEntries;
  }
  return changed;
}

function inferEndpointType(filename) {
  var baseName = Nodepath.basename(filename.toLowerCase());
  var cleanName = baseName.replace(".exe", "").replace(".cmd", "").replace(".bat", "");
  if (cleanName === "agda" || cleanName.startsWith("agda-")) {
    return {
            TAG: "Agda",
            _0: undefined
          };
  } else if (cleanName === "als" || cleanName.startsWith("als-")) {
    return {
            TAG: "ALS",
            _0: undefined
          };
  } else {
    return "Unknown";
  }
}

async function syncWithFilesystem(self, platformDeps) {
  var endpoints = {};
  Config$AgdaModeVscode.Connection.getAgdaPaths().forEach(function (path) {
        var filename = Nodepath.basename(path);
        var endpoint = inferEndpointType(filename);
        endpoints[path] = endpoint;
      });
  var path = await platformDeps.findCommand("agda", undefined);
  if (path.TAG === "Ok") {
    endpoints[path._0] = {
      TAG: "Agda",
      _0: undefined
    };
  }
  var path$1 = await platformDeps.findCommand("als", undefined);
  if (path$1.TAG === "Ok") {
    endpoints[path$1._0] = {
      TAG: "ALS",
      _0: undefined
    };
  }
  await Memento$AgdaModeVscode.Module.Endpoints.syncWithPaths(self.memento, endpoints);
  return refreshFromMemento(self);
}

async function probeVersions(self) {
  var pathsToProbe = Core__Array.filterMap(Object.entries(self.entries), (function (param) {
          var match = param[1].endpoint;
          if (typeof match !== "object") {
            return ;
          }
          match.TAG === "Agda";
          if (match._0 !== undefined) {
            return ;
          } else {
            return param[0];
          }
        }));
  if (pathsToProbe.length === 0) {
    return false;
  }
  var probePromises = pathsToProbe.map(async function (path) {
        var error = await Connection$AgdaModeVscode.probeFilepath(path);
        if (error.TAG === "Ok") {
          var agdaVersion = error._0[1];
          switch (agdaVersion.TAG) {
            case "IsAgda" :
                await Memento$AgdaModeVscode.Module.Endpoints.setVersion(self.memento, path, {
                      TAG: "Agda",
                      _0: agdaVersion._0
                    });
                return path;
            case "IsALS" :
                await Memento$AgdaModeVscode.Module.Endpoints.setVersion(self.memento, path, {
                      TAG: "ALS",
                      _0: [
                        agdaVersion._0,
                        agdaVersion._1,
                        agdaVersion._2
                      ]
                    });
                return path;
            case "IsALSOfUnknownVersion" :
            case "IsALSWASM" :
                break;
            
          }
          await Memento$AgdaModeVscode.Module.Endpoints.setVersion(self.memento, path, {
                TAG: "ALS",
                _0: undefined
              });
          return path;
        }
        await Memento$AgdaModeVscode.Module.Endpoints.setError(self.memento, path, Connection__Error$AgdaModeVscode.Probe.toString(error._0));
        return path;
      });
  var updateResults = await Promise.all(probePromises);
  var updatedPaths = Core__Array.filterMap(updateResults, (function (x) {
          return x;
        }));
  if (updatedPaths.length > 0) {
    refreshFromMemento(self);
    return true;
  } else {
    return false;
  }
}

var SwitchVersionManager = {
  make: make$1,
  getItemData: getItemData,
  refreshFromMemento: refreshFromMemento,
  inferEndpointType: inferEndpointType,
  syncWithFilesystem: syncWithFilesystem,
  probeVersions: probeVersions
};

async function resolveDownloadOrderWithPlatform(platformOps, target, memento, globalStorageUri) {
  var _error = await platformOps.determinePlatform();
  if (_error.TAG === "Ok") {
    return await platformOps.resolveDownloadOrder(target, true)(memento, globalStorageUri, _error._0);
  } else {
    return {
            TAG: "Error",
            _0: "CannotFindCompatibleALSRelease"
          };
  }
}

async function switchAgdaVersion(state, uri) {
  var path;
  path = uri.TAG === "FileURI" ? uri._1.fsPath : uri._0;
  await State__View$AgdaModeVscode.Panel.displayConnectionStatus(state, undefined);
  await State__View$AgdaModeVscode.Panel.display(state, {
        TAG: "Plain",
        _0: "Switching connection..."
      }, []);
  var conn = await Connection$AgdaModeVscode.make(path, "FromConfig");
  if (conn.TAG === "Ok") {
    var conn$1 = conn._0;
    await Connection$AgdaModeVscode.destroy(state.connection, state.channels.log);
    state.connection = conn$1;
    await Memento$AgdaModeVscode.Module.PickedConnection.set(state.memento, path);
    await Config$AgdaModeVscode.Connection.addAgdaPath(state.channels.log, path);
    await State__View$AgdaModeVscode.Panel.displayConnectionStatus(state, conn$1);
    await State__View$AgdaModeVscode.Panel.display(state, {
          TAG: "Success",
          _0: "Switched to " + Connection$AgdaModeVscode.toString(conn$1)
        }, []);
    switch (conn$1.TAG) {
      case "Agda" :
          return await Memento$AgdaModeVscode.Module.Endpoints.setVersion(state.memento, path, {
                      TAG: "Agda",
                      _0: conn$1._2
                    });
      case "ALS" :
          var match = conn$1._2;
          if (match !== undefined) {
            return await Memento$AgdaModeVscode.Module.Endpoints.setVersion(state.memento, path, {
                        TAG: "ALS",
                        _0: [
                          match[0],
                          match[1],
                          match[2]
                        ]
                      });
          } else {
            return ;
          }
      case "ALSWASM" :
          var match$1 = conn$1._3;
          if (match$1 !== undefined) {
            return await Memento$AgdaModeVscode.Module.Endpoints.setVersion(state.memento, path, {
                        TAG: "ALS",
                        _0: [
                          match$1[0],
                          match$1[1],
                          match$1[2]
                        ]
                      });
          } else {
            return ;
          }
      
    }
  } else {
    var match$2 = Connection__Error$AgdaModeVscode.toString({
          TAG: "Establish",
          _0: conn._0
        });
    var header = {
      TAG: "Error",
      _0: "Failed to switch to a different installation: " + match$2[0]
    };
    var body = [Item$AgdaModeVscode.plainText(match$2[1])];
    return await State__View$AgdaModeVscode.Panel.display(state, header, body);
  }
}

async function getAvailableLatestDownload(state, platformDeps) {
  var match = await resolveDownloadOrderWithPlatform(platformDeps, "LatestALS", state.memento, state.globalStorageUri);
  if (match.TAG !== "Ok") {
    return ;
  }
  var match$1 = match._0;
  var match$2 = await platformDeps.alreadyDownloaded(state.globalStorageUri, "LatestALS");
  var downloaded = match$2 !== undefined;
  var versionString = Connection__Download$AgdaModeVscode.DownloadOrderConcrete.toVersionString({
        TAG: "FromGitHub",
        _0: match$1._0,
        _1: match$1._1
      });
  return [
          downloaded,
          versionString,
          "latest"
        ];
}

async function getAvailableDevDownload(state, platformDeps) {
  var _error = await resolveDownloadOrderWithPlatform(platformDeps, "DevALS", state.memento, state.globalStorageUri);
  if (_error.TAG !== "Ok") {
    return ;
  }
  var match = _error._0;
  var match$1 = await platformDeps.alreadyDownloaded(state.globalStorageUri, "DevALS");
  var downloaded = match$1 !== undefined;
  var versionString = Connection__Download$AgdaModeVscode.DownloadOrderConcrete.toVersionString({
        TAG: "FromGitHub",
        _0: match._0,
        _1: match._1
      });
  return [
          downloaded,
          versionString,
          "dev"
        ];
}

async function getAvailableDevWASMDownload(state, platformDeps) {
  var _error = await resolveDownloadOrderWithPlatform(platformDeps, "DevWASMALS", state.memento, state.globalStorageUri);
  if (_error.TAG !== "Ok") {
    return ;
  }
  var match = await platformDeps.alreadyDownloaded(state.globalStorageUri, "DevWASMALS");
  var downloaded = match !== undefined;
  var versionString = Connection__Download$AgdaModeVscode.DownloadOrderConcrete.toVersionString(_error._0);
  return [
          downloaded,
          versionString,
          "wasm"
        ];
}

function getPlaceholderDownloadItems() {
  var items = [[
      false,
      "Checking availability...",
      "latest"
    ]];
  if (Config$AgdaModeVscode.DevMode.get()) {
    return items.concat([[
                  false,
                  "Checking availability...",
                  "dev"
                ]]);
  } else {
    return items;
  }
}

async function getAllAvailableDownloads(state, platformDeps) {
  var latestPromise = getAvailableLatestDownload(state, platformDeps);
  var item = await latestPromise;
  var latestItem = item !== undefined ? item : [
      false,
      "Not available for this platform",
      "latest"
    ];
  var devItem;
  if (Config$AgdaModeVscode.DevMode.get()) {
    var item$1 = await getAvailableDevDownload(state, platformDeps);
    devItem = item$1 !== undefined ? [item$1] : [[
          false,
          "Not available for this platform",
          "dev"
        ]];
  } else {
    devItem = [];
  }
  return Belt_Array.concatMany([
              [latestItem],
              devItem
            ]);
}

var Download = {
  getAvailableLatestDownload: getAvailableLatestDownload,
  getAvailableDevDownload: getAvailableDevDownload,
  getAvailableDevWASMDownload: getAvailableDevWASMDownload,
  getPlaceholderDownloadItems: getPlaceholderDownloadItems,
  getAllAvailableDownloads: getAllAvailableDownloads
};

async function handleDownload(state, platformDeps, target, downloaded, versionString, refreshUIOpt) {
  var refreshUI = refreshUIOpt !== undefined ? Caml_option.valFromOption(refreshUIOpt) : undefined;
  Chan$AgdaModeVscode.emit(state.channels.log, {
        TAG: "SwitchVersionUI",
        _0: {
          TAG: "SelectedDownloadAction",
          _0: downloaded,
          _1: versionString
        }
      });
  if (downloaded) {
    var match = await resolveDownloadOrderWithPlatform(platformDeps, target, state.memento, state.globalStorageUri);
    if (match.TAG === "Ok") {
      var match$1 = match._0;
      var order = match$1._0;
      var fileName;
      switch (order) {
        case "LatestALS" :
        case "DevALS" :
            fileName = "als";
            break;
        case "DevWASMALS" :
            fileName = "als.wasm";
            break;
        
      }
      var downloadedUri = Vscode.Uri.joinPath(state.globalStorageUri, match$1._1.saveAsFileName, fileName);
      var downloadedPath;
      switch (order) {
        case "LatestALS" :
        case "DevALS" :
            downloadedPath = downloadedUri.fsPath;
            break;
        case "DevWASMALS" :
            downloadedPath = downloadedUri.toString();
            break;
        
      }
      await Config$AgdaModeVscode.Connection.addAgdaPath(state.channels.log, downloadedPath);
    }
    Vscode.window.showInformationMessage(versionString + " is already downloaded");
  } else {
    var error = await resolveDownloadOrderWithPlatform(platformDeps, target, state.memento, state.globalStorageUri);
    var downloadResult;
    downloadResult = error.TAG === "Ok" ? await platformDeps.download(state.globalStorageUri, error._0) : ({
          TAG: "Error",
          _0: error._0
        });
    if (downloadResult.TAG === "Ok") {
      await Config$AgdaModeVscode.Connection.addAgdaPath(state.channels.log, downloadResult._0);
      if (refreshUI !== undefined) {
        await refreshUI();
      }
      Vscode.window.showInformationMessage(versionString + " successfully downloaded");
    } else {
      Vscode.window.showErrorMessage(Connection__Download$AgdaModeVscode.$$Error.toString(downloadResult._0));
    }
  }
  return Chan$AgdaModeVscode.emit(state.channels.log, {
              TAG: "SwitchVersionUI",
              _0: "SelectionCompleted"
            });
}

function onSelection$1(state, platformDeps, manager, updateUI, view, selectedItems) {
  destroy(view);
  ((async function () {
          var selectedItem = selectedItems[0];
          if (selectedItem === undefined) {
            return Chan$AgdaModeVscode.emit(state.channels.log, {
                        TAG: "SwitchVersionUI",
                        _0: "SelectionCompleted"
                      });
          }
          if (selectedItem.label === deleteDownloads) {
            var deleteDir = async function (dirName) {
              var uri = Vscode.Uri.joinPath(state.globalStorageUri, dirName);
              await FS$AgdaModeVscode.deleteRecursive(uri);
            };
            await deleteDir("dev-wasm-als");
            await deleteDir("dev-als");
            await deleteDir("latest-als");
            await Memento$AgdaModeVscode.Module.ALSReleaseCache.clear(state.memento, "agda", "agda-language-server");
            await Memento$AgdaModeVscode.Module.ALSReleaseCache.clear(state.memento, "banacorn", "agda-language-server");
            await Memento$AgdaModeVscode.Module.PickedConnection.clear(state.memento);
            await Memento$AgdaModeVscode.Module.Endpoints.clear(state.memento);
            await Vscode.window.showInformationMessage("All downloads and cache deleted");
            return Chan$AgdaModeVscode.emit(state.channels.log, {
                        TAG: "SwitchVersionUI",
                        _0: "SelectionCompleted"
                      });
          }
          if (selectedItem.label === downloadLatestALS) {
            var downloadInfoResult = await getAvailableLatestDownload(state, platformDeps);
            if (downloadInfoResult !== undefined) {
              return await handleDownload(state, platformDeps, "LatestALS", downloadInfoResult[0], downloadInfoResult[1], Caml_option.some((async function () {
                                var newDownloadItems = await getAllAvailableDownloads(state, platformDeps);
                                refreshFromMemento(manager);
                                return await updateUI(newDownloadItems);
                              })));
            } else {
              await Vscode.window.showErrorMessage("Download not available for this platform");
              return Chan$AgdaModeVscode.emit(state.channels.log, {
                          TAG: "SwitchVersionUI",
                          _0: "SelectionCompleted"
                        });
            }
          }
          var selectedPath = selectedItem.detail;
          if (selectedPath === undefined) {
            return Chan$AgdaModeVscode.emit(state.channels.log, {
                        TAG: "SwitchVersionUI",
                        _0: "SelectionCompleted"
                      });
          }
          var path = Memento$AgdaModeVscode.Module.PickedConnection.get(manager.memento);
          var changed = path !== undefined ? selectedPath !== path : true;
          if (!changed) {
            return Chan$AgdaModeVscode.emit(state.channels.log, {
                        TAG: "SwitchVersionUI",
                        _0: "SelectionCompleted"
                      });
          }
          var entry = manager.entries[selectedPath];
          if (entry !== undefined) {
            Chan$AgdaModeVscode.emit(state.channels.log, {
                  TAG: "SwitchVersionUI",
                  _0: {
                    TAG: "SelectedEndpoint",
                    _0: selectedPath,
                    _1: entry,
                    _2: true
                  }
                });
          }
          var uri = Connection__URI$AgdaModeVscode.parse(selectedPath);
          await switchAgdaVersion(state, uri);
          return Chan$AgdaModeVscode.emit(state.channels.log, {
                      TAG: "SwitchVersionUI",
                      _0: "SelectionCompleted"
                    });
        })());
}

function onHide$1(view) {
  destroy(view);
}

async function onActivate(state, platformDeps) {
  var manager = make$1(state);
  var view = make(state.channels.log);
  var updateUI = async function (downloadItems) {
    var itemData = await getItemData(manager, state, downloadItems);
    var endpointItemDatas = Core__Array.filterMap(itemData, (function (item) {
            if (typeof item !== "object") {
              return ;
            }
            if (item.TAG !== "Endpoint") {
              return ;
            }
            var entry = item._1;
            return [
                    item._0,
                    entry.endpoint,
                    entry.error,
                    item._2
                  ];
          }));
    Chan$AgdaModeVscode.emit(state.channels.log, {
          TAG: "SwitchVersionUI",
          _0: {
            TAG: "UpdatedEndpoints",
            _0: endpointItemDatas
          }
        });
    var items = fromItemDataArray(itemData, state.extensionUri);
    return updateItems(view, items);
  };
  setPlaceholder(view, "Switch Agda Version");
  await updateUI(getPlaceholderDownloadItems());
  view.quickPick.show();
  Chan$AgdaModeVscode.emit(state.channels.log, {
        TAG: "SwitchVersionUI",
        _0: {
          TAG: "Others",
          _0: "QuickPick shown"
        }
      });
  var downloadItemsPromise = getAllAvailableDownloads(state, platformDeps);
  onSelection(view, (function (selectedItems) {
          onSelection$1(state, platformDeps, manager, updateUI, view, selectedItems);
        }));
  onHide(view, (function () {
          destroy(view);
        }));
  var backgroundUpdate = async function () {
    try {
      var downloadItems = await downloadItemsPromise;
      var phase2Changed = await syncWithFilesystem(manager, platformDeps);
      if (phase2Changed) {
        await updateUI(downloadItems);
      }
      var phase3Changed = await probeVersions(manager);
      if (phase3Changed) {
        await updateUI(downloadItems);
      }
      if (!phase2Changed && !phase3Changed) {
        return await updateUI(downloadItems);
      } else {
        return ;
      }
    }
    catch (_exn){
      return ;
    }
  };
  backgroundUpdate();
}

var Handler = {
  handleDownload: handleDownload,
  onSelection: onSelection$1,
  onHide: onHide$1,
  onActivate: onActivate
};

var activate = onActivate;

exports.Constants = Constants;
exports.ItemData = ItemData;
exports.Item = Item;
exports.View = View;
exports.SwitchVersionManager = SwitchVersionManager;
exports.resolveDownloadOrderWithPlatform = resolveDownloadOrderWithPlatform;
exports.switchAgdaVersion = switchAgdaVersion;
exports.Download = Download;
exports.Handler = Handler;
exports.activate = activate;
/* vscode Not a pure module */
