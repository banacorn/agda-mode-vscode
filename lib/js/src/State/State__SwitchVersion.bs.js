// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Vscode = require("vscode");
var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Nodepath = require("node:path");
var Core__Array = require("@rescript/core/lib/js/src/Core__Array.bs.js");
var PervasivesU = require("rescript/lib/js/pervasivesU.js");
var Core__Option = require("@rescript/core/lib/js/src/Core__Option.bs.js");
var Chan$AgdaModeVscode = require("../Util/Chan.bs.js");
var Item$AgdaModeVscode = require("../View/Component/Item.bs.js");
var Util$AgdaModeVscode = require("../Util/Util.bs.js");
var Config$AgdaModeVscode = require("../Config.bs.js");
var Memento$AgdaModeVscode = require("../Memento.bs.js");
var Connection$AgdaModeVscode = require("../Connection/Connection.bs.js");
var State__View$AgdaModeVscode = require("./State__View.bs.js");
var Connection__URI$AgdaModeVscode = require("../Connection/Shared/Connection__URI.bs.js");
var Connection__Error$AgdaModeVscode = require("../Connection/Shared/Connection__Error.bs.js");
var Connection__Download$AgdaModeVscode = require("../Connection/Download/Connection__Download.bs.js");
var Connection__LatestALS$AgdaModeVscode = require("../Connection/Download/Connection__LatestALS.bs.js");

var agdaVersionPrefix = "Agda v";

var alsWithSquirrel = "$(squirrel)  ALS v";

var downloadLatestALS = "$(cloud-download)  Download the latest Agda Language Server";

var openDownloadFolder = "$(folder-opened)  Open download folder";

var downloadedAndInstalled = "Downloaded and installed";

var Constants = {
  agdaVersionPrefix: agdaVersionPrefix,
  alsWithSquirrel: alsWithSquirrel,
  downloadLatestALS: downloadLatestALS,
  openDownloadFolder: openDownloadFolder,
  downloadedAndInstalled: downloadedAndInstalled
};

function toString(item) {
  if (typeof item !== "object") {
    return "NoInstallations";
  }
  switch (item.TAG) {
    case "Endpoint" :
        return "Endpoint: " + item._0 + ", " + Memento$AgdaModeVscode.Module.Endpoints.endpointToString(item._1.endpoint) + (
                item._2 ? ", selected" : ""
              );
    case "DownloadAction" :
        return "DownloadAction: downloaded=" + PervasivesU.string_of_bool(item._0) + ", versionString=" + item._1;
    case "OpenFolder" :
        return "OpenFolder: " + item._0;
    case "Separator" :
        return "Separator: " + item._0;
    
  }
}

function shouldEndpointHaveIcon(endpoint) {
  if (typeof endpoint !== "object" || endpoint.TAG !== "Agda") {
    return false;
  } else {
    return true;
  }
}

function getEndpointDisplayInfo(filename, entry) {
  var match = entry.endpoint;
  var match$1 = entry.error;
  if (typeof match !== "object") {
    if (match$1 !== undefined) {
      return [
              "$(error) " + filename,
              "Error: " + match$1
            ];
    } else {
      return [
              "$(question) " + filename,
              "Unknown executable"
            ];
    }
  }
  if (match.TAG === "Agda") {
    var version = match._0;
    if (version !== undefined) {
      return [
              agdaVersionPrefix + version,
              undefined
            ];
    } else {
      return [
              "Agda (version unknown)",
              undefined
            ];
    }
  }
  var match$2 = match._0;
  if (match$2 !== undefined) {
    return [
            alsWithSquirrel + match$2[0] + ", " + agdaVersionPrefix + match$2[1],
            undefined
          ];
  } else {
    return [
            alsWithSquirrel + "(version unknown)",
            undefined
          ];
  }
}

function entriesToItemData(entries, pickedPath, downloadItem, folderPath) {
  var entriesArray = Object.entries(entries);
  var hasEndpoints = entriesArray.length > 0;
  var endpointItems = pickedPath !== undefined ? entriesArray.map(function (param) {
          var path = param[0];
          return {
                  TAG: "Endpoint",
                  _0: path,
                  _1: param[1],
                  _2: pickedPath === path
                };
        }) : entriesArray.map(function (param) {
          return {
                  TAG: "Endpoint",
                  _0: param[0],
                  _1: param[1],
                  _2: false
                };
        });
  var sectionsWithInstalled = hasEndpoints ? [{
          TAG: "Separator",
          _0: "Installed"
        }].concat(endpointItems) : ["NoInstallations"];
  var sectionsWithDownload = downloadItem !== undefined ? sectionsWithInstalled.concat([
          {
            TAG: "Separator",
            _0: "Download"
          },
          {
            TAG: "DownloadAction",
            _0: downloadItem[0],
            _1: downloadItem[1]
          }
        ]) : sectionsWithInstalled;
  return sectionsWithDownload.concat([
              {
                TAG: "Separator",
                _0: "Misc"
              },
              {
                TAG: "OpenFolder",
                _0: folderPath
              }
            ]);
}

var ItemData = {
  toString: toString,
  shouldEndpointHaveIcon: shouldEndpointHaveIcon,
  getEndpointDisplayInfo: getEndpointDisplayInfo,
  entriesToItemData: entriesToItemData
};

function createQuickPickItem(label, description, detail) {
  if (description !== undefined) {
    if (detail !== undefined) {
      return {
              description: description,
              detail: detail,
              label: label
            };
    } else {
      return {
              description: description,
              label: label
            };
    }
  } else if (detail !== undefined) {
    return {
            detail: detail,
            label: label
          };
  } else {
    return {
            label: label
          };
  }
}

function fromItemData(itemData, extensionUri) {
  var match;
  if (typeof itemData !== "object") {
    match = [
      "$(info) No installations found",
      "Try installing Agda or ALS first",
      "No executable paths detected"
    ];
  } else {
    switch (itemData.TAG) {
      case "Endpoint" :
          var path = itemData._0;
          var filename = Nodepath.basename(path);
          var match$1 = getEndpointDisplayInfo(filename, itemData._1);
          var errorDescription = match$1[1];
          var description = itemData._2 ? (
              errorDescription !== undefined ? errorDescription : "Selected"
            ) : (
              errorDescription !== undefined ? errorDescription : ""
            );
          match = [
            match$1[0],
            description,
            path
          ];
          break;
      case "DownloadAction" :
          var description$1 = itemData._0 ? downloadedAndInstalled : "";
          match = [
            downloadLatestALS,
            description$1,
            itemData._1
          ];
          break;
      case "OpenFolder" :
          match = [
            openDownloadFolder,
            "Where the language servers are downloaded to",
            itemData._0
          ];
          break;
      case "Separator" :
          match = [
            itemData._0,
            undefined,
            undefined
          ];
          break;
      
    }
  }
  var detail = match[2];
  var description$2 = match[1];
  var label = match[0];
  if (typeof itemData !== "object") {
    return createQuickPickItem(label, description$2, detail);
  }
  switch (itemData.TAG) {
    case "Endpoint" :
        var baseItem = createQuickPickItem(label, description$2, detail);
        if (!shouldEndpointHaveIcon(itemData._1.endpoint)) {
          return baseItem;
        }
        var newrecord = Caml_obj.obj_dup(baseItem);
        newrecord.iconPath = {
          dark: Vscode.Uri.joinPath(extensionUri, "asset/dark.png"),
          light: Vscode.Uri.joinPath(extensionUri, "asset/light.png")
        };
        return newrecord;
    case "Separator" :
        return {
                kind: -1,
                label: label
              };
    default:
      return createQuickPickItem(label, description$2, detail);
  }
}

function fromItemDataArray(itemDataArray, extensionUri) {
  return itemDataArray.map(function (itemData) {
              return fromItemData(itemData, extensionUri);
            });
}

var Item = {
  createQuickPickItem: createQuickPickItem,
  fromItemData: fromItemData,
  fromItemDataArray: fromItemDataArray
};

function make(log) {
  return {
          log: log,
          quickPick: Vscode.window.createQuickPick(),
          subscriptions: [],
          items: []
        };
}

function setPlaceholder(self, placeholder) {
  self.quickPick.placeholder = placeholder;
}

function updateItems(self, items) {
  self.items = items;
  self.quickPick.items = items;
}

function show(self) {
  self.quickPick.show();
}

function onSelection(self, handler) {
  Util$AgdaModeVscode.Disposable.add(self.quickPick.onDidChangeSelection(handler), self.subscriptions);
}

function onHide(self, handler) {
  Util$AgdaModeVscode.Disposable.add(self.quickPick.onDidHide(handler), self.subscriptions);
}

function destroy(self) {
  self.quickPick.dispose();
  self.subscriptions.forEach(function (sub) {
        sub.dispose();
      });
  Chan$AgdaModeVscode.emit(self.log, {
        TAG: "SwitchVersionUI",
        _0: "Destroyed"
      });
}

var View = {
  make: make,
  setPlaceholder: setPlaceholder,
  updateItems: updateItems,
  show: show,
  onSelection: onSelection,
  onHide: onHide,
  destroy: destroy
};

function formatAgdaVersion(version) {
  return "Agda v" + version;
}

function formatALSVersion(alsVersion, agdaVersion) {
  return "Agda v" + agdaVersion + " Language Server v" + alsVersion;
}

function formatSwitchingMessage(version) {
  return "Switching to " + version;
}

function formatSwitchedMessage(version) {
  return "Switched to " + version;
}

var VersionDisplay = {
  formatAgdaVersion: formatAgdaVersion,
  formatALSVersion: formatALSVersion,
  formatSwitchingMessage: formatSwitchingMessage,
  formatSwitchedMessage: formatSwitchedMessage
};

function make$1(state) {
  return {
          entries: Memento$AgdaModeVscode.Module.Endpoints.entries(state.memento),
          memento: state.memento,
          globalStorageUri: state.globalStorageUri
        };
}

async function getItemData(self, state, downloadInfo) {
  var storedPath = Memento$AgdaModeVscode.Module.PickedConnection.get(self.memento);
  var pickedPath;
  if (storedPath !== undefined) {
    pickedPath = storedPath.startsWith("file://") ? Vscode.Uri.parse(storedPath).fsPath : storedPath;
  } else {
    var connection = state.connection;
    pickedPath = connection !== undefined ? connection._1 : undefined;
  }
  var folderPath = self.globalStorageUri.fsPath;
  return entriesToItemData(self.entries, pickedPath, downloadInfo, folderPath);
}

function refreshFromMemento(self) {
  var newEntries = Memento$AgdaModeVscode.Module.Endpoints.entries(self.memento);
  var changed = newEntries !== self.entries;
  if (changed) {
    self.entries = newEntries;
  }
  return changed;
}

async function syncWithFilesystem(self, platformDeps) {
  var discoveredEndpoints = await platformDeps.getInstalledEndpointsAndPersistThem(self.globalStorageUri);
  await Memento$AgdaModeVscode.Module.Endpoints.syncWithPaths(self.memento, discoveredEndpoints);
  return refreshFromMemento(self);
}

async function probeVersions(self) {
  var pathsToProbe = Core__Array.filterMap(Object.entries(self.entries), (function (param) {
          var match = param[1].endpoint;
          if (typeof match !== "object") {
            return ;
          }
          match.TAG === "Agda";
          if (match._0 !== undefined) {
            return ;
          } else {
            return param[0];
          }
        }));
  if (pathsToProbe.length === 0) {
    return false;
  }
  var probePromises = pathsToProbe.map(async function (path) {
        var error = await Connection$AgdaModeVscode.probeFilepath(path);
        if (error.TAG === "Ok") {
          var agdaVersion = error._0[1];
          if (agdaVersion.TAG === "Ok") {
            await Memento$AgdaModeVscode.Module.Endpoints.setVersion(self.memento, path, {
                  TAG: "Agda",
                  _0: agdaVersion._0
                });
            return path;
          }
          var match = agdaVersion._0;
          await Memento$AgdaModeVscode.Module.Endpoints.setVersion(self.memento, path, {
                TAG: "ALS",
                _0: [
                  match[0],
                  match[1],
                  match[2]
                ]
              });
          return path;
        }
        await Memento$AgdaModeVscode.Module.Endpoints.setError(self.memento, path, Connection__Error$AgdaModeVscode.Probe.toString(error._0));
        return path;
      });
  var updateResults = await Promise.all(probePromises);
  var updatedPaths = Core__Array.filterMap(updateResults, (function (x) {
          return x;
        }));
  if (updatedPaths.length > 0) {
    refreshFromMemento(self);
    return true;
  } else {
    return false;
  }
}

var SwitchVersionManager = {
  make: make$1,
  getItemData: getItemData,
  refreshFromMemento: refreshFromMemento,
  syncWithFilesystem: syncWithFilesystem,
  probeVersions: probeVersions
};

async function switchAgdaVersion(state) {
  await State__View$AgdaModeVscode.Panel.displayStatus(state, "");
  await State__View$AgdaModeVscode.Panel.display(state, {
        TAG: "Plain",
        _0: "Switching connection..."
      }, []);
  await Connection$AgdaModeVscode.destroy(state.connection, state.channels.log);
  var configPaths = Config$AgdaModeVscode.Connection.getAgdaPaths();
  var storedPathBeforeConnection = Memento$AgdaModeVscode.Module.PickedConnection.get(state.memento);
  var pathsFromSystem;
  if (storedPathBeforeConnection !== undefined) {
    var pathExists = configPaths.includes(storedPathBeforeConnection);
    pathsFromSystem = pathExists ? configPaths : [storedPathBeforeConnection].concat(configPaths);
  } else {
    pathsFromSystem = configPaths;
  }
  var conn = await Connection$AgdaModeVscode.make(state.platformDeps, state.memento, state.globalStorageUri, pathsFromSystem, [
        "als",
        "agda"
      ], state.channels.log);
  if (conn.TAG === "Ok") {
    var conn$1 = conn._0;
    state.connection = conn$1;
    if (conn$1.TAG === "Agda") {
      var formattedVersion = "Agda v" + conn$1._2;
      await State__View$AgdaModeVscode.Panel.displayStatus(state, formattedVersion);
      return await State__View$AgdaModeVscode.Panel.display(state, {
                  TAG: "Success",
                  _0: "Switched to " + formattedVersion
                }, []);
    }
    var match = conn$1._2;
    var formattedVersion$1 = formatALSVersion(match[0], match[1]);
    await State__View$AgdaModeVscode.Panel.displayStatus(state, formattedVersion$1);
    return await State__View$AgdaModeVscode.Panel.display(state, {
                TAG: "Success",
                _0: "Switched to " + formattedVersion$1
              }, []);
  }
  var match$1 = Connection__Error$AgdaModeVscode.toString(conn._0);
  var header = {
    TAG: "Error",
    _0: "Failed to switch to a different installation: " + match$1[0]
  };
  var body = [Item$AgdaModeVscode.plainText(match$1[1])];
  return await State__View$AgdaModeVscode.Panel.display(state, header, body);
}

async function getAvailableDownload(state, platformDeps) {
  var platform = await platformDeps.determinePlatform();
  if (platform.TAG !== "Ok") {
    return ;
  }
  var fetchSpec = await Connection__LatestALS$AgdaModeVscode.getFetchSpec(state.memento, state.globalStorageUri, platform._0);
  if (fetchSpec.TAG !== "Ok") {
    return ;
  }
  var fetchSpec$1 = fetchSpec._0;
  var installedEndpoints = await platformDeps.getInstalledEndpointsAndPersistThem(state.globalStorageUri);
  var installedPaths = Object.entries(installedEndpoints).map(function (param) {
        return param[0];
      });
  var filename = Nodepath.join(state.globalStorageUri.fsPath, fetchSpec$1.saveAsFileName, "als");
  var filenameAsUri = Vscode.Uri.file(filename).toString();
  var downloaded = installedPaths.includes(filenameAsUri);
  var getAgdaVersion = function (asset) {
    return asset.name.replace(/als-Agda-/, "").replace(/-.*/, "");
  };
  var agdaVersion = getAgdaVersion(fetchSpec$1.asset);
  var alsVersion = Core__Option.getOr(Core__Array.last(fetchSpec$1.release.name.split(".")), fetchSpec$1.release.name);
  var versionString = formatALSVersion(alsVersion, agdaVersion);
  return [
          downloaded,
          versionString
        ];
}

var Download = {
  getAvailableDownload: getAvailableDownload
};

function onSelection$1(state, platformDeps, manager, updateUI, view, selectedItems) {
  destroy(view);
  ((async function () {
          var selectedItem = selectedItems[0];
          if (selectedItem === undefined) {
            return Chan$AgdaModeVscode.emit(state.channels.log, {
                        TAG: "SwitchVersionUI",
                        _0: "SelectionCompleted"
                      });
          }
          if (selectedItem.label === openDownloadFolder) {
            var globalStorageUriAsFile = Vscode.Uri.file(state.globalStorageUri.fsPath);
            Chan$AgdaModeVscode.emit(state.channels.log, {
                  TAG: "SwitchVersionUI",
                  _0: {
                    TAG: "SelectedOpenFolder",
                    _0: state.globalStorageUri.fsPath
                  }
                });
            await Vscode.env.openExternal(globalStorageUriAsFile);
            return Chan$AgdaModeVscode.emit(state.channels.log, {
                        TAG: "SwitchVersionUI",
                        _0: "SelectionCompleted"
                      });
          }
          if (selectedItem.label === downloadLatestALS) {
            var match = await getAvailableDownload(state, platformDeps);
            if (match !== undefined) {
              var versionString = match[1];
              var downloaded = match[0];
              Chan$AgdaModeVscode.emit(state.channels.log, {
                    TAG: "SwitchVersionUI",
                    _0: {
                      TAG: "SelectedDownloadAction",
                      _0: downloaded,
                      _1: versionString
                    }
                  });
              if (downloaded) {
                Vscode.window.showInformationMessage(versionString + " is already downloaded");
                return Chan$AgdaModeVscode.emit(state.channels.log, {
                            TAG: "SwitchVersionUI",
                            _0: "SelectionCompleted"
                          });
              }
              var platform = await platformDeps.determinePlatform();
              if (platform.TAG === "Ok") {
                var error = await platformDeps.downloadLatestALS(state.channels.log, state.memento, state.globalStorageUri)(platform._0);
                if (error.TAG === "Ok") {
                  var newDownloadInfo = await getAvailableDownload(state, platformDeps);
                  refreshFromMemento(manager);
                  await updateUI(newDownloadInfo);
                  Vscode.window.showInformationMessage(versionString + " successfully downloaded");
                  return Chan$AgdaModeVscode.emit(state.channels.log, {
                              TAG: "SwitchVersionUI",
                              _0: "SelectionCompleted"
                            });
                }
                Vscode.window.showErrorMessage(Connection__Download$AgdaModeVscode.$$Error.toString(error._0));
                return Chan$AgdaModeVscode.emit(state.channels.log, {
                            TAG: "SwitchVersionUI",
                            _0: "SelectionCompleted"
                          });
              }
              Vscode.window.showErrorMessage("Failed to determine the platform for downloading the Agda Language Server");
              return Chan$AgdaModeVscode.emit(state.channels.log, {
                          TAG: "SwitchVersionUI",
                          _0: "SelectionCompleted"
                        });
            }
            await Vscode.window.showErrorMessage("Download not available for this platform");
            return Chan$AgdaModeVscode.emit(state.channels.log, {
                        TAG: "SwitchVersionUI",
                        _0: "SelectionCompleted"
                      });
          }
          var selectedPath = selectedItem.detail;
          if (selectedPath === undefined) {
            return Chan$AgdaModeVscode.emit(state.channels.log, {
                        TAG: "SwitchVersionUI",
                        _0: "SelectionCompleted"
                      });
          }
          var path = Memento$AgdaModeVscode.Module.PickedConnection.get(manager.memento);
          var changed = path !== undefined ? selectedPath !== path : true;
          if (!changed) {
            return Chan$AgdaModeVscode.emit(state.channels.log, {
                        TAG: "SwitchVersionUI",
                        _0: "SelectionCompleted"
                      });
          }
          var entry = manager.entries[selectedPath];
          if (entry !== undefined) {
            Chan$AgdaModeVscode.emit(state.channels.log, {
                  TAG: "SwitchVersionUI",
                  _0: {
                    TAG: "SelectedEndpoint",
                    _0: selectedPath,
                    _1: entry,
                    _2: true
                  }
                });
          }
          var uri = Connection__URI$AgdaModeVscode.parse(selectedPath);
          if (uri.TAG !== "FileURI") {
            return Chan$AgdaModeVscode.emit(state.channels.log, {
                        TAG: "SwitchVersionUI",
                        _0: "SelectionCompleted"
                      });
          }
          var path$1 = uri._1.fsPath;
          await Memento$AgdaModeVscode.Module.PickedConnection.set(state.memento, path$1);
          await Config$AgdaModeVscode.Connection.addAgdaPath(state.channels.log, path$1);
          await switchAgdaVersion(state);
          return Chan$AgdaModeVscode.emit(state.channels.log, {
                      TAG: "SwitchVersionUI",
                      _0: "SelectionCompleted"
                    });
        })());
}

function onHide$1(view) {
  destroy(view);
}

async function onActivate(state, platformDeps) {
  var manager = make$1(state);
  var view = make(state.channels.log);
  var updateUI = async function (downloadInfo) {
    var itemData = await getItemData(manager, state, downloadInfo);
    var endpointItemDatas = Core__Array.filterMap(itemData, (function (item) {
            if (typeof item !== "object") {
              return ;
            }
            if (item.TAG !== "Endpoint") {
              return ;
            }
            var entry = item._1;
            return [
                    item._0,
                    entry.endpoint,
                    entry.error,
                    item._2
                  ];
          }));
    Chan$AgdaModeVscode.emit(state.channels.log, {
          TAG: "SwitchVersionUI",
          _0: {
            TAG: "UpdatedEndpoints",
            _0: endpointItemDatas
          }
        });
    var items = fromItemDataArray(itemData, state.extensionUri);
    return updateItems(view, items);
  };
  setPlaceholder(view, "Switch Agda Version");
  await updateUI(undefined);
  view.quickPick.show();
  Chan$AgdaModeVscode.emit(state.channels.log, {
        TAG: "SwitchVersionUI",
        _0: {
          TAG: "Others",
          _0: "QuickPick shown"
        }
      });
  var downloadInfoPromise = getAvailableDownload(state, platformDeps);
  onSelection(view, (function (selectedItems) {
          onSelection$1(state, platformDeps, manager, updateUI, view, selectedItems);
        }));
  onHide(view, (function () {
          destroy(view);
        }));
  var backgroundUpdate = async function () {
    try {
      var downloadInfo = await downloadInfoPromise;
      var phase2Changed = await syncWithFilesystem(manager, platformDeps);
      if (phase2Changed) {
        await updateUI(downloadInfo);
      }
      var phase3Changed = await probeVersions(manager);
      if (phase3Changed) {
        await updateUI(downloadInfo);
      }
      if (!phase2Changed && !phase3Changed) {
        return await updateUI(downloadInfo);
      } else {
        return ;
      }
    }
    catch (_exn){
      return ;
    }
  };
  backgroundUpdate();
}

var Handler = {
  onSelection: onSelection$1,
  onHide: onHide$1,
  onActivate: onActivate
};

var activate = onActivate;

exports.Constants = Constants;
exports.ItemData = ItemData;
exports.Item = Item;
exports.View = View;
exports.VersionDisplay = VersionDisplay;
exports.SwitchVersionManager = SwitchVersionManager;
exports.switchAgdaVersion = switchAgdaVersion;
exports.Download = Download;
exports.Handler = Handler;
exports.activate = activate;
/* vscode Not a pure module */
