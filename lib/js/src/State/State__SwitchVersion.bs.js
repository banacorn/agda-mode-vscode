// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Vscode = require("vscode");
var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Nodepath = require("node:path");
var Core__Array = require("@rescript/core/lib/js/src/Core__Array.bs.js");
var PervasivesU = require("rescript/lib/js/pervasivesU.js");
var Core__Option = require("@rescript/core/lib/js/src/Core__Option.bs.js");
var Chan$AgdaModeVscode = require("../Util/Chan.bs.js");
var Item$AgdaModeVscode = require("../View/Component/Item.bs.js");
var Util$AgdaModeVscode = require("../Util/Util.bs.js");
var Config$AgdaModeVscode = require("../Config.bs.js");
var Memento$AgdaModeVscode = require("../Memento.bs.js");
var Connection$AgdaModeVscode = require("../Connection/Connection.bs.js");
var State__View$AgdaModeVscode = require("./State__View.bs.js");
var Connection__URI$AgdaModeVscode = require("../Connection/Shared/Connection__URI.bs.js");
var Connection__Error$AgdaModeVscode = require("../Connection/Shared/Connection__Error.bs.js");
var Connection__Download$AgdaModeVscode = require("../Connection/Download/Connection__Download.bs.js");

var agdaVersionPrefix = "Agda v";

var alsWithSquirrel = "$(squirrel)  ALS v";

var downloadLatestALS = "$(cloud-download)  Download the latest Agda Language Server";

var openDownloadFolder = "$(folder-opened)  Open download folder";

var downloadedAndInstalled = "Downloaded and installed";

var otherDownloads = "$(chevron-right)  Other Downloads";

var otherDownloadsDesc = "Browse other versions available for download";

var Constants = {
  agdaVersionPrefix: agdaVersionPrefix,
  alsWithSquirrel: alsWithSquirrel,
  downloadLatestALS: downloadLatestALS,
  openDownloadFolder: openDownloadFolder,
  downloadedAndInstalled: downloadedAndInstalled,
  otherDownloads: otherDownloads,
  otherDownloadsDesc: otherDownloadsDesc
};

function toString(item) {
  if (typeof item !== "object") {
    if (item === "OtherVersionsSubmenu") {
      return "OtherVersionsSubmenu";
    } else {
      return "NoInstallations";
    }
  }
  switch (item.TAG) {
    case "Endpoint" :
        return "Endpoint: " + item._0 + ", " + Memento$AgdaModeVscode.Module.Endpoints.endpointToString(item._1.endpoint) + (
                item._2 ? ", selected" : ""
              );
    case "DownloadAction" :
        return "DownloadAction: downloaded=" + PervasivesU.string_of_bool(item._0) + ", versionString=" + item._1 + ", type=" + item._2;
    case "OpenFolder" :
        return "OpenFolder: " + item._0;
    case "Separator" :
        return "Separator: " + item._0;
    
  }
}

function shouldEndpointHaveIcon(endpoint) {
  if (typeof endpoint !== "object" || endpoint.TAG !== "Agda") {
    return false;
  } else {
    return true;
  }
}

function getEndpointDisplayInfo(filename, entry) {
  var match = entry.endpoint;
  var match$1 = entry.error;
  if (typeof match !== "object") {
    if (match$1 !== undefined) {
      return [
              "$(error) " + filename,
              "Error: " + match$1
            ];
    } else {
      return [
              "$(question) " + filename,
              "Unknown executable"
            ];
    }
  }
  if (match.TAG === "Agda") {
    var version = match._0;
    if (version !== undefined) {
      return [
              agdaVersionPrefix + version,
              undefined
            ];
    } else {
      return [
              "Agda (version unknown)",
              undefined
            ];
    }
  }
  var match$2 = match._0;
  if (match$2 !== undefined) {
    return [
            alsWithSquirrel + match$2[0] + ", " + agdaVersionPrefix + match$2[1],
            undefined
          ];
  } else {
    return [
            alsWithSquirrel + "(version unknown)",
            undefined
          ];
  }
}

function entriesToItemData(entries, pickedPath, downloadItems, folderPath) {
  var entriesArray = Object.entries(entries);
  var hasEndpoints = entriesArray.length > 0;
  var endpointItems = pickedPath !== undefined ? entriesArray.map(function (param) {
          var path = param[0];
          return {
                  TAG: "Endpoint",
                  _0: path,
                  _1: param[1],
                  _2: pickedPath === path
                };
        }) : entriesArray.map(function (param) {
          return {
                  TAG: "Endpoint",
                  _0: param[0],
                  _1: param[1],
                  _2: false
                };
        });
  var sectionsWithInstalled = hasEndpoints ? [{
          TAG: "Separator",
          _0: "Installed"
        }].concat(endpointItems) : ["NoInstallations"];
  var sectionsWithDownload;
  if (downloadItems.length > 0) {
    var devDownloads = downloadItems.filter(function (param) {
          return param[2] === "dev";
        });
    var otherDownloads = downloadItems.filter(function (param) {
          return param[2] !== "dev";
        });
    var downloadSectionItems = otherDownloads.map(function (param) {
            return {
                    TAG: "DownloadAction",
                    _0: param[0],
                    _1: param[1],
                    _2: param[2]
                  };
          }).concat(devDownloads.length > 0 ? ["OtherVersionsSubmenu"] : []);
    sectionsWithDownload = downloadSectionItems.length > 0 ? sectionsWithInstalled.concat([{
                TAG: "Separator",
                _0: "Download"
              }].concat(downloadSectionItems)) : sectionsWithInstalled;
  } else {
    sectionsWithDownload = sectionsWithInstalled;
  }
  return sectionsWithDownload.concat([
              {
                TAG: "Separator",
                _0: "Misc"
              },
              {
                TAG: "OpenFolder",
                _0: folderPath
              }
            ]);
}

var ItemData = {
  toString: toString,
  shouldEndpointHaveIcon: shouldEndpointHaveIcon,
  getEndpointDisplayInfo: getEndpointDisplayInfo,
  entriesToItemData: entriesToItemData
};

function createQuickPickItem(label, description, detail) {
  if (description !== undefined) {
    if (detail !== undefined) {
      return {
              description: description,
              detail: detail,
              label: label
            };
    } else {
      return {
              description: description,
              label: label
            };
    }
  } else if (detail !== undefined) {
    return {
            detail: detail,
            label: label
          };
  } else {
    return {
            label: label
          };
  }
}

function fromItemData(itemData, extensionUri) {
  var match;
  if (typeof itemData !== "object") {
    match = itemData === "OtherVersionsSubmenu" ? [
        otherDownloads,
        otherDownloadsDesc,
        undefined
      ] : [
        "$(info) No installations found",
        "Try installing Agda or ALS first",
        "No executable paths detected"
      ];
  } else {
    switch (itemData.TAG) {
      case "Endpoint" :
          var path = itemData._0;
          var filename = Nodepath.basename(path);
          var match$1 = getEndpointDisplayInfo(filename, itemData._1);
          var errorDescription = match$1[1];
          var description = itemData._2 ? (
              errorDescription !== undefined ? errorDescription : "Selected"
            ) : (
              errorDescription !== undefined ? errorDescription : ""
            );
          match = [
            match$1[0],
            description,
            path
          ];
          break;
      case "DownloadAction" :
          var label = itemData._2 === "dev" ? "$(cloud-download)  Download the dev Agda Language Server" : downloadLatestALS;
          var description$1 = itemData._0 ? downloadedAndInstalled : "";
          match = [
            label,
            description$1,
            itemData._1
          ];
          break;
      case "OpenFolder" :
          match = [
            openDownloadFolder,
            "Where the language servers are downloaded to",
            itemData._0
          ];
          break;
      case "Separator" :
          match = [
            itemData._0,
            undefined,
            undefined
          ];
          break;
      
    }
  }
  var detail = match[2];
  var description$2 = match[1];
  var label$1 = match[0];
  if (typeof itemData !== "object") {
    return createQuickPickItem(label$1, description$2, detail);
  }
  switch (itemData.TAG) {
    case "Endpoint" :
        var baseItem = createQuickPickItem(label$1, description$2, detail);
        if (!shouldEndpointHaveIcon(itemData._1.endpoint)) {
          return baseItem;
        }
        var newrecord = Caml_obj.obj_dup(baseItem);
        newrecord.iconPath = {
          dark: Vscode.Uri.joinPath(extensionUri, "asset/dark.png"),
          light: Vscode.Uri.joinPath(extensionUri, "asset/light.png")
        };
        return newrecord;
    case "Separator" :
        return {
                kind: -1,
                label: label$1
              };
    default:
      return createQuickPickItem(label$1, description$2, detail);
  }
}

function fromItemDataArray(itemDataArray, extensionUri) {
  return itemDataArray.map(function (itemData) {
              return fromItemData(itemData, extensionUri);
            });
}

var Item = {
  createQuickPickItem: createQuickPickItem,
  fromItemData: fromItemData,
  fromItemDataArray: fromItemDataArray
};

function make(log) {
  return {
          log: log,
          quickPick: Vscode.window.createQuickPick(),
          subscriptions: [],
          items: []
        };
}

function setPlaceholder(self, placeholder) {
  self.quickPick.placeholder = placeholder;
}

function updateItems(self, items) {
  self.items = items;
  self.quickPick.items = items;
}

function show(self) {
  self.quickPick.show();
}

function onSelection(self, handler) {
  Util$AgdaModeVscode.Disposable.add(self.quickPick.onDidChangeSelection(handler), self.subscriptions);
}

function onHide(self, handler) {
  Util$AgdaModeVscode.Disposable.add(self.quickPick.onDidHide(handler), self.subscriptions);
}

function destroy(self) {
  self.quickPick.dispose();
  self.subscriptions.forEach(function (sub) {
        sub.dispose();
      });
  Chan$AgdaModeVscode.emit(self.log, {
        TAG: "SwitchVersionUI",
        _0: "Destroyed"
      });
}

var View = {
  make: make,
  setPlaceholder: setPlaceholder,
  updateItems: updateItems,
  show: show,
  onSelection: onSelection,
  onHide: onHide,
  destroy: destroy
};

function formatAgdaVersion(version) {
  return "Agda v" + version;
}

function formatALSVersion(alsVersion, agdaVersion) {
  return "Agda v" + agdaVersion + " Language Server v" + alsVersion;
}

function formatSwitchingMessage(version) {
  return "Switching to " + version;
}

function formatSwitchedMessage(version) {
  return "Switched to " + version;
}

var VersionDisplay = {
  formatAgdaVersion: formatAgdaVersion,
  formatALSVersion: formatALSVersion,
  formatSwitchingMessage: formatSwitchingMessage,
  formatSwitchedMessage: formatSwitchedMessage
};

function make$1(state) {
  return {
          entries: Memento$AgdaModeVscode.Module.Endpoints.entries(state.memento),
          memento: state.memento,
          globalStorageUri: state.globalStorageUri
        };
}

async function getItemData(self, state, downloadItems) {
  var storedPath = Memento$AgdaModeVscode.Module.PickedConnection.get(self.memento);
  var pickedPath;
  if (storedPath !== undefined) {
    pickedPath = storedPath.startsWith("file://") ? Vscode.Uri.parse(storedPath).fsPath : storedPath;
  } else {
    var connection = state.connection;
    pickedPath = connection !== undefined ? connection._1 : undefined;
  }
  var folderPath = self.globalStorageUri.fsPath;
  return entriesToItemData(self.entries, pickedPath, downloadItems, folderPath);
}

function refreshFromMemento(self) {
  var newEntries = Memento$AgdaModeVscode.Module.Endpoints.entries(self.memento);
  var changed = newEntries !== self.entries;
  if (changed) {
    self.entries = newEntries;
  }
  return changed;
}

function inferEndpointType(filename) {
  var baseName = Nodepath.basename(filename.toLowerCase());
  var cleanName = baseName.replace(".exe", "").replace(".cmd", "").replace(".bat", "");
  if (cleanName === "agda" || cleanName.startsWith("agda-")) {
    return {
            TAG: "Agda",
            _0: undefined
          };
  } else if (cleanName === "als" || cleanName.startsWith("als-")) {
    return {
            TAG: "ALS",
            _0: undefined
          };
  } else {
    return "Unknown";
  }
}

async function syncWithFilesystem(self, platformDeps) {
  var endpoints = {};
  Config$AgdaModeVscode.Connection.getAgdaPaths().forEach(function (path) {
        var filename = Nodepath.basename(path);
        var endpoint = inferEndpointType(filename);
        endpoints[path] = endpoint;
      });
  var path = await platformDeps.findCommand("agda", undefined);
  if (path.TAG === "Ok") {
    endpoints[path._0] = {
      TAG: "Agda",
      _0: undefined
    };
  }
  var path$1 = await platformDeps.findCommand("als", undefined);
  if (path$1.TAG === "Ok") {
    endpoints[path$1._0] = {
      TAG: "ALS",
      _0: undefined
    };
  }
  await Memento$AgdaModeVscode.Module.Endpoints.syncWithPaths(self.memento, endpoints);
  return refreshFromMemento(self);
}

async function probeVersions(self) {
  var pathsToProbe = Core__Array.filterMap(Object.entries(self.entries), (function (param) {
          var match = param[1].endpoint;
          if (typeof match !== "object") {
            return ;
          }
          match.TAG === "Agda";
          if (match._0 !== undefined) {
            return ;
          } else {
            return param[0];
          }
        }));
  if (pathsToProbe.length === 0) {
    return false;
  }
  var probePromises = pathsToProbe.map(async function (path) {
        var error = await Connection$AgdaModeVscode.probeFilepath(path);
        if (error.TAG === "Ok") {
          var agdaVersion = error._0[1];
          switch (agdaVersion.TAG) {
            case "IsAgda" :
                await Memento$AgdaModeVscode.Module.Endpoints.setVersion(self.memento, path, {
                      TAG: "Agda",
                      _0: agdaVersion._0
                    });
                return path;
            case "IsALS" :
                await Memento$AgdaModeVscode.Module.Endpoints.setVersion(self.memento, path, {
                      TAG: "ALS",
                      _0: [
                        agdaVersion._0,
                        agdaVersion._1,
                        agdaVersion._2
                      ]
                    });
                return path;
            case "IsALSOfUnknownVersion" :
                await Memento$AgdaModeVscode.Module.Endpoints.setVersion(self.memento, path, {
                      TAG: "ALS",
                      _0: undefined
                    });
                return path;
            
          }
        } else {
          await Memento$AgdaModeVscode.Module.Endpoints.setError(self.memento, path, Connection__Error$AgdaModeVscode.Probe.toString(error._0));
          return path;
        }
      });
  var updateResults = await Promise.all(probePromises);
  var updatedPaths = Core__Array.filterMap(updateResults, (function (x) {
          return x;
        }));
  if (updatedPaths.length > 0) {
    refreshFromMemento(self);
    return true;
  } else {
    return false;
  }
}

var SwitchVersionManager = {
  make: make$1,
  getItemData: getItemData,
  refreshFromMemento: refreshFromMemento,
  inferEndpointType: inferEndpointType,
  syncWithFilesystem: syncWithFilesystem,
  probeVersions: probeVersions
};

async function getDownloadDescriptorWithPlatform(platformOps, target, useCache, memento, globalStorageUri) {
  var _error = await platformOps.determinePlatform();
  if (_error.TAG === "Ok") {
    return await platformOps.getDownloadDescriptor(target, useCache)(memento, globalStorageUri, _error._0);
  } else {
    return {
            TAG: "Error",
            _0: "CannotFindCompatibleALSRelease"
          };
  }
}

async function switchAgdaVersion(state, uri) {
  var path;
  path = uri.TAG === "FileURI" ? uri._1.fsPath : uri._0;
  await State__View$AgdaModeVscode.Panel.displayStatus(state, "");
  await State__View$AgdaModeVscode.Panel.display(state, {
        TAG: "Plain",
        _0: "Switching connection..."
      }, []);
  var conn = await Connection$AgdaModeVscode.make(path);
  if (conn.TAG === "Ok") {
    var conn$1 = conn._0;
    await Connection$AgdaModeVscode.destroy(state.connection, state.channels.log);
    state.connection = conn$1;
    await Memento$AgdaModeVscode.Module.PickedConnection.set(state.memento, path);
    await Config$AgdaModeVscode.Connection.addAgdaPath(state.channels.log, path);
    if (conn$1.TAG === "Agda") {
      var version = conn$1._2;
      await Memento$AgdaModeVscode.Module.Endpoints.setVersion(state.memento, path, {
            TAG: "Agda",
            _0: version
          });
      var formattedVersion = "Agda v" + version;
      await State__View$AgdaModeVscode.Panel.displayStatus(state, formattedVersion);
      return await State__View$AgdaModeVscode.Panel.display(state, {
                  TAG: "Success",
                  _0: "Switched to " + formattedVersion
                }, []);
    }
    var match = conn$1._2;
    if (match !== undefined) {
      var agdaVersion = match[1];
      var alsVersion = match[0];
      await Memento$AgdaModeVscode.Module.Endpoints.setVersion(state.memento, path, {
            TAG: "ALS",
            _0: [
              alsVersion,
              agdaVersion,
              match[2]
            ]
          });
      var formattedVersion$1 = formatALSVersion(alsVersion, agdaVersion);
      await State__View$AgdaModeVscode.Panel.displayStatus(state, formattedVersion$1);
      return await State__View$AgdaModeVscode.Panel.display(state, {
                  TAG: "Success",
                  _0: "Switched to " + formattedVersion$1
                }, []);
    }
    var formattedVersion$2 = "Agda Language Server of unknown version";
    await State__View$AgdaModeVscode.Panel.displayStatus(state, formattedVersion$2);
    return await State__View$AgdaModeVscode.Panel.display(state, {
                TAG: "Success",
                _0: "Switched to " + formattedVersion$2
              }, []);
  }
  var match$1 = Connection__Error$AgdaModeVscode.toString({
        TAG: "Establish",
        _0: conn._0
      });
  var header = {
    TAG: "Error",
    _0: "Failed to switch to a different installation: " + match$1[0]
  };
  var body = [Item$AgdaModeVscode.plainText(match$1[1])];
  return await State__View$AgdaModeVscode.Panel.display(state, header, body);
}

async function getAvailableLatestDownload(state, platformDeps) {
  var downloadDescriptor = await getDownloadDescriptorWithPlatform(platformDeps, "LatestALS", true, state.memento, state.globalStorageUri);
  if (downloadDescriptor.TAG !== "Ok") {
    return ;
  }
  var downloadDescriptor$1 = downloadDescriptor._0;
  var filepath = Vscode.Uri.joinPath(state.globalStorageUri, downloadDescriptor$1.saveAsFileName, "als");
  var match = await platformDeps.alreadyDownloaded(filepath, "LatestALS");
  var downloaded = match !== undefined;
  var getAgdaVersion = function (asset) {
    return asset.name.replace(/als-Agda-/, "").replace(/-.*/, "");
  };
  var agdaVersion = getAgdaVersion(downloadDescriptor$1.asset);
  var alsVersion = Core__Option.getOr(Core__Array.last(downloadDescriptor$1.release.name.split(".")), downloadDescriptor$1.release.name);
  var versionString = formatALSVersion(alsVersion, agdaVersion);
  return [
          downloaded,
          versionString,
          "latest"
        ];
}

async function getAvailableDevDownload(state, platformDeps) {
  var _error = await getDownloadDescriptorWithPlatform(platformDeps, "DevALS", false, state.memento, state.globalStorageUri);
  if (_error.TAG !== "Ok") {
    return ;
  }
  var downloadDescriptor = _error._0;
  var match = await platformDeps.alreadyDownloaded(state.globalStorageUri, "DevALS");
  var downloaded = match !== undefined;
  var getAgdaVersion = function (asset) {
    return asset.name.replace(/als-dev-Agda-/, "").replace(/-.*/, "");
  };
  var agdaVersion = getAgdaVersion(downloadDescriptor.asset);
  var alsVersion = downloadDescriptor.release.name;
  var versionString = formatALSVersion(alsVersion, agdaVersion);
  return [
          downloaded,
          versionString,
          "dev"
        ];
}

async function getAllAvailableDownloads(state, platformDeps) {
  var latestPromise = getAvailableLatestDownload(state, platformDeps);
  var devPromise = Config$AgdaModeVscode.DevMode.get() ? getAvailableDevDownload(state, platformDeps) : Promise.resolve(undefined);
  var results = await Promise.all([
        latestPromise,
        devPromise
      ]);
  return Core__Array.filterMap(results, (function (x) {
                return x;
              }));
}

var Download = {
  getAvailableLatestDownload: getAvailableLatestDownload,
  getAvailableDevDownload: getAvailableDevDownload,
  getAllAvailableDownloads: getAllAvailableDownloads
};

async function showOtherVersionsSubmenu(state, platformDeps) {
  var submenuView = make(state.channels.log);
  var devDownloadInfo = await getAvailableDevDownload(state, platformDeps);
  var devItems;
  if (devDownloadInfo !== undefined) {
    var description = devDownloadInfo[0] ? downloadedAndInstalled : "";
    devItems = [createQuickPickItem("$(cloud-download)  Download dev ALS", description, devDownloadInfo[1])];
  } else {
    devItems = [];
  }
  var wasmItem = createQuickPickItem("$(cloud-download)  Download WASM build", "Universal WebAssembly build", "WASM dev");
  var wasmItems = [wasmItem];
  var allItems = devItems.concat(wasmItems);
  var submenuItems = allItems.length === 0 ? [createQuickPickItem("$(info)  No dev downloads available", "Dev downloads not available", undefined)] : allItems;
  setPlaceholder(submenuView, otherDownloadsDesc);
  updateItems(submenuView, submenuItems);
  submenuView.quickPick.show();
  onSelection(submenuView, (function (selectedItems) {
          destroy(submenuView);
          ((async function () {
                  var selectedItem = selectedItems[0];
                  if (selectedItem === undefined) {
                    return Chan$AgdaModeVscode.emit(state.channels.log, {
                                TAG: "SwitchVersionUI",
                                _0: "SelectionCompleted"
                              });
                  }
                  if (!selectedItem.label.startsWith("$(cloud-download)")) {
                    return ;
                  }
                  if (selectedItem.label.includes("WASM")) {
                    Vscode.window.showInformationMessage("WASM download not yet implemented");
                    return Chan$AgdaModeVscode.emit(state.channels.log, {
                                TAG: "SwitchVersionUI",
                                _0: "SelectionCompleted"
                              });
                  }
                  if (devDownloadInfo !== undefined) {
                    var versionString = devDownloadInfo[1];
                    var downloaded = devDownloadInfo[0];
                    Chan$AgdaModeVscode.emit(state.channels.log, {
                          TAG: "SwitchVersionUI",
                          _0: {
                            TAG: "SelectedDownloadAction",
                            _0: downloaded,
                            _1: versionString
                          }
                        });
                    if (downloaded) {
                      var downloadDescriptor = await getDownloadDescriptorWithPlatform(platformDeps, "DevALS", false, state.memento, state.globalStorageUri);
                      if (downloadDescriptor.TAG === "Ok") {
                        var downloadedPath = Vscode.Uri.joinPath(state.globalStorageUri, downloadDescriptor._0.saveAsFileName, "als").fsPath;
                        await Config$AgdaModeVscode.Connection.addAgdaPath(state.channels.log, downloadedPath);
                      }
                      Vscode.window.showInformationMessage(versionString + " is already downloaded");
                    } else {
                      var error = await getDownloadDescriptorWithPlatform(platformDeps, "DevALS", false, state.memento, state.globalStorageUri);
                      var downloadResult;
                      downloadResult = error.TAG === "Ok" ? await platformDeps.download(state.globalStorageUri, error._0) : ({
                            TAG: "Error",
                            _0: error._0
                          });
                      if (downloadResult.TAG === "Ok") {
                        await Config$AgdaModeVscode.Connection.addAgdaPath(state.channels.log, downloadResult._0);
                        Vscode.window.showInformationMessage(versionString + " successfully downloaded");
                      } else {
                        Vscode.window.showErrorMessage(Connection__Download$AgdaModeVscode.$$Error.toString(downloadResult._0));
                      }
                    }
                    return Chan$AgdaModeVscode.emit(state.channels.log, {
                                TAG: "SwitchVersionUI",
                                _0: "SelectionCompleted"
                              });
                  }
                  Vscode.window.showErrorMessage("Download not available for this platform");
                  return Chan$AgdaModeVscode.emit(state.channels.log, {
                              TAG: "SwitchVersionUI",
                              _0: "SelectionCompleted"
                            });
                })());
        }));
  return onHide(submenuView, (function () {
                destroy(submenuView);
              }));
}

function onSelection$1(state, platformDeps, manager, updateUI, view, selectedItems) {
  destroy(view);
  ((async function () {
          var selectedItem = selectedItems[0];
          if (selectedItem === undefined) {
            return Chan$AgdaModeVscode.emit(state.channels.log, {
                        TAG: "SwitchVersionUI",
                        _0: "SelectionCompleted"
                      });
          }
          if (selectedItem.label === otherDownloads) {
            return await showOtherVersionsSubmenu(state, platformDeps);
          }
          if (selectedItem.label === openDownloadFolder) {
            var globalStorageUriAsFile = Vscode.Uri.file(state.globalStorageUri.fsPath);
            Chan$AgdaModeVscode.emit(state.channels.log, {
                  TAG: "SwitchVersionUI",
                  _0: {
                    TAG: "SelectedOpenFolder",
                    _0: state.globalStorageUri.fsPath
                  }
                });
            await platformDeps.openFolder(globalStorageUriAsFile);
            return Chan$AgdaModeVscode.emit(state.channels.log, {
                        TAG: "SwitchVersionUI",
                        _0: "SelectionCompleted"
                      });
          }
          if (selectedItem.label === downloadLatestALS) {
            var downloadInfoResult = await getAvailableLatestDownload(state, platformDeps);
            if (downloadInfoResult !== undefined) {
              var versionString = downloadInfoResult[1];
              var downloaded = downloadInfoResult[0];
              Chan$AgdaModeVscode.emit(state.channels.log, {
                    TAG: "SwitchVersionUI",
                    _0: {
                      TAG: "SelectedDownloadAction",
                      _0: downloaded,
                      _1: versionString
                    }
                  });
              if (downloaded) {
                var downloadDescriptor = await getDownloadDescriptorWithPlatform(platformDeps, "LatestALS", true, state.memento, state.globalStorageUri);
                if (downloadDescriptor.TAG === "Ok") {
                  var downloadedPath = Vscode.Uri.joinPath(state.globalStorageUri, downloadDescriptor._0.saveAsFileName, "als").fsPath;
                  await Config$AgdaModeVscode.Connection.addAgdaPath(state.channels.log, downloadedPath);
                }
                Vscode.window.showInformationMessage(versionString + " is already downloaded");
                return Chan$AgdaModeVscode.emit(state.channels.log, {
                            TAG: "SwitchVersionUI",
                            _0: "SelectionCompleted"
                          });
              }
              var error = await getDownloadDescriptorWithPlatform(platformDeps, "LatestALS", true, state.memento, state.globalStorageUri);
              var downloadResult;
              downloadResult = error.TAG === "Ok" ? await platformDeps.download(state.globalStorageUri, error._0) : ({
                    TAG: "Error",
                    _0: error._0
                  });
              if (downloadResult.TAG === "Ok") {
                await Config$AgdaModeVscode.Connection.addAgdaPath(state.channels.log, downloadResult._0);
                var newDownloadItems = await getAllAvailableDownloads(state, platformDeps);
                refreshFromMemento(manager);
                await updateUI(newDownloadItems);
                Vscode.window.showInformationMessage(versionString + " successfully downloaded");
                return Chan$AgdaModeVscode.emit(state.channels.log, {
                            TAG: "SwitchVersionUI",
                            _0: "SelectionCompleted"
                          });
              }
              Vscode.window.showErrorMessage(Connection__Download$AgdaModeVscode.$$Error.toString(downloadResult._0));
              return Chan$AgdaModeVscode.emit(state.channels.log, {
                          TAG: "SwitchVersionUI",
                          _0: "SelectionCompleted"
                        });
            }
            await Vscode.window.showErrorMessage("Download not available for this platform");
            return Chan$AgdaModeVscode.emit(state.channels.log, {
                        TAG: "SwitchVersionUI",
                        _0: "SelectionCompleted"
                      });
          }
          var selectedPath = selectedItem.detail;
          if (selectedPath === undefined) {
            return Chan$AgdaModeVscode.emit(state.channels.log, {
                        TAG: "SwitchVersionUI",
                        _0: "SelectionCompleted"
                      });
          }
          var path = Memento$AgdaModeVscode.Module.PickedConnection.get(manager.memento);
          var changed = path !== undefined ? selectedPath !== path : true;
          if (!changed) {
            return Chan$AgdaModeVscode.emit(state.channels.log, {
                        TAG: "SwitchVersionUI",
                        _0: "SelectionCompleted"
                      });
          }
          var entry = manager.entries[selectedPath];
          if (entry !== undefined) {
            Chan$AgdaModeVscode.emit(state.channels.log, {
                  TAG: "SwitchVersionUI",
                  _0: {
                    TAG: "SelectedEndpoint",
                    _0: selectedPath,
                    _1: entry,
                    _2: true
                  }
                });
          }
          var uri = Connection__URI$AgdaModeVscode.parse(selectedPath);
          await switchAgdaVersion(state, uri);
          return Chan$AgdaModeVscode.emit(state.channels.log, {
                      TAG: "SwitchVersionUI",
                      _0: "SelectionCompleted"
                    });
        })());
}

function onHide$1(view) {
  destroy(view);
}

async function onActivate(state, platformDeps) {
  var manager = make$1(state);
  var view = make(state.channels.log);
  var updateUI = async function (downloadItems) {
    var itemData = await getItemData(manager, state, downloadItems);
    var endpointItemDatas = Core__Array.filterMap(itemData, (function (item) {
            if (typeof item !== "object") {
              return ;
            }
            if (item.TAG !== "Endpoint") {
              return ;
            }
            var entry = item._1;
            return [
                    item._0,
                    entry.endpoint,
                    entry.error,
                    item._2
                  ];
          }));
    Chan$AgdaModeVscode.emit(state.channels.log, {
          TAG: "SwitchVersionUI",
          _0: {
            TAG: "UpdatedEndpoints",
            _0: endpointItemDatas
          }
        });
    var items = fromItemDataArray(itemData, state.extensionUri);
    return updateItems(view, items);
  };
  setPlaceholder(view, "Switch Agda Version");
  await updateUI([]);
  view.quickPick.show();
  Chan$AgdaModeVscode.emit(state.channels.log, {
        TAG: "SwitchVersionUI",
        _0: {
          TAG: "Others",
          _0: "QuickPick shown"
        }
      });
  var downloadItemsPromise = getAllAvailableDownloads(state, platformDeps);
  onSelection(view, (function (selectedItems) {
          onSelection$1(state, platformDeps, manager, updateUI, view, selectedItems);
        }));
  onHide(view, (function () {
          destroy(view);
        }));
  var backgroundUpdate = async function () {
    try {
      var downloadItems = await downloadItemsPromise;
      var phase2Changed = await syncWithFilesystem(manager, platformDeps);
      if (phase2Changed) {
        await updateUI(downloadItems);
      }
      var phase3Changed = await probeVersions(manager);
      if (phase3Changed) {
        await updateUI(downloadItems);
      }
      if (!phase2Changed && !phase3Changed) {
        return await updateUI(downloadItems);
      } else {
        return ;
      }
    }
    catch (_exn){
      return ;
    }
  };
  backgroundUpdate();
}

var Handler = {
  showOtherVersionsSubmenu: showOtherVersionsSubmenu,
  onSelection: onSelection$1,
  onHide: onHide$1,
  onActivate: onActivate
};

var activate = onActivate;

exports.Constants = Constants;
exports.ItemData = ItemData;
exports.Item = Item;
exports.View = View;
exports.VersionDisplay = VersionDisplay;
exports.SwitchVersionManager = SwitchVersionManager;
exports.getDownloadDescriptorWithPlatform = getDownloadDescriptorWithPlatform;
exports.switchAgdaVersion = switchAgdaVersion;
exports.Download = Download;
exports.Handler = Handler;
exports.activate = activate;
/* vscode Not a pure module */
