// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Vscode = require("vscode");
var Core__Option = require("@rescript/core/lib/js/src/Core__Option.bs.js");
var IM$AgdaModeVscode = require("../InputMethod/IM.bs.js");
var Chan$AgdaModeVscode = require("../Util/Chan.bs.js");
var Goals$AgdaModeVscode = require("../Goals.bs.js");
var Tokens$AgdaModeVscode = require("../Tokens.bs.js");
var Command$AgdaModeVscode = require("../Command.bs.js");
var Memento$AgdaModeVscode = require("../Memento.bs.js");
var Request$AgdaModeVscode = require("../Request.bs.js");
var Response$AgdaModeVscode = require("../Response.bs.js");
var Connection$AgdaModeVscode = require("../Connection/Connection.bs.js");
var WebviewPanel$AgdaModeVscode = require("../View/WebviewPanel.bs.js");

function make() {
  return {
          display: undefined,
          prompt: undefined
        };
}

function cacheEvent(self, $$event) {
  if (typeof $$event !== "object" || $$event.TAG !== "Display") {
    return ;
  } else {
    self.display = [
      $$event._0,
      $$event._1
    ];
    return ;
  }
}

function cacheRequest(self, $$event, callback) {
  self.prompt = [
    $$event._0,
    $$event._1,
    callback
  ];
}

function clearPrompt(self) {
  self.prompt = undefined;
}

function restore(self, view) {
  var match = self.prompt;
  if (match !== undefined) {
    WebviewPanel$AgdaModeVscode.sendRequest(view, {
          TAG: "Prompt",
          _0: match[0],
          _1: match[1]
        }, match[2]);
    return ;
  } else {
    return Core__Option.forEach(self.display, (function (param) {
                  WebviewPanel$AgdaModeVscode.sendEvent(view, {
                        TAG: "Display",
                        _0: param[0],
                        _1: param[1]
                      });
                }));
  }
}

var ViewCache = {
  make: make,
  cacheEvent: cacheEvent,
  cacheRequest: cacheRequest,
  clearPrompt: clearPrompt,
  restore: restore
};

function toString($$event) {
  if (typeof $$event !== "object") {
    return "Destroyed";
  } else if ($$event.TAG === "UpdatedEndpoints") {
    return "UpdatedEndpoints: " + $$event._0.map(function (param) {
                  var error = param[2];
                  var endpoint = param[1];
                  var tmp;
                  if (typeof endpoint !== "object") {
                    tmp = "Unknown";
                  } else if (endpoint.TAG === "Agda") {
                    var version = endpoint._0;
                    tmp = version !== undefined ? "Agda(" + version + ")" : "Agda(None)";
                  } else {
                    var match = endpoint._0;
                    tmp = match !== undefined ? "ALS(" + match[0] + ", " + match[1] + ")" : "ALS(None)";
                  }
                  return param[0] + ": " + tmp + (
                          error !== undefined ? " [Error: " + error + "]" : ""
                        ) + (
                          param[3] ? " [Selected]" : ""
                        );
                }).join("\n");
  } else {
    return $$event._0;
  }
}

var SwitchVersion = {
  toString: toString
};

function toString$1(log) {
  switch (log.TAG) {
    case "CommandDispatched" :
        return " <=== " + Command$AgdaModeVscode.toString(log._0);
    case "CommandHandled" :
        return " ===> " + Command$AgdaModeVscode.toString(log._0);
    case "RequestSent" :
        return "   <- " + Request$AgdaModeVscode.toString(log._0);
    case "ResponseHandled" :
        return "    > " + Response$AgdaModeVscode.toString(log._0);
    case "RegistryLookup" :
        return "Registry lookup: " + log._0 + " " + (
                log._1 ? "found" : "not found"
              );
    case "RegistryAdd" :
        return "Registry add: " + log._0;
    case "RegistryRemove" :
        return "Registry remove: " + log._0;
    case "ParserFilepath" :
        return "Parser.filepath: " + log._0 + " -> " + log._1;
    case "TokensReset" :
        return "Tokens reset: " + log._0;
    case "AgdaModeOperation" :
        return "AgdaMode." + log._0 + ": " + log._1;
    case "SwitchVersionUI" :
        return "SwitchVersionUI: " + toString(log._0);
    case "Others" :
        return log._0;
    
  }
}

var Log = {
  SwitchVersion: SwitchVersion,
  toString: toString$1
};

function make$1(platformDeps, channels, globalStorageUri, extensionUri, memento, editor, semanticTokens) {
  return {
          platformDeps: platformDeps,
          connection: undefined,
          agdaVersion: undefined,
          editor: editor,
          document: editor.document,
          panelCache: {
            display: undefined,
            prompt: undefined
          },
          runningInfoLog: [],
          tokens: Tokens$AgdaModeVscode.make(semanticTokens),
          goals: Goals$AgdaModeVscode.make(),
          cursor: undefined,
          editorIM: IM$AgdaModeVscode.make(channels.inputMethod),
          promptIM: IM$AgdaModeVscode.make(channels.inputMethod),
          subscriptions: [],
          onRemoveFromRegistry: Chan$AgdaModeVscode.make(),
          globalStorageUri: globalStorageUri,
          extensionUri: extensionUri,
          memento: Memento$AgdaModeVscode.make(memento),
          channels: channels,
          isInRefineOrGiveOperation: false
        };
}

async function destroy(state, alsoRemoveFromRegistry) {
  Chan$AgdaModeVscode.emit(state.channels.log, {
        TAG: "Others",
        _0: "State.destroy: Starting destruction"
      });
  await Goals$AgdaModeVscode.waitUntilNotBusy(state.goals);
  Chan$AgdaModeVscode.emit(state.channels.log, {
        TAG: "Others",
        _0: "State.destroy: Goals are not busy"
      });
  if (alsoRemoveFromRegistry) {
    Chan$AgdaModeVscode.emit(state.channels.log, {
          TAG: "Others",
          _0: "State.destroy: Emitting remove from registry"
        });
    Chan$AgdaModeVscode.emit(state.onRemoveFromRegistry, undefined);
  }
  Chan$AgdaModeVscode.destroy(state.onRemoveFromRegistry);
  Chan$AgdaModeVscode.emit(state.channels.log, {
        TAG: "Others",
        _0: "State.destroy: Destroyed onRemoveFromRegistry channel"
      });
  Goals$AgdaModeVscode.destroy(state.goals);
  Chan$AgdaModeVscode.emit(state.channels.log, {
        TAG: "Others",
        _0: "State.destroy: Destroyed goals"
      });
  state.subscriptions.forEach(function (prim) {
        return prim.dispose();
      });
  Chan$AgdaModeVscode.emit(state.channels.log, {
        TAG: "Others",
        _0: "State.destroy: Disposed subscriptions"
      });
  Chan$AgdaModeVscode.emit(state.channels.log, {
        TAG: "TokensReset",
        _0: "State.destroy"
      });
  Tokens$AgdaModeVscode.reset(state.tokens);
  Chan$AgdaModeVscode.emit(state.channels.log, {
        TAG: "Others",
        _0: "State.destroy: Tokens reset completed"
      });
  var result = await Connection$AgdaModeVscode.destroy(state.connection);
  Chan$AgdaModeVscode.emit(state.channels.log, {
        TAG: "Others",
        _0: "State.destroy: Connection destroyed, destruction complete"
      });
  return result;
}

function setPrompt(value) {
  Vscode.commands.executeCommand("setContext", "agdaModePrompting", value);
}

function setIM(value) {
  Vscode.commands.executeCommand("setContext", "agdaModeTyping", value);
}

var Context = {
  setPrompt: setPrompt,
  setIM: setIM
};

exports.ViewCache = ViewCache;
exports.Log = Log;
exports.make = make$1;
exports.destroy = destroy;
exports.Context = Context;
/* vscode Not a pure module */
