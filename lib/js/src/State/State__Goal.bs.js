// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Caml = require("rescript/lib/js/caml.js");
var Vscode = require("vscode");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Core__Array = require("@rescript/core/lib/js/src/Core__Array.bs.js");
var Core__Option = require("@rescript/core/lib/js/src/Core__Option.bs.js");
var Goal$AgdaModeVscode = require("../Goal.bs.js");
var Item$AgdaModeVscode = require("../View/Component/Item.bs.js");
var Util$AgdaModeVscode = require("../Util/Util.bs.js");
var Common$AgdaModeVscode = require("../View/Common.bs.js");
var Editor$AgdaModeVscode = require("../Editor.bs.js");
var Parser$AgdaModeVscode = require("../Parser/Parser.bs.js");
var Tokens$AgdaModeVscode = require("../Tokens.bs.js");
var State__View$AgdaModeVscode = require("./State__View.bs.js");
var Highlighting$AgdaModeVscode = require("../Highlighting.bs.js");

function getOffsets(state) {
  return state.goals.map(function (goal) {
              var match = goal.interval;
              var from = match[0];
              return from + Caml.int_min(3, (match[1] - from | 0) / 2 | 0) | 0;
            });
}

function caseSplitAux($$document, goal) {
  var interval_1 = goal.interval[0];
  var interval = [
    0,
    interval_1
  ];
  var range = Common$AgdaModeVscode.Interval.toVSCodeRange($$document, interval);
  var textBeforeGoal = Editor$AgdaModeVscode.$$Text.get($$document, range);
  var nextWordBoundary = function (start, string) {
    var $$break = false;
    var n = 0;
    var i = start;
    while(i < string.length && !$$break) {
      var $$char = string.charAt(i);
      switch ($$char) {
        case "	" :
        case "" :
        case " " :
            n = n + 1 | 0;
            break;
        default:
          $$break = true;
      }
      i = i + 1 | 0;
    };
    return start + n | 0;
  };
  var bracketCount = 0;
  var i = goal.interval[0] - 1 | 0;
  while(i >= 0 && bracketCount >= 0) {
    var i$p = i;
    if (i$p !== 0) {
      var match = textBeforeGoal.charAt(i$p - 1 | 0);
      switch (match) {
        case "{" :
            bracketCount = bracketCount - 1 | 0;
            break;
        case "}" :
            bracketCount = bracketCount + 1 | 0;
            break;
        default:
          
      }
    }
    i = i - 1 | 0;
  };
  var lastOpenCurlyBracketOffset = i + 1 | 0;
  var n = textBeforeGoal.lastIndexOf(";");
  var lastSemicolonOffset = (
    n !== -1 ? n : 0
  ) + 1 | 0;
  var n$1 = textBeforeGoal.lastIndexOf("where");
  var lastWhereTokenOffset = (
    n$1 !== -1 ? n$1 : 0
  ) + 5 | 0;
  var lastLineBreakOffset = Caml.int_max(0, Caml.int_max(textBeforeGoal.lastIndexOf("\r"), textBeforeGoal.lastIndexOf("\n"))) + 1 | 0;
  var inWhereClause = lastWhereTokenOffset > lastOpenCurlyBracketOffset;
  var offset = Caml.int_max(lastLineBreakOffset > lastSemicolonOffset ? lastLineBreakOffset : lastSemicolonOffset, lastWhereTokenOffset > lastOpenCurlyBracketOffset ? lastWhereTokenOffset : lastOpenCurlyBracketOffset);
  var caseStart = nextWordBoundary(offset, textBeforeGoal);
  var caseEnd = goal.interval[1];
  var range$1 = [
    caseStart,
    caseEnd
  ];
  return [
          inWhereClause,
          caseStart - lastLineBreakOffset | 0,
          range$1
        ];
}

function indentationWidth($$document, goal) {
  var goalStart = $$document.positionAt(goal.interval[0]);
  var lineNo = goalStart.line;
  var range = new Vscode.Range(new Vscode.Position(lineNo, 0), goalStart);
  var textBeforeGoal = Editor$AgdaModeVscode.$$Text.get($$document, range);
  var indentedBy = function (s) {
    var n = 0;
    for(var i = 0 ,i_finish = s.length; i < i_finish; ++i){
      var match = s.charAt(i);
      var exit = 0;
      switch (match) {
        case "	" :
        case "" :
        case " " :
        case "\n" :
            exit = 1;
            break;
        default:
          
      }
      if (exit === 1 && i === n) {
        n = n + 1 | 0;
      }
      
    }
    return n;
  };
  return [
          indentedBy(textBeforeGoal),
          textBeforeGoal,
          range
        ];
}

function jumpToOffset(state, offset) {
  var point = state.document.positionAt(offset);
  var range = new Vscode.Range(point, point);
  Editor$AgdaModeVscode.reveal(state.editor, range);
}

function updateIntervals(state) {
  var indices = state.goals.map(function (goal) {
        return goal.index;
      });
  var diffs = Goal$AgdaModeVscode.generateDiffs(state.document, indices);
  diffs.forEach(function (diff, i) {
        var goal = state.goals[i];
        if (goal !== undefined) {
          goal.interval = diff.modifiedInterval;
          return ;
        }
        
      });
}

async function modify(state, goal, f) {
  updateIntervals(state);
  var content = Goal$AgdaModeVscode.getContent(goal, state.document);
  if (await Goal$AgdaModeVscode.setContent(goal, state.document, f(content))) {
    return updateIntervals(state);
  } else {
    return await State__View$AgdaModeVscode.Panel.display(state, {
                TAG: "Error",
                _0: "Goal-related Error",
                [Symbol.for("name")]: "Error"
              }, [Item$AgdaModeVscode.plainText("Failed to modify the content of goal #" + String(goal.index))]);
  }
}

function next(state) {
  updateIntervals(state);
  var nextGoal = {
    contents: undefined
  };
  var cursorOffset = state.document.offsetAt(Editor$AgdaModeVscode.Cursor.get(state.editor));
  var offsets = getOffsets(state);
  offsets.forEach(function (offset) {
        if (cursorOffset < offset && nextGoal.contents === undefined) {
          nextGoal.contents = offset;
          return ;
        }
        
      });
  if (nextGoal.contents === undefined) {
    nextGoal.contents = offsets[0];
  }
  var offset = nextGoal.contents;
  if (offset === undefined) {
    return ;
  }
  var point = state.document.positionAt(offset);
  Editor$AgdaModeVscode.Cursor.set(state.editor, point);
  jumpToOffset(state, offset);
}

function previous(state) {
  updateIntervals(state);
  var previousGoal = {
    contents: undefined
  };
  var cursorOffset = state.document.offsetAt(Editor$AgdaModeVscode.Cursor.get(state.editor));
  var offsets = getOffsets(state);
  offsets.forEach(function (offset) {
        if (cursorOffset > offset) {
          previousGoal.contents = offset;
          return ;
        }
        
      });
  if (previousGoal.contents === undefined) {
    previousGoal.contents = offsets[offsets.length - 1 | 0];
  }
  var offset = previousGoal.contents;
  if (offset === undefined) {
    return ;
  }
  var point = state.document.positionAt(offset);
  Editor$AgdaModeVscode.Cursor.set(state.editor, point);
  jumpToOffset(state, offset);
}

async function rewriteQuestionMarks(state, editor) {
  var $$document = editor.document;
  var questionMarkTokens = Core__Array.filterMap(Array.from(Tokens$AgdaModeVscode.getHoles(state.tokens).values()), (function (param) {
          var range = param[2];
          var content = $$document.getText(Caml_option.some(range));
          if (content === "?") {
            return [
                    param[0],
                    [
                      range,
                      "{!   !}"
                    ]
                  ];
          }
          
        }));
  var rewrites = questionMarkTokens.map(function (prim) {
        return prim[1];
      });
  console.log("rewriting " + String(rewrites.length) + " question marks");
  await Editor$AgdaModeVscode.$$Text.batchReplace($$document, rewrites);
  console.log("destroyed tokens: " + Util$AgdaModeVscode.Pretty.array(questionMarkTokens.map(function (param) {
                return Tokens$AgdaModeVscode.Token.toString(param[0]);
              })));
  var revivedQuestionMarkTokens = Core__Array.reduce(questionMarkTokens, [
          [],
          0
        ], (function (param, param$1) {
            var token = param$1[0];
            var delta = param[1];
            return [
                    Belt_Array.concatMany([
                          param[0],
                          [{
                              start: token.start + delta | 0,
                              end_: (token.end_ + delta | 0) + 6 | 0,
                              aspects: token.aspects,
                              isTokenBased: token.isTokenBased,
                              note: token.note,
                              source: token.source
                            }]
                        ]),
                    delta + 6 | 0
                  ];
          }))[0];
  console.log("revived tokens: " + Util$AgdaModeVscode.Pretty.array(revivedQuestionMarkTokens.map(function (token) {
                return Tokens$AgdaModeVscode.Token.toString(token);
              })));
  return Tokens$AgdaModeVscode.insert(state.tokens, editor, revivedQuestionMarkTokens);
}

async function decorateHoles(state, editor, indices) {
  console.log("decorating " + String(indices.length) + " holes");
  console.log("holes: " + Util$AgdaModeVscode.Pretty.array(Tokens$AgdaModeVscode.getHolesSorted(state.tokens).map(function (param) {
                return Tokens$AgdaModeVscode.Token.toString(param[0]);
              })));
  return Belt_Array.zip(Tokens$AgdaModeVscode.getHolesSorted(state.tokens), indices).map(function (param) {
              var index = param[1];
              var match = param[0];
              var interval = match[1];
              console.log("decorating hole #" + String(index) + " " + Editor$AgdaModeVscode.$$Range.toString(match[2]));
              var match$1 = Highlighting$AgdaModeVscode.decorateHole(editor, interval, index);
              return {
                      index: index,
                      interval: interval,
                      decorationBackground: match$1[0],
                      decorationIndex: match$1[1]
                    };
            });
}

async function instantiate(state, indices) {
  state.goals.forEach(Goal$AgdaModeVscode.destroyDecoration);
  var selection = state.editor.selection;
  var cursorStart = state.document.offsetAt(selection.start);
  var cursorEnd = state.document.offsetAt(selection.end);
  await rewriteQuestionMarks(state, state.editor);
  var goals = await decorateHoles(state, state.editor, indices);
  goals.forEach(function (goal) {
        var match = goal.interval;
        var right = match[1];
        var left = match[0];
        var touched = left <= cursorStart && cursorStart <= (left + 2 | 0) || (right - 2 | 0) <= cursorStart && cursorStart <= right || left <= cursorEnd && cursorEnd <= (left + 2 | 0) || (right - 2 | 0) <= cursorEnd && cursorEnd <= right;
        if (touched) {
          return Goal$AgdaModeVscode.setCursor(goal, state.editor);
        }
        
      });
  state.goals = goals;
}

function pointed(state) {
  updateIntervals(state);
  var cursor = Editor$AgdaModeVscode.Cursor.get(state.editor);
  var cursorOffset = state.document.offsetAt(cursor);
  var pointedGoals = state.goals.filter(function (goal) {
        return Common$AgdaModeVscode.Interval.contains(goal.interval, cursorOffset);
      });
  return Core__Option.map(pointedGoals[0], (function (goal) {
                return [
                        goal,
                        Goal$AgdaModeVscode.getContent(goal, state.document)
                      ];
              }));
}

function placeCursorAtFirstNewGoal(state, rewriteText, rewriteRange) {
  var splittedLines = Parser$AgdaModeVscode.splitToLines(rewriteText);
  Core__Option.forEach(splittedLines[0], (function (line) {
          var col = line.length - 1 | 0;
          var lastChar = line.charAt(col);
          if (lastChar !== "?") {
            return ;
          }
          var position = rewriteRange.start.translate(0, col);
          Editor$AgdaModeVscode.Cursor.set(state.editor, position);
        }));
}

async function replaceWithLambda(state, goal, lines) {
  var match = caseSplitAux(state.document, goal);
  var indentWidth = match[1];
  var rewriteText = match[0] ? lines.join("\n" + " ".repeat(indentWidth)) : lines.join("\n" + (" ".repeat(indentWidth - 2 | 0) + "; "));
  var rewriteRange = Common$AgdaModeVscode.Interval.toVSCodeRange(state.document, match[2]);
  if (await Editor$AgdaModeVscode.$$Text.replace(state.document, rewriteRange, rewriteText)) {
    Goal$AgdaModeVscode.destroyDecoration(goal);
    return placeCursorAtFirstNewGoal(state, rewriteText, rewriteRange);
  } else {
    return await State__View$AgdaModeVscode.Panel.display(state, {
                TAG: "Error",
                _0: "Goal-related Error",
                [Symbol.for("name")]: "Error"
              }, [Item$AgdaModeVscode.plainText("Unable to replace the lines of goal #" + String(goal.index))]);
  }
}

async function replaceWithLines(state, goal, lines) {
  var match = indentationWidth(state.document, goal);
  var indentation = " ".repeat(match[0]);
  var indentedLines = indentation + lines.join("\n" + indentation);
  var start = state.document.positionAt(goal.interval[0]);
  var startLineNo = start.line;
  var startLineRange = state.document.lineAt(startLineNo).range;
  var start$1 = startLineRange.start;
  var end_ = state.document.positionAt(goal.interval[1]);
  var rangeToBeReplaced = new Vscode.Range(start$1, end_);
  if (await Editor$AgdaModeVscode.$$Text.replace(state.document, rangeToBeReplaced, indentedLines)) {
    Goal$AgdaModeVscode.destroyDecoration(goal);
    return placeCursorAtFirstNewGoal(state, indentedLines, rangeToBeReplaced);
  } else {
    return await State__View$AgdaModeVscode.Panel.display(state, {
                TAG: "Error",
                _0: "Goal-related Error",
                [Symbol.for("name")]: "Error"
              }, [Item$AgdaModeVscode.plainText("Unable to replace the lines of goal #" + String(goal.index))]);
  }
}

async function removeBoundaryAndDestroy(state, goal) {
  updateIntervals(state);
  var innerRange = Goal$AgdaModeVscode.getInnerRange(goal, state.document);
  var outerRange = Common$AgdaModeVscode.Interval.toVSCodeRange(state.document, goal.interval);
  var content = Editor$AgdaModeVscode.$$Text.get(state.document, innerRange).trim();
  if (await Editor$AgdaModeVscode.$$Text.replace(state.document, outerRange, content)) {
    return Goal$AgdaModeVscode.destroyDecoration(goal);
  } else {
    return await State__View$AgdaModeVscode.Panel.display(state, {
                TAG: "Error",
                _0: "Goal-related Error",
                [Symbol.for("name")]: "Error"
              }, [Item$AgdaModeVscode.plainText("Unable to remove the boundary of goal #" + String(goal.index))]);
  }
}

function redecorate(state) {
  updateIntervals(state);
  state.goals.forEach(function (goal) {
        Goal$AgdaModeVscode.refreshDecoration(goal, state.editor);
      });
}

var Module = {
  instantiate: instantiate,
  modify: modify,
  removeBoundaryAndDestroy: removeBoundaryAndDestroy,
  pointed: pointed,
  replaceWithLines: replaceWithLines,
  replaceWithLambda: replaceWithLambda,
  indentationWidth: indentationWidth,
  caseSplitAux: caseSplitAux,
  redecorate: redecorate,
  next: next,
  previous: previous
};

exports.Module = Module;
exports.instantiate = instantiate;
exports.modify = modify;
exports.removeBoundaryAndDestroy = removeBoundaryAndDestroy;
exports.pointed = pointed;
exports.replaceWithLines = replaceWithLines;
exports.replaceWithLambda = replaceWithLambda;
exports.indentationWidth = indentationWidth;
exports.caseSplitAux = caseSplitAux;
exports.redecorate = redecorate;
exports.next = next;
exports.previous = previous;
/* vscode Not a pure module */
