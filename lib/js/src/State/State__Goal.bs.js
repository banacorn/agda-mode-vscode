// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Caml = require("rescript/lib/js/caml.js");
var Vscode = require("vscode");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Core__Array = require("@rescript/core/lib/js/src/Core__Array.bs.js");
var Core__Option = require("@rescript/core/lib/js/src/Core__Option.bs.js");
var Goal$AgdaModeVscode = require("../Goal.bs.js");
var Item$AgdaModeVscode = require("../View/Component/Item.bs.js");
var Common$AgdaModeVscode = require("../View/Common.bs.js");
var Editor$AgdaModeVscode = require("../Editor.bs.js");
var Parser$AgdaModeVscode = require("../Parser/Parser.bs.js");
var State__View$AgdaModeVscode = require("./State__View.bs.js");
var Highlighting$AgdaModeVscode = require("../Highlighting.bs.js");

function caseSplitAux($$document, goal) {
  var interval_1 = goal.interval[0];
  var interval = [
    0,
    interval_1
  ];
  var range = Common$AgdaModeVscode.Interval.toVSCodeRange($$document, interval);
  var textBeforeGoal = Editor$AgdaModeVscode.$$Text.get($$document, range);
  var nextWordBoundary = function (start, string) {
    var $$break = false;
    var n = 0;
    var i = start;
    while(i < string.length && !$$break) {
      var $$char = string.charAt(i);
      switch ($$char) {
        case "	" :
        case "" :
        case " " :
            n = n + 1 | 0;
            break;
        default:
          $$break = true;
      }
      i = i + 1 | 0;
    };
    return start + n | 0;
  };
  var bracketCount = 0;
  var i = goal.interval[0] - 1 | 0;
  while(i >= 0 && bracketCount >= 0) {
    var i$p = i;
    if (i$p !== 0) {
      var match = textBeforeGoal.charAt(i$p - 1 | 0);
      switch (match) {
        case "{" :
            bracketCount = bracketCount - 1 | 0;
            break;
        case "}" :
            bracketCount = bracketCount + 1 | 0;
            break;
        default:
          
      }
    }
    i = i - 1 | 0;
  };
  var lastOpenCurlyBracketOffset = i + 1 | 0;
  var n = textBeforeGoal.lastIndexOf(";");
  var lastSemicolonOffset = (
    n !== -1 ? n : 0
  ) + 1 | 0;
  var n$1 = textBeforeGoal.lastIndexOf("where");
  var lastWhereTokenOffset = (
    n$1 !== -1 ? n$1 : 0
  ) + 5 | 0;
  var lastLineBreakOffset = Caml.int_max(0, Caml.int_max(textBeforeGoal.lastIndexOf("\r"), textBeforeGoal.lastIndexOf("\n"))) + 1 | 0;
  var inWhereClause = lastWhereTokenOffset > lastOpenCurlyBracketOffset;
  var offset = Caml.int_max(lastLineBreakOffset > lastSemicolonOffset ? lastLineBreakOffset : lastSemicolonOffset, lastWhereTokenOffset > lastOpenCurlyBracketOffset ? lastWhereTokenOffset : lastOpenCurlyBracketOffset);
  var caseStart = nextWordBoundary(offset, textBeforeGoal);
  var caseEnd = goal.interval[1];
  var range$1 = [
    caseStart,
    caseEnd
  ];
  return [
          inWhereClause,
          caseStart - lastLineBreakOffset | 0,
          range$1
        ];
}

function indentationWidth($$document, goal) {
  var goalStart = $$document.positionAt(goal.interval[0]);
  var lineNo = goalStart.line;
  var range = new Vscode.Range(new Vscode.Position(lineNo, 0), goalStart);
  var textBeforeGoal = Editor$AgdaModeVscode.$$Text.get($$document, range);
  var indentedBy = function (s) {
    var n = 0;
    for(var i = 0 ,i_finish = s.length; i < i_finish; ++i){
      var match = s.charAt(i);
      var exit = 0;
      switch (match) {
        case "	" :
        case "" :
        case " " :
        case "\n" :
            exit = 1;
            break;
        default:
          
      }
      if (exit === 1 && i === n) {
        n = n + 1 | 0;
      }
      
    }
    return n;
  };
  return [
          indentedBy(textBeforeGoal),
          textBeforeGoal,
          range
        ];
}

function updateIntervals(state) {
  var indices = state.goals.map(function (goal) {
        return goal.index;
      });
  var diffs = Goal$AgdaModeVscode.generateDiffs(state.document, indices);
  diffs.forEach(function (diff, i) {
        var goal = state.goals[i];
        if (goal !== undefined) {
          goal.interval = diff.modifiedInterval;
          return ;
        }
        
      });
}

async function modify(state, goal, f) {
  updateIntervals(state);
  var content = Goal$AgdaModeVscode.getContent(goal, state.document);
  if (await Goal$AgdaModeVscode.setContent(goal, state.document, f(content))) {
    return updateIntervals(state);
  } else {
    return await State__View$AgdaModeVscode.Panel.display(state, {
                TAG: "Error",
                _0: "Goal-related Error",
                [Symbol.for("name")]: "Error"
              }, [Item$AgdaModeVscode.plainText("Failed to modify the content of goal #" + String(goal.index))]);
  }
}

function parseHolesFromRefineResult(raw) {
  var goalQuestionMark = /([\s\(\{\_\;\.\\\"@]|^)(\?)([\s\)\}\_\;\.\\\"@]|$)/gm;
  var chunks = raw.split(goalQuestionMark);
  return Core__Array.reduce(chunks, [
                [],
                0
              ], (function (param, chunk) {
                  var i = param[1];
                  var offsets = param[0];
                  if (chunk !== undefined) {
                    if (chunk === "?") {
                      return [
                              Belt_Array.concatMany([
                                    offsets,
                                    [i]
                                  ]),
                              i + 1 | 0
                            ];
                    } else {
                      return [
                              offsets,
                              i + chunk.length | 0
                            ];
                    }
                  } else {
                    return [
                            offsets,
                            i
                          ];
                  }
                }))[0];
}

function pointed(state) {
  updateIntervals(state);
  var cursor = Editor$AgdaModeVscode.Cursor.get(state.editor);
  var cursorOffset = state.document.offsetAt(cursor);
  var pointedGoals = state.goals.filter(function (goal) {
        return Common$AgdaModeVscode.Interval.contains(goal.interval, cursorOffset);
      });
  return Core__Option.map(pointedGoals[0], (function (goal) {
                return [
                        goal,
                        Goal$AgdaModeVscode.getContent(goal, state.document)
                      ];
              }));
}

function placeCursorAtFirstNewGoal(state, rewriteText, rewriteRange) {
  var splittedLines = Parser$AgdaModeVscode.splitToLines(rewriteText);
  Core__Option.forEach(splittedLines[0], (function (line) {
          var col = line.length - 1 | 0;
          var lastChar = line.charAt(col);
          if (lastChar !== "?") {
            return ;
          }
          var position = rewriteRange.start.translate(0, col);
          Editor$AgdaModeVscode.Cursor.set(state.editor, position);
        }));
}

async function replaceWithLambda(state, goal, lines) {
  var match = caseSplitAux(state.document, goal);
  var indentWidth = match[1];
  var rewriteText = match[0] ? lines.join("\n" + " ".repeat(indentWidth)) : lines.join("\n" + (" ".repeat(indentWidth - 2 | 0) + "; "));
  var rewriteRange = Common$AgdaModeVscode.Interval.toVSCodeRange(state.document, match[2]);
  if (await Editor$AgdaModeVscode.$$Text.replace(state.document, rewriteRange, rewriteText)) {
    Goal$AgdaModeVscode.destroyDecoration(goal);
    return placeCursorAtFirstNewGoal(state, rewriteText, rewriteRange);
  } else {
    return await State__View$AgdaModeVscode.Panel.display(state, {
                TAG: "Error",
                _0: "Goal-related Error",
                [Symbol.for("name")]: "Error"
              }, [Item$AgdaModeVscode.plainText("Unable to replace the lines of goal #" + String(goal.index))]);
  }
}

async function replaceWithLines(state, goal, lines) {
  var match = indentationWidth(state.document, goal);
  var indentation = " ".repeat(match[0]);
  var indentedLines = indentation + lines.join("\n" + indentation);
  var start = state.document.positionAt(goal.interval[0]);
  var startLineNo = start.line;
  var startLineRange = state.document.lineAt(startLineNo).range;
  var start$1 = startLineRange.start;
  var end_ = state.document.positionAt(goal.interval[1]);
  var rangeToBeReplaced = new Vscode.Range(start$1, end_);
  if (await Editor$AgdaModeVscode.$$Text.replace(state.document, rangeToBeReplaced, indentedLines)) {
    Goal$AgdaModeVscode.destroyDecoration(goal);
    return placeCursorAtFirstNewGoal(state, indentedLines, rangeToBeReplaced);
  } else {
    return await State__View$AgdaModeVscode.Panel.display(state, {
                TAG: "Error",
                _0: "Goal-related Error",
                [Symbol.for("name")]: "Error"
              }, [Item$AgdaModeVscode.plainText("Unable to replace the lines of goal #" + String(goal.index))]);
  }
}

function redecorate(state) {
  updateIntervals(state);
  state.goals.forEach(function (goal) {
        Goal$AgdaModeVscode.refreshDecoration(goal, state.editor);
      });
}

var Module = {
  modify: modify,
  pointed: pointed,
  replaceWithLines: replaceWithLines,
  replaceWithLambda: replaceWithLambda,
  caseSplitAux: caseSplitAux,
  redecorate: redecorate,
  parseHolesFromRefineResult: parseHolesFromRefineResult
};

exports.Module = Module;
exports.modify = modify;
exports.pointed = pointed;
exports.replaceWithLines = replaceWithLines;
exports.replaceWithLambda = replaceWithLambda;
exports.caseSplitAux = caseSplitAux;
exports.redecorate = redecorate;
exports.parseHolesFromRefineResult = parseHolesFromRefineResult;
/* vscode Not a pure module */
