// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Caml = require("rescript/lib/js/caml.js");
var Curry = require("rescript/lib/js/curry.js");
var $$String = require("rescript/lib/js/string.js");
var Vscode = require("vscode");
var $$Promise = require("reason-promise/lib/js/src/js/promise.bs.js");
var Js_array = require("rescript/lib/js/js_array.js");
var Js_string = require("rescript/lib/js/js_string.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Goal$AgdaModeVscode = require("../Goal.bs.js");
var Item$AgdaModeVscode = require("../View/Component/Item.bs.js");
var Common$AgdaModeVscode = require("../View/Common.bs.js");
var Editor$AgdaModeVscode = require("../Editor.bs.js");
var State__View$AgdaModeVscode = require("./State__View.bs.js");

function getOffsets(state) {
  return Belt_Array.map(state.goals, (function (goal) {
                var match = goal.interval;
                var from = match[0];
                return from + Caml.int_min(3, (match[1] - from | 0) / 2 | 0) | 0;
              }));
}

function caseSplitAux($$document, goal) {
  var interval_1 = goal.interval[0];
  var interval = [
    0,
    interval_1
  ];
  var range = Editor$AgdaModeVscode.$$Range.fromInterval($$document, interval);
  var textBeforeGoal = Editor$AgdaModeVscode.$$Text.get($$document, range);
  var nextWordBoundary = function (start, string) {
    var $$break = false;
    var n = 0;
    var i = start;
    while(i < string.length && !$$break) {
      var $$char = Js_string.charAt(i, string);
      switch ($$char) {
        case "	" :
        case "" :
        case " " :
            n = n + 1 | 0;
            break;
        default:
          $$break = true;
      }
      i = i + 1 | 0;
    };
    return start + n | 0;
  };
  var bracketCount = 0;
  var i = goal.interval[0] - 1 | 0;
  while(i >= 0 && bracketCount >= 0) {
    var i$p = i;
    if (i$p !== 0) {
      var match = Js_string.charAt(i$p - 1 | 0, textBeforeGoal);
      switch (match) {
        case "{" :
            bracketCount = bracketCount - 1 | 0;
            break;
        case "}" :
            bracketCount = bracketCount + 1 | 0;
            break;
        default:
          
      }
    }
    i = i - 1 | 0;
  };
  var lastOpenCurlyBracketOffset = i + 1 | 0;
  var n = Js_string.lastIndexOf(";", textBeforeGoal);
  var lastSemicolonOffset = (
    n !== -1 ? n : 0
  ) + 1 | 0;
  var n$1 = Js_string.lastIndexOf("where", textBeforeGoal);
  var lastWhereTokenOffset = (
    n$1 !== -1 ? n$1 : 0
  ) + 5 | 0;
  var lastLineBreakOffset = Caml.int_max(0, Caml.int_max(Js_string.lastIndexOf("\r", textBeforeGoal), Js_string.lastIndexOf("\n", textBeforeGoal))) + 1 | 0;
  var inWhereClause = lastWhereTokenOffset > lastOpenCurlyBracketOffset;
  var offset = Caml.int_max(lastLineBreakOffset > lastSemicolonOffset ? lastLineBreakOffset : lastSemicolonOffset, lastWhereTokenOffset > lastOpenCurlyBracketOffset ? lastWhereTokenOffset : lastOpenCurlyBracketOffset);
  var caseStart = nextWordBoundary(offset, textBeforeGoal);
  var caseEnd = goal.interval[1];
  var range$1 = [
    caseStart,
    caseEnd
  ];
  return [
          inWhereClause,
          caseStart - lastLineBreakOffset | 0,
          range$1
        ];
}

function indentationWidth($$document, goal) {
  var goalStart = $$document.positionAt(goal.interval[0]);
  var lineNo = goalStart.line;
  var range = new Vscode.Range(new Vscode.Position(lineNo, 0), goalStart);
  var textBeforeGoal = Editor$AgdaModeVscode.$$Text.get($$document, range);
  var indentedBy = function (s) {
    var n = 0;
    for(var i = 0 ,i_finish = s.length; i < i_finish; ++i){
      var match = Js_string.charAt(i, s);
      var exit = 0;
      switch (match) {
        case "	" :
        case "" :
        case " " :
        case "\n" :
            exit = 1;
            break;
        default:
          
      }
      if (exit === 1 && i === n) {
        n = n + 1 | 0;
      }
      
    }
    return n;
  };
  return [
          indentedBy(textBeforeGoal),
          textBeforeGoal,
          range
        ];
}

function jumpToOffset(state, offset) {
  var point = state.document.positionAt(offset);
  var range = new Vscode.Range(point, point);
  Editor$AgdaModeVscode.reveal(state.editor, range);
}

function updateIntervals(state) {
  var indices = Belt_Array.map(state.goals, (function (goal) {
          return goal.index;
        }));
  var diffs = Goal$AgdaModeVscode.generateDiffs(state.document, indices);
  Belt_Array.forEachWithIndex(diffs, (function (i, diff) {
          var goal = Belt_Array.get(state.goals, i);
          if (goal !== undefined) {
            goal.interval = diff.modifiedInterval;
            return ;
          }
          
        }));
}

function modify(state, goal, f) {
  updateIntervals(state);
  var content = Goal$AgdaModeVscode.getContent(goal, state.document);
  return $$Promise.flatMap(Goal$AgdaModeVscode.setContent(goal, state.document, Curry._1(f, content)), (function (x) {
                if (x) {
                  updateIntervals(state);
                  return $$Promise.resolved(undefined);
                } else {
                  return State__View$AgdaModeVscode.Panel.display(state, {
                              TAG: 3,
                              _0: "Goal-related Error",
                              [Symbol.for("name")]: "Error"
                            }, [Item$AgdaModeVscode.plainText("Failed to modify the content of goal #" + String(goal.index))]);
                }
              }));
}

function next(state) {
  updateIntervals(state);
  var nextGoal = {
    contents: undefined
  };
  var cursorOffset = state.document.offsetAt(Editor$AgdaModeVscode.Cursor.get(state.editor));
  var offsets = getOffsets(state);
  Belt_Array.forEach(offsets, (function (offset) {
          if (cursorOffset < offset && nextGoal.contents === undefined) {
            nextGoal.contents = offset;
            return ;
          }
          
        }));
  if (nextGoal.contents === undefined) {
    nextGoal.contents = Belt_Array.get(offsets, 0);
  }
  var offset = nextGoal.contents;
  if (offset === undefined) {
    return $$Promise.resolved(undefined);
  }
  var point = state.document.positionAt(offset);
  Editor$AgdaModeVscode.Cursor.set(state.editor, point);
  jumpToOffset(state, offset);
  return $$Promise.resolved(undefined);
}

function previous(state) {
  updateIntervals(state);
  var previousGoal = {
    contents: undefined
  };
  var cursorOffset = state.document.offsetAt(Editor$AgdaModeVscode.Cursor.get(state.editor));
  var offsets = getOffsets(state);
  Belt_Array.forEach(offsets, (function (offset) {
          if (cursorOffset > offset) {
            previousGoal.contents = offset;
            return ;
          }
          
        }));
  if (previousGoal.contents === undefined) {
    previousGoal.contents = Belt_Array.get(offsets, offsets.length - 1 | 0);
  }
  var offset = previousGoal.contents;
  if (offset === undefined) {
    return $$Promise.resolved(undefined);
  }
  var point = state.document.positionAt(offset);
  Editor$AgdaModeVscode.Cursor.set(state.editor, point);
  jumpToOffset(state, offset);
  return $$Promise.resolved(undefined);
}

function instantiate(state, indices) {
  Belt_Array.forEach(state.goals, Goal$AgdaModeVscode.destroy);
  var selection = state.editor.selection;
  var cursorStart = state.document.offsetAt(selection.start);
  var cursorEnd = state.document.offsetAt(selection.end);
  return $$Promise.map(Goal$AgdaModeVscode.makeMany(state.editor, indices), (function (goals) {
                Belt_Array.forEach(goals, (function (goal) {
                        var match = goal.interval;
                        var right = match[1];
                        var left = match[0];
                        var touched = left <= cursorStart && cursorStart <= (left + 2 | 0) || (right - 2 | 0) <= cursorStart && cursorStart <= right || left <= cursorEnd && cursorEnd <= (left + 2 | 0) || (right - 2 | 0) <= cursorEnd && cursorEnd <= right;
                        if (touched) {
                          return Goal$AgdaModeVscode.setCursor(goal, state.editor);
                        }
                        
                      }));
                state.goals = goals;
              }));
}

function pointed(state) {
  updateIntervals(state);
  var cursor = Editor$AgdaModeVscode.Cursor.get(state.editor);
  var cursorOffset = state.document.offsetAt(cursor);
  var pointedGoals = Belt_Array.keep(state.goals, (function (goal) {
          return Common$AgdaModeVscode.Interval.contains(goal.interval, cursorOffset);
        }));
  return Belt_Option.map(Belt_Array.get(pointedGoals, 0), (function (goal) {
                return [
                        goal,
                        Goal$AgdaModeVscode.getContent(goal, state.document)
                      ];
              }));
}

function placeCursorAtFirstNewGoal(state, rewriteText, rewriteRange) {
  var splittedLines = Js_string.split("\n", rewriteText);
  Belt_Option.forEach(Belt_Array.get(splittedLines, 0), (function (line) {
          var col = line.length - 1 | 0;
          var lastChar = Js_string.charAt(col, line);
          if (lastChar !== "?") {
            return ;
          }
          var position = rewriteRange.start.translate(0, col);
          Editor$AgdaModeVscode.Cursor.set(state.editor, position);
        }));
}

function replaceWithLambda(state, goal, lines) {
  var match = caseSplitAux(state.document, goal);
  var indentWidth = match[1];
  var rewriteText = match[0] ? Js_array.joinWith("\n" + Js_string.repeat(indentWidth, " "), lines) : Js_array.joinWith("\n" + (Js_string.repeat(indentWidth - 2 | 0, " ") + "; "), lines);
  var rewriteRange = Editor$AgdaModeVscode.$$Range.fromInterval(state.document, match[2]);
  return $$Promise.flatMap(Editor$AgdaModeVscode.$$Text.replace(state.document, rewriteRange, rewriteText), (function (x) {
                if (x) {
                  Goal$AgdaModeVscode.destroy(goal);
                  placeCursorAtFirstNewGoal(state, rewriteText, rewriteRange);
                  return $$Promise.resolved(undefined);
                } else {
                  return State__View$AgdaModeVscode.Panel.display(state, {
                              TAG: 3,
                              _0: "Goal-related Error",
                              [Symbol.for("name")]: "Error"
                            }, [Item$AgdaModeVscode.plainText("Unable to replace the lines of goal #" + String(goal.index))]);
                }
              }));
}

function replaceWithLines(state, goal, lines) {
  var match = indentationWidth(state.document, goal);
  var indentation = Js_string.repeat(match[0], " ");
  var indentedLines = indentation + Js_array.joinWith("\n" + indentation, lines);
  var start = Editor$AgdaModeVscode.Position.fromOffset(state.document, goal.interval[0]);
  var startLineNo = start.line;
  var startLineRange = state.document.lineAt(startLineNo).range;
  var start$1 = startLineRange.start;
  var end_ = Editor$AgdaModeVscode.Position.fromOffset(state.document, goal.interval[1]);
  var rangeToBeReplaced = new Vscode.Range(start$1, end_);
  return $$Promise.flatMap(Editor$AgdaModeVscode.$$Text.replace(state.document, rangeToBeReplaced, indentedLines), (function (x) {
                if (x) {
                  Goal$AgdaModeVscode.destroy(goal);
                  placeCursorAtFirstNewGoal(state, indentedLines, rangeToBeReplaced);
                  return $$Promise.resolved(undefined);
                } else {
                  return State__View$AgdaModeVscode.Panel.display(state, {
                              TAG: 3,
                              _0: "Goal-related Error",
                              [Symbol.for("name")]: "Error"
                            }, [Item$AgdaModeVscode.plainText("Unable to replace the lines of goal #" + String(goal.index))]);
                }
              }));
}

function removeBoundaryAndDestroy(state, goal) {
  updateIntervals(state);
  var innerRange = Goal$AgdaModeVscode.getInnerRange(goal, state.document);
  var outerRange = Editor$AgdaModeVscode.$$Range.fromInterval(state.document, goal.interval);
  var content = $$String.trim(Editor$AgdaModeVscode.$$Text.get(state.document, innerRange));
  return $$Promise.flatMap(Editor$AgdaModeVscode.$$Text.replace(state.document, outerRange, content), (function (x) {
                if (x) {
                  Goal$AgdaModeVscode.destroy(goal);
                  return $$Promise.resolved(undefined);
                } else {
                  return State__View$AgdaModeVscode.Panel.display(state, {
                              TAG: 3,
                              _0: "Goal-related Error",
                              [Symbol.for("name")]: "Error"
                            }, [Item$AgdaModeVscode.plainText("Unable to remove the boundary of goal #" + String(goal.index))]);
                }
              }));
}

function redecorate(state) {
  updateIntervals(state);
  Belt_Array.forEach(state.goals, (function (goal) {
          Goal$AgdaModeVscode.refreshDecoration(goal, state.editor);
        }));
}

var Module = {
  instantiate: instantiate,
  modify: modify,
  removeBoundaryAndDestroy: removeBoundaryAndDestroy,
  pointed: pointed,
  replaceWithLines: replaceWithLines,
  replaceWithLambda: replaceWithLambda,
  caseSplitAux: caseSplitAux,
  redecorate: redecorate,
  next: next,
  previous: previous
};

exports.Module = Module;
exports.instantiate = instantiate;
exports.modify = modify;
exports.removeBoundaryAndDestroy = removeBoundaryAndDestroy;
exports.pointed = pointed;
exports.replaceWithLines = replaceWithLines;
exports.replaceWithLambda = replaceWithLambda;
exports.caseSplitAux = caseSplitAux;
exports.redecorate = redecorate;
exports.next = next;
exports.previous = previous;
/* vscode Not a pure module */
