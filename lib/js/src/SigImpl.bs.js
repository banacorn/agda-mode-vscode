// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var VSCode = require("bs-vscode/lib/js/src/VSCode.bs.js");
var Vscode = require("vscode");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Sig$AgdaModeVscode = require("./Sig.bs.js");
var Parser$AgdaModeVscode = require("./Parser.bs.js");
var View__Controller$AgdaModeVscode = require("./View__Controller.bs.js");

function make(prim) {
  return new Vscode.Disposable(prim);
}

function dispose(prim) {
  return prim.dispose();
}

var Disposable = {
  make: make,
  dispose: dispose
};

function make$1(prim, prim$1) {
  return new Vscode.Position(prim, prim$1);
}

function line(prim) {
  return prim.line;
}

function column(prim) {
  return prim.character;
}

function translate(prim, prim$1, prim$2) {
  return prim.translate(prim$1, prim$2);
}

function compare(x, y) {
  var match = x.compareTo(y);
  switch (match) {
    case -1 :
        return /* LT */2;
    case 0 :
        return /* EQ */1;
    case 1 :
        return /* GT */0;
    default:
      return /* EQ */1;
  }
}

var Point = {
  make: make$1,
  line: line,
  column: column,
  translate: translate,
  compare: compare
};

function pointAtOffset($$document, offset) {
  return $$document.positionAt(offset);
}

function offsetAtPoint($$document, point) {
  return $$document.offsetAt(point);
}

function make$2(prim, prim$1) {
  return new Vscode.Range(prim, prim$1);
}

function start(prim) {
  return prim.start;
}

function end_(prim) {
  return prim.end;
}

function isSingleLine(prim) {
  return prim.isSingleLine;
}

function contains(prim, prim$1) {
  return prim.contains(prim$1);
}

function containsRange(prim, prim$1) {
  return prim.contains(prim$1);
}

function fromOffset($$document, param) {
  return new Vscode.Range($$document.positionAt(param[0]), $$document.positionAt(param[1]));
}

var $$Range = {
  make: make$2,
  start: start,
  end_: end_,
  isSingleLine: isSingleLine,
  contains: contains,
  containsRange: containsRange,
  fromOffset: fromOffset
};

function getExtensionPath(context) {
  return context.extensionPath;
}

function getFileName($$document) {
  return Parser$AgdaModeVscode.filepath($$document.fileName);
}

function getDocument(prim) {
  return prim.document;
}

function openDocument(fileName) {
  return Vscode.workspace.openTextDocument(fileName);
}

function openEditor(fileName) {
  return Vscode.window.showTextDocument(Vscode.Uri.file(fileName), undefined);
}

function openEditorWithContent(content) {
  return $$Promise.flatMap(Vscode.workspace.openTextDocument({
                  content: content,
                  language: "agda"
                }), (function (textDocument) {
                return Vscode.window.showTextDocument(textDocument, undefined);
              }));
}

function save(prim) {
  return prim.save();
}

function getDisposables(context) {
  return context.subscriptions;
}

function onDidCloseEditor(callback) {
  return Vscode.workspace.onDidCloseTextDocument((function (textDoc) {
                return Belt_Option.forEach(textDoc, (function (textDoc) {
                              return Curry._1(callback, textDoc.fileName);
                            }));
              }));
}

function onDidChangeFileName(callback) {
  return Vscode.workspace.onDidRenameFiles((function ($$event) {
                return Belt_Option.forEach(Belt_Option.map($$event, (function (prim) {
                                  return prim.files;
                                })), (function (files) {
                              return Belt_Array.forEach(files, (function (file) {
                                            return Curry._2(callback, file.oldUri.path, file.newUri.path);
                                          }));
                            }));
              }));
}

function onDidChangeActivation(callback) {
  var previous = {
    contents: Vscode.window.activeTextEditor
  };
  return Vscode.window.onDidChangeActiveTextEditor((function (next) {
                if (Caml_obj.caml_notequal(Belt_Option.flatMap(Belt_Option.map(next, (function (prim) {
                                  return prim.document;
                                })), getFileName), Belt_Option.flatMap(Belt_Option.map(previous.contents, (function (prim) {
                                  return prim.document;
                                })), getFileName))) {
                  Curry._2(callback, previous.contents, next);
                  previous.contents = next;
                  return ;
                }
                
              }));
}

function registerCommand(name, callback) {
  return Vscode.commands.registerCommand("agda-mode." + name, (function (param) {
                return Belt_Option.flatMap(Vscode.window.activeTextEditor, (function (editor) {
                              var $$document = editor.document;
                              return Belt_Option.map(Parser$AgdaModeVscode.filepath($$document.fileName), (function (fileName) {
                                            return Curry._2(callback, editor, fileName);
                                          }));
                            }));
              }));
}

function setContext(prim, prim$1) {
  return Vscode.commands.executeCommand("setContext", prim, prim$1);
}

function setAgdaPath(path) {
  return Vscode.workspace.getConfiguration("agdaMode", undefined).update("agdaPath", path, 1, undefined);
}

function getAgdaPath(param) {
  return Vscode.workspace.getConfiguration("agdaMode", undefined).get("agdaPath");
}

function getLibraryPath(param) {
  var raw = Belt_Option.getWithDefault(Vscode.workspace.getConfiguration("agdaMode", undefined).get("libraryPath"), "");
  return Belt_Array.map(Belt_Array.keep(raw.split(","), (function (x) {
                    return x !== "";
                  })), Parser$AgdaModeVscode.filepath);
}

function getHighlightingMethod(param) {
  var raw = Vscode.workspace.getConfiguration("agdaMode", undefined).get("highlighting.IPC");
  if (raw === "Standard input/output") {
    return true;
  } else {
    return false;
  }
}

function getSemanticHighlighting(param) {
  var raw = Vscode.workspace.getConfiguration("agdaMode", undefined).get("highlighting.semanticToken");
  if (raw !== undefined && raw) {
    return true;
  } else {
    return false;
  }
}

function getBackend(param) {
  var raw = Vscode.workspace.getConfiguration("agdaMode", undefined).get("backend");
  if (raw === undefined) {
    return "GHCNoMain";
  }
  switch (raw) {
    case "GHC" :
        return "GHCNoMain";
    case "LaTeX" :
        return "LaTeX";
    case "QuickLaTeX" :
        return "QuickLaTeX";
    default:
      return "GHCNoMain";
  }
}

var Config = {
  setAgdaPath: setAgdaPath,
  getAgdaPath: getAgdaPath,
  getLibraryPath: getLibraryPath,
  getHighlightingMethod: getHighlightingMethod,
  getSemanticHighlighting: getSemanticHighlighting,
  getBackend: getBackend
};

var View = {
  send: View__Controller$AgdaModeVscode.send,
  onEvent: View__Controller$AgdaModeVscode.onEvent,
  destroy: View__Controller$AgdaModeVscode.destroy,
  show: View__Controller$AgdaModeVscode.show,
  focus: View__Controller$AgdaModeVscode.focus,
  hide: View__Controller$AgdaModeVscode.hide,
  fromPosition: View__Controller$AgdaModeVscode.fromPosition,
  fromInterval: View__Controller$AgdaModeVscode.fromInterval,
  make: View__Controller$AgdaModeVscode.make
};

function decorate(editor, decoration, ranges) {
  editor.setDecorations(decoration, ranges);
  
}

function highlightBackgroundPrim(editor, backgroundColor, ranges) {
  var rangeBehavior = VSCode.DecorationRangeBehavior.toEnum(/* ClosedClosed */1);
  var options = {
    backgroundColor: backgroundColor,
    rangeBehavior: rangeBehavior
  };
  var decoration = Vscode.window.createTextEditorDecorationType(options);
  decorate(editor, decoration, ranges);
  return decoration;
}

function highlightBackground(editor, style, ranges) {
  return highlightBackgroundPrim(editor, VSCode.ThemeColor.themeColor(new Vscode.ThemeColor(style)), ranges);
}

function highlightBackgroundWithColor(editor, color, ranges) {
  return highlightBackgroundPrim(editor, VSCode.ThemeColor.string(color), ranges);
}

function decorateTextPrim(editor, color, ranges) {
  var rangeBehavior = VSCode.DecorationRangeBehavior.toEnum(/* ClosedClosed */1);
  var options = {
    color: color,
    rangeBehavior: rangeBehavior
  };
  var decoration = Vscode.window.createTextEditorDecorationType(options);
  decorate(editor, decoration, ranges);
  return decoration;
}

function decorateText(editor, style, ranges) {
  return decorateTextPrim(editor, VSCode.ThemeColor.themeColor(new Vscode.ThemeColor(style)), ranges);
}

function decorateTextWithColor(editor, color, ranges) {
  return decorateTextPrim(editor, VSCode.ThemeColor.string(color), ranges);
}

function overlayTextPrim(editor, color, text, range) {
  var after = {
    color: color,
    contentText: text
  };
  var options = {
    after: after
  };
  var decoration = Vscode.window.createTextEditorDecorationType(options);
  decorate(editor, decoration, [range]);
  return decoration;
}

function overlayText(editor, style, text, range) {
  return overlayTextPrim(editor, VSCode.ThemeColor.themeColor(new Vscode.ThemeColor(style)), text, range);
}

function overlayTextWithColor(editor, color, text, range) {
  return overlayTextPrim(editor, VSCode.ThemeColor.string(color), text, range);
}

function underlineText(editor, range) {
  var rangeBehavior = VSCode.DecorationRangeBehavior.toEnum(/* OpenOpen */0);
  var options = {
    rangeBehavior: rangeBehavior,
    textDecoration: "underline dotted"
  };
  var decoration = Vscode.window.createTextEditorDecorationType(options);
  decorate(editor, decoration, [range]);
  return decoration;
}

function destroy(prim) {
  prim.dispose();
  
}

var Decoration = {
  decorate: decorate,
  highlightBackgroundPrim: highlightBackgroundPrim,
  highlightBackground: highlightBackground,
  highlightBackgroundWithColor: highlightBackgroundWithColor,
  decorateTextPrim: decorateTextPrim,
  decorateText: decorateText,
  decorateTextWithColor: decorateTextWithColor,
  overlayTextPrim: overlayTextPrim,
  overlayText: overlayText,
  overlayTextWithColor: overlayTextWithColor,
  underlineText: underlineText,
  destroy: destroy
};

function focus(editor) {
  Vscode.window.showTextDocument(editor.document, /* Beside */1, undefined);
  
}

function reveal(editor, range) {
  return VSCode.TextEditor.revealRange(editor, range, /* InCenterIfOutsideViewport */3);
}

function getSelection(editor) {
  var selection = editor.selection;
  return new Vscode.Range(selection.start, selection.end);
}

function getSelections(editor) {
  return Belt_Array.map(editor.selections, (function (selection) {
                return new Vscode.Range(selection.start, selection.end);
              }));
}

function setSelection(editor, range) {
  var selection = new Vscode.Selection(range.start, range.end);
  editor.selection = selection;
  
}

function setSelections(editor, ranges) {
  var selections = Belt_Array.map(ranges, (function (range) {
          return new Vscode.Selection(range.start, range.end);
        }));
  editor.selections = selections;
  
}

function getCursorPosition(editor) {
  return editor.selection.end;
}

function getCursorPositions(editor) {
  return Belt_Array.map(editor.selections, (function (prim) {
                return prim.end;
              }));
}

function setCursorPosition(editor, point) {
  editor.selection = new Vscode.Selection(point, point);
  
}

function setCursorPositions(editor, points) {
  editor.selections = Belt_Array.map(points, (function (point) {
          return new Vscode.Selection(point, point);
        }));
  
}

function onChangeCursorPosition(callback) {
  return Vscode.window.onDidChangeTextEditorSelection((function ($$event) {
                return Curry._1(callback, Belt_Array.map($$event.selections, (function (prim) {
                                  return prim.anchor;
                                })));
              }));
}

function rangeForLine($$document, line) {
  return $$document.lineAt(line).range;
}

function computeUTF16SurrogatePairIndices(text) {
  var surrogatePairs = [];
  var lengthInCodeUnits = text.length;
  var i = 0;
  while(i < lengthInCodeUnits) {
    var charCode = text.charCodeAt(i) | 0;
    var notFinal = (i + 1 | 0) < lengthInCodeUnits;
    if (charCode >= 55296 && charCode <= 56319 && notFinal) {
      var nextCharCode = text.charCodeAt(i + 1 | 0) | 0;
      if (nextCharCode >= 56320 && charCode <= 57343) {
        surrogatePairs.push(i);
      }
      i = i + 2 | 0;
    } else {
      i = i + 1 | 0;
    }
  };
  return surrogatePairs;
}

function compile(text) {
  var indicesUTF16 = computeUTF16SurrogatePairIndices(text);
  var indicesUTF8 = Belt_Array.mapWithIndex(indicesUTF16, (function (i, x) {
          return x - i | 0;
        }));
  var intervals = Belt_Array.mapWithIndex(indicesUTF8, (function (i, rightEndpoint) {
          var x = Belt_Array.get(indicesUTF8, i - 1 | 0);
          var leftEndpoint = x !== undefined ? x + 1 | 0 : 0;
          return /* tuple */[
                  leftEndpoint,
                  rightEndpoint
                ];
        }));
  var lastEndpoint = text.length - indicesUTF16.length | 0;
  var match = Belt_Array.get(intervals, intervals.length - 1 | 0);
  var intervals$1 = match !== undefined ? Belt_Array.concat(intervals, [/* tuple */[
            match[1] + 1 | 0,
            lastEndpoint
          ]]) : [/* tuple */[
        0,
        lastEndpoint
      ]];
  return {
          intervals: intervals$1,
          cursor: 0
        };
}

var OffsetIntervals = {
  computeUTF16SurrogatePairIndices: computeUTF16SurrogatePairIndices,
  compile: compile
};

function fromUTF8Offset(self, index) {
  while(true) {
    var match = Belt_Array.get(self.intervals, self.cursor);
    if (match === undefined) {
      return index;
    }
    if (index < match[0]) {
      self.cursor = 0;
      continue ;
    }
    if (index <= match[1]) {
      return index + self.cursor | 0;
    }
    self.cursor = self.cursor + 1 | 0;
    continue ;
  };
}

function toUTF8Offset($$document, offset) {
  var range = new Vscode.Range(new Vscode.Position(0, 0), $$document.positionAt(offset));
  return Sig$AgdaModeVscode.characterWidth($$document.getText(Caml_option.some(range)));
}

function getTextInRange($$document, range) {
  return $$document.getText(Caml_option.some(range));
}

function getText($$document) {
  return $$document.getText(undefined);
}

function selectText(editor, range) {
  var start = range.start;
  var end_ = range.end;
  var selection = new Vscode.Selection(start, end_);
  editor.selection = selection;
  
}

function replaceText($$document, range, text) {
  var workspaceEdit = new Vscode.WorkspaceEdit();
  workspaceEdit.replace($$document.uri, range, text, undefined);
  return Vscode.workspace.applyEdit(workspaceEdit);
}

function replaceTextBatch($$document, replacements) {
  var workspaceEdit = new Vscode.WorkspaceEdit();
  Belt_Array.forEach(replacements, (function (param) {
          workspaceEdit.replace($$document.uri, param[0], param[1], undefined);
          
        }));
  return Vscode.workspace.applyEdit(workspaceEdit);
}

function insertText($$document, point, text) {
  var workspaceEdit = new Vscode.WorkspaceEdit();
  workspaceEdit.insert($$document.uri, point, text, undefined);
  return Vscode.workspace.applyEdit(workspaceEdit);
}

function insertTexts($$document, points, text) {
  var workspaceEdit = new Vscode.WorkspaceEdit();
  var textEdits = Belt_Array.map(points, (function (point) {
          return Vscode.TextEdit.insert(point, text);
        }));
  workspaceEdit.set($$document.uri, textEdits);
  return Vscode.workspace.applyEdit(workspaceEdit);
}

function deleteText($$document, range) {
  var workspaceEdit = new Vscode.WorkspaceEdit();
  workspaceEdit.delete($$document.uri, range, undefined);
  return Vscode.workspace.applyEdit(workspaceEdit);
}

function onChange(callback) {
  return Vscode.workspace.onDidChangeTextDocument((function ($$event) {
                if ($$event !== undefined) {
                  return Curry._1(callback, Belt_Array.map(Caml_option.valFromOption($$event).contentChanges, (function (change) {
                                    return {
                                            offset: change.rangeOffset,
                                            insertedText: change.text,
                                            replacedTextLength: change.rangeLength
                                          };
                                  })));
                }
                
              }));
}

function copyToClipboard(text) {
  return Vscode.env.clipboard.writeText(text);
}

function colorThemeIsDark(param) {
  return VSCode.ColorTheme.kind(Vscode.window.activeColorTheme) === /* Dark */1;
}

function lineEndingIsCRLF($$document) {
  var match = VSCode.TextDocument.eol($$document);
  if (match) {
    return false;
  } else {
    return true;
  }
}

function registerProvider(definitionProvider, hoverProvider) {
  var documentSelector = [VSCode.DocumentFilterOrString.string("agda")];
  var definitionProvider$1 = {
    provideDefinition: (function (textDocument, point, param) {
        return VSCode.ProviderResult.map(Curry._2(definitionProvider, textDocument.fileName, point), (function (pairs) {
                      return VSCode.LocationLinkOrLocation.locationLinks(Belt_Array.map(pairs, (function (param) {
                                        var targetPos = param[2];
                                        return {
                                                originSelectionRange: Caml_option.some(param[0]),
                                                targetRange: new Vscode.Range(targetPos, targetPos),
                                                targetSelectionRange: undefined,
                                                targetUri: Vscode.Uri.file(param[1])
                                              };
                                      })));
                    }));
      })
  };
  var hoverProvider$1 = {
    provideHover: (function (textDocument, point, param) {
        return VSCode.ProviderResult.map(Curry._2(hoverProvider, textDocument.fileName, point), (function (param) {
                      var markdownStrings = Belt_Array.map(param[0], (function (string) {
                              return new Vscode.MarkdownString(string, true);
                            }));
                      return new Vscode.Hover(markdownStrings, param[1]);
                    }));
      })
  };
  return [
          Vscode.languages.registerDefinitionProvider(documentSelector, definitionProvider$1),
          Vscode.languages.registerHoverProvider(documentSelector, hoverProvider$1)
        ];
}

var SemanticsTokens = { };

var SemanticTokensLegend = { };

var SemanticTokensBuilder = { };

var DocumentSemanticTokensProvider = { };

var Languages = { };

var Mock = {
  SemanticsTokens: SemanticsTokens,
  SemanticTokensLegend: SemanticTokensLegend,
  SemanticTokensBuilder: SemanticTokensBuilder,
  DocumentSemanticTokensProvider: DocumentSemanticTokensProvider,
  Languages: Languages
};

function registerTestingProvider(prodider, param) {
  var documentSelector = [VSCode.DocumentFilterOrString.string("agda")];
  var semanticTokensLegend = new Vscode.SemanticTokensLegend(param[0], param[1]);
  var documentSemanticTokensProvider = {
    provideDocumentSemanticTokens: (function (textDocument, param) {
        var builder = new Vscode.SemanticTokensBuilder(semanticTokensLegend);
        var pushLegend = function (param, param$1, param$2) {
          builder.push(param, param$1, param$2);
          
        };
        return VSCode.ProviderResult.map(Curry._2(prodider, textDocument.fileName, pushLegend), (function (param) {
                      return builder.build();
                    }));
      })
  };
  return [Vscode.languages.registerDocumentSemanticTokensProvider(documentSelector, documentSemanticTokensProvider, semanticTokensLegend)];
}

var editorType = /* VsCode */1;

exports.Disposable = Disposable;
exports.Point = Point;
exports.pointAtOffset = pointAtOffset;
exports.offsetAtPoint = offsetAtPoint;
exports.$$Range = $$Range;
exports.editorType = editorType;
exports.getExtensionPath = getExtensionPath;
exports.getFileName = getFileName;
exports.getDocument = getDocument;
exports.openDocument = openDocument;
exports.openEditor = openEditor;
exports.openEditorWithContent = openEditorWithContent;
exports.save = save;
exports.getDisposables = getDisposables;
exports.onDidCloseEditor = onDidCloseEditor;
exports.onDidChangeFileName = onDidChangeFileName;
exports.onDidChangeActivation = onDidChangeActivation;
exports.registerCommand = registerCommand;
exports.setContext = setContext;
exports.Config = Config;
exports.View = View;
exports.Decoration = Decoration;
exports.focus = focus;
exports.reveal = reveal;
exports.getSelection = getSelection;
exports.getSelections = getSelections;
exports.setSelection = setSelection;
exports.setSelections = setSelections;
exports.getCursorPosition = getCursorPosition;
exports.getCursorPositions = getCursorPositions;
exports.setCursorPosition = setCursorPosition;
exports.setCursorPositions = setCursorPositions;
exports.onChangeCursorPosition = onChangeCursorPosition;
exports.rangeForLine = rangeForLine;
exports.OffsetIntervals = OffsetIntervals;
exports.fromUTF8Offset = fromUTF8Offset;
exports.toUTF8Offset = toUTF8Offset;
exports.getTextInRange = getTextInRange;
exports.getText = getText;
exports.selectText = selectText;
exports.replaceText = replaceText;
exports.replaceTextBatch = replaceTextBatch;
exports.insertText = insertText;
exports.insertTexts = insertTexts;
exports.deleteText = deleteText;
exports.onChange = onChange;
exports.copyToClipboard = copyToClipboard;
exports.colorThemeIsDark = colorThemeIsDark;
exports.lineEndingIsCRLF = lineEndingIsCRLF;
exports.registerProvider = registerProvider;
exports.Mock = Mock;
exports.registerTestingProvider = registerTestingProvider;
/* VSCode Not a pure module */
