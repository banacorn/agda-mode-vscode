// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Caml = require("rescript/lib/js/caml.js");
var Vscode = require("vscode");
var Core__List = require("@rescript/core/lib/js/src/Core__List.bs.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Core__Array = require("@rescript/core/lib/js/src/Core__Array.bs.js");
var Util$AgdaModeVscode = require("./Util/Util.bs.js");
var Editor$AgdaModeVscode = require("./Editor.bs.js");
var Tokens$AgdaModeVscode = require("./Tokens.bs.js");
var AVLTree$AgdaModeVscode = require("./Util/AVLTree.bs.js");
var BinarySearchTree = require("@datastructures-js/binary-search-tree");

function decorate(editor, start, end, index) {
  var $$document = editor.document;
  var backgroundRange = new Vscode.Range($$document.positionAt(start), $$document.positionAt(end));
  var background = Editor$AgdaModeVscode.Decoration.highlightBackground(editor, "editor.selectionHighlightBackground", [backgroundRange]);
  var indexText = String(index);
  var indexRange = new Vscode.Range($$document.positionAt(start), $$document.positionAt(end - 2 | 0));
  var index$1 = Editor$AgdaModeVscode.Decoration.overlayText(editor, "editorLightBulb.foreground", indexText, indexRange);
  return [
          background,
          index$1
        ];
}

function make(editor, start, end, index) {
  var match = decorate(editor, start, end, index);
  return {
          index: index,
          start: start,
          end: end,
          decorationBackground: match[0],
          decorationIndex: match[1]
        };
}

function toString(goal) {
  return "#" + String(goal.index) + " [" + String(goal.start) + "-" + String(goal.end) + ")";
}

function make$1() {
  return {
          goals: new Map(),
          positions: new BinarySearchTree.BinarySearchTree()
        };
}

function serialize(self) {
  return Array.from(self.goals.values()).toSorted(function (x, y) {
                return Caml.int_compare(x.index, y.index);
              }).map(toString);
}

function destroyGoal(self, goal) {
  Editor$AgdaModeVscode.Decoration.destroy(goal.decorationBackground);
  Editor$AgdaModeVscode.Decoration.destroy(goal.decorationIndex);
  self.goals.delete(goal.index);
  self.positions.remove(goal.start);
}

function clear(self) {
  Array.from(self.goals.values()).forEach(function (goal) {
        Editor$AgdaModeVscode.Decoration.destroy(goal.decorationBackground);
        Editor$AgdaModeVscode.Decoration.destroy(goal.decorationIndex);
      });
  self.goals = new Map();
  self.positions = new BinarySearchTree.BinarySearchTree();
}

async function expandQuestionMarkGoals(self, $$document) {
  var rewrites = Core__Array.filterMap(Array.from(self.goals.values()), (function (goal) {
          var range = new Vscode.Range($$document.positionAt(goal.start), $$document.positionAt(goal.end));
          var content = $$document.getText(Caml_option.some(range));
          if (content === "?") {
            return [
                    range,
                    "{!   !}"
                  ];
          }
          
        }));
  await Editor$AgdaModeVscode.$$Text.batchReplace($$document, rewrites);
}

function updateGoalPosition(self, editor, goal, deltaStart, deltaEnd, redecorate) {
  var newStart = goal.start + deltaStart | 0;
  var newEnd = goal.end + deltaEnd | 0;
  self.positions.remove(goal.start);
  var updatedGoal = redecorate ? (destroyGoal(self, goal), make(editor, newStart, newEnd, goal.index)) : ({
        index: goal.index,
        start: newStart,
        end: newEnd,
        decorationBackground: goal.decorationBackground,
        decorationIndex: goal.decorationIndex
      });
  console.log("Update " + toString(goal) + " => " + toString(updatedGoal) + " (deltaStart: " + String(deltaStart) + ", deltaEnd: " + String(deltaEnd) + ")");
  self.positions.insert(newStart, updatedGoal.index);
  self.goals.set(updatedGoal.index, updatedGoal);
}

async function instantiateGoalsFromLoad(self, editor, indices, positions) {
  clear(self);
  Array.from(positions.entries()).forEach(function (param, i) {
        var start = param[0];
        var index = indices[i];
        if (index === undefined) {
          return ;
        }
        var goal = make(editor, start, param[1], index);
        self.goals.set(index, goal);
        self.positions.insert(start, index);
      });
  return await expandQuestionMarkGoals(self, editor.document);
}

async function updatePositions(self, editor, $$event) {
  console.log(" ======= Update positions ======= ");
  var $$document = editor.document;
  var changes = Core__List.fromArray($$event.contentChanges.map(Tokens$AgdaModeVscode.Change.fromTextDocumentContentChangeEvent).toReversed());
  var go = function (_delta, _goals, _changes) {
    while(true) {
      var changes = _changes;
      var goals = _goals;
      var delta = _delta;
      if (!goals) {
        return /* [] */0;
      }
      var goals$1 = goals.tl;
      var goal = goals.hd;
      if (changes) {
        var changes$1 = changes.tl;
        var change = changes.hd;
        var removalStart = change.offset;
        var removalEnd = change.offset + change.removed | 0;
        if (removalEnd <= goal.start) {
          var delta$1 = (delta + change.inserted | 0) - change.removed | 0;
          _changes = changes$1;
          _goals = {
            hd: goal,
            tl: goals$1
          };
          _delta = delta$1;
          continue ;
        }
        if (removalStart >= goal.end) {
          _changes = {
            hd: change,
            tl: changes$1
          };
          _goals = goals$1;
          continue ;
        }
        if (goal.start >= removalStart && goal.end <= removalEnd) {
          if ((goal.end - goal.start | 0) === 1 && change.removed === 1 && change.inserted === 7) {
            var delta$p = (delta + change.inserted | 0) - change.removed | 0;
            return {
                    hd: {
                      TAG: "UpdatePosition",
                      _0: goal,
                      _1: delta,
                      _2: delta$p,
                      _3: true,
                      [Symbol.for("name")]: "UpdatePosition"
                    },
                    tl: go(delta$p, goals$1, changes$1)
                  };
          }
          var delta$2 = (delta + change.inserted | 0) - change.removed | 0;
          return {
                  hd: {
                    TAG: "Destroy",
                    _0: goal,
                    [Symbol.for("name")]: "Destroy"
                  },
                  tl: go(delta$2, goals$1, changes$1)
                };
        }
        if ((goal.start + 2 | 0) <= removalStart && (goal.end - 2 | 0) >= removalEnd) {
          var delta$p$1 = (delta + change.inserted | 0) - change.removed | 0;
          return {
                  hd: {
                    TAG: "UpdatePosition",
                    _0: goal,
                    _1: delta,
                    _2: delta$p$1,
                    _3: false,
                    [Symbol.for("name")]: "UpdatePosition"
                  },
                  tl: go(delta$p$1, goals$1, changes$1)
                };
        }
        console.log("partially damaged goal: " + toString(goal));
        var damage = removalStart <= goal.start ? (
            removalEnd === (goal.start + 1 | 0) ? ({
                  TAG: "A",
                  _0: goal.start - removalStart | 0,
                  [Symbol.for("name")]: "A"
                }) : (
                removalEnd === (goal.end - 1 | 0) ? "ABC" : "AB"
              )
          ) : (
            removalStart === (goal.start + 1 | 0) ? (
                removalEnd <= (goal.end - 2 | 0) ? "B" : (
                    removalEnd === (goal.end - 1 | 0) ? "BC" : "BCD"
                  )
              ) : (
                removalStart === (goal.end - 1 | 0) ? "D" : (
                    removalEnd === (goal.end - 1 | 0) ? "C" : "CD"
                  )
              )
          );
        var delta$3 = (delta + change.inserted | 0) - change.removed | 0;
        return {
                hd: {
                  TAG: "Restore",
                  _0: goal,
                  _1: damage,
                  [Symbol.for("name")]: "Restore"
                },
                tl: go(delta$3, goals$1, changes$1)
              };
      }
      if (delta !== 0) {
        return {
                hd: {
                  TAG: "UpdatePosition",
                  _0: goal,
                  _1: delta,
                  _2: delta,
                  _3: false,
                  [Symbol.for("name")]: "UpdatePosition"
                },
                tl: go(delta, goals$1, changes)
              };
      }
      _goals = goals$1;
      continue ;
    };
  };
  if (Core__List.length(changes) === 0) {
    return ;
  }
  var goals = Core__List.fromArray(Core__Array.filterMap(AVLTree$AgdaModeVscode.toArray(self.positions), (function (index) {
              return self.goals.get(index);
            })));
  var rewrites = Core__Array.filterMap(Core__List.toArray(go(0, goals, changes)), (function (action) {
          switch (action.TAG) {
            case "Destroy" :
                destroyGoal(self, action._0);
                return ;
            case "Restore" :
                var delta = action._1;
                var goal = action._0;
                if (typeof delta !== "object") {
                  return ;
                }
                var delta$1 = delta._0;
                console.log("type A");
                updateGoalPosition(self, editor, goal, -delta$1 | 0, (-delta$1 | 0) - 1 | 0, false);
                var position = $$document.positionAt(goal.start - delta$1 | 0);
                var range = new Vscode.Range(position, position);
                return [
                        range,
                        "{"
                      ];
            case "UpdatePosition" :
                updateGoalPosition(self, editor, action._0, action._1, action._2, action._3);
                return ;
            
          }
        }));
  console.log("Goals after update: " + Util$AgdaModeVscode.Pretty.array(serialize(self)));
  console.log("rewrites: " + Util$AgdaModeVscode.Pretty.array(rewrites.map(function (param) {
                var range = param[0];
                return Editor$AgdaModeVscode.$$Range.toString(range) + " " + $$document.offsetAt(range.start).toString() + " => " + param[1];
              })));
  await Promise.all(rewrites.map(function (param) {
            return Editor$AgdaModeVscode.$$Text.replace($$document, param[0], param[1]);
          }));
}

var Module = {
  make: make$1,
  instantiateGoalsFromLoad: instantiateGoalsFromLoad,
  updatePositions: updatePositions,
  serialize: serialize
};

exports.Module = Module;
exports.make = make$1;
exports.instantiateGoalsFromLoad = instantiateGoalsFromLoad;
exports.updatePositions = updatePositions;
exports.serialize = serialize;
/* vscode Not a pure module */
