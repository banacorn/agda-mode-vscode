// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Caml = require("rescript/lib/js/caml.js");
var Vscode = require("vscode");
var Nodeos = require("node:os");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Core__List = require("@rescript/core/lib/js/src/Core__List.bs.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Core__Array = require("@rescript/core/lib/js/src/Core__Array.bs.js");
var Core__Option = require("@rescript/core/lib/js/src/Core__Option.bs.js");
var Editor$AgdaModeVscode = require("./Editor.bs.js");
var Parser$AgdaModeVscode = require("./Parser/Parser.bs.js");
var AVLTree$AgdaModeVscode = require("./Util/AVLTree.bs.js");
var Resource$AgdaModeVscode = require("./Resource.bs.js");

function overlaps(start1, end1, start2, end2) {
  return !(end1 <= start2 || end2 <= start1);
}

function containsCursor(start, end, cursorOffset) {
  if (start <= cursorOffset) {
    return cursorOffset <= end;
  } else {
    return false;
  }
}

function containsCursorExclusive(start, end, cursorOffset) {
  if (start <= cursorOffset) {
    return cursorOffset < end;
  } else {
    return false;
  }
}

function isContainedOrOverlapsEnd(_partStart, partEnd, removalStart, removalEnd) {
  if (removalEnd <= partEnd) {
    return removalStart < partEnd;
  } else {
    return false;
  }
}

function makeDecorationRanges($$document, start, end) {
  var backgroundRange = new Vscode.Range($$document.positionAt(start), $$document.positionAt(end));
  var indexRange = new Vscode.Range($$document.positionAt(end - 2 | 0), $$document.positionAt(end - 2 | 0));
  return [
          backgroundRange,
          indexRange
        ];
}

function createAndApplyDecoration(editor, start, end, index) {
  var $$document = editor.document;
  var match = makeDecorationRanges($$document, start, end);
  var background = Editor$AgdaModeVscode.Decoration.createBackground("editor.selectionHighlightBackground");
  Editor$AgdaModeVscode.Decoration.apply(editor, background, [match[0]]);
  var indexText = String(index);
  var index$1 = Editor$AgdaModeVscode.Decoration.createTextOverlay("editorLightBulb.foreground", indexText);
  Editor$AgdaModeVscode.Decoration.apply(editor, index$1, [match[1]]);
  return [
          background,
          index$1
        ];
}

function decorate(start, end, index) {
  return Core__Option.map(Vscode.window.activeTextEditor, (function (editor) {
                var match = createAndApplyDecoration(editor, start, end, index);
                return [
                        match[0],
                        match[1]
                      ];
              }));
}

function undecorate(goal) {
  Core__Option.forEach(goal.decoration, (function (param) {
          Editor$AgdaModeVscode.Decoration.destroy(param[0]);
          Editor$AgdaModeVscode.Decoration.destroy(param[1]);
        }));
}

function make(start, end, index) {
  var isQuestionMark = (start + 1 | 0) === end;
  return {
          index: index,
          start: start,
          end: end,
          decoration: isQuestionMark ? undefined : decorate(start, end, index)
        };
}

function toString(goal) {
  console.log("=== InternalGoal.toString DEBUG for goal #" + goal.index.toString() + " ===");
  console.log("Raw offsets: start=" + goal.start.toString() + ", end=" + goal.end.toString());
  var editor = Vscode.window.activeTextEditor;
  if (editor !== undefined) {
    var $$document = Caml_option.valFromOption(editor).document;
    var startPoint = $$document.positionAt(goal.start);
    var endPoint = $$document.positionAt(goal.end);
    console.log("VSCode positionAt results:");
    console.log("  startPoint - line: " + startPoint.line.toString() + ", character: " + startPoint.character.toString());
    console.log("  endPoint - line: " + endPoint.line.toString() + ", character: " + endPoint.character.toString());
    var startLine = startPoint.line + 1 | 0;
    var startColumn = startPoint.character + 1 | 0;
    var endLine = endPoint.line + 1 | 0;
    var endColumn = endPoint.character + 1 | 0;
    var result = startLine === endLine ? "#" + String(goal.index) + " [" + String(startLine) + ":" + String(startColumn) + "-" + String(endColumn) + ")" : "#" + String(goal.index) + " [" + String(startLine) + ":" + String(startColumn) + "-" + String(endLine) + ":" + String(endColumn) + ")";
    console.log("Final position string: " + result);
    return result;
  }
  var result$1 = "#" + String(goal.index) + " offset [" + String(goal.start) + "-" + String(goal.end) + ")";
  console.log("No active editor, using offsets: " + result$1);
  return result$1;
}

function makeInnerRange(goal, $$document) {
  return new Vscode.Range($$document.positionAt(goal.start + 2 | 0), $$document.positionAt(goal.end - 2 | 0));
}

function makeOuterRange(goal, $$document) {
  return new Vscode.Range($$document.positionAt(goal.start), $$document.positionAt(goal.end));
}

function make$1() {
  return {
          goals: new Map(),
          goalsWithoutIndices: new Map(),
          positions: AVLTree$AgdaModeVscode.make(),
          isBusy: undefined,
          recentlyCaseSplited: undefined
        };
}

function insertGoal(self, start, end, index) {
  var goal = make(start, end, index);
  self.goals.set(index, goal);
  AVLTree$AgdaModeVscode.insert(self.positions, start, index);
}

function removeGoal(self, goal) {
  undecorate(goal);
  self.goals.delete(goal.index);
  AVLTree$AgdaModeVscode.remove(self.positions, goal.start);
}

function redecorate(self) {
  Core__Option.forEach(Vscode.window.activeTextEditor, (function (editor) {
          Array.from(self.goals.values()).forEach(function (goal) {
                Core__Option.forEach(goal.decoration, (function (param) {
                        var $$document = editor.document;
                        var match = makeDecorationRanges($$document, goal.start, goal.end);
                        Editor$AgdaModeVscode.Decoration.apply(editor, param[0], [match[0]]);
                        Editor$AgdaModeVscode.Decoration.apply(editor, param[1], [match[1]]);
                      }));
              });
        }));
}

function destroy(self) {
  Array.from(self.goals.values()).forEach(function (goal) {
        removeGoal(self, goal);
      });
  self.goals = new Map();
  self.positions = AVLTree$AgdaModeVscode.make();
}

function size(self) {
  return self.goals.size;
}

function serializeGoals(self) {
  console.log("=== Goals.serializeGoals DEBUG START ===");
  var goalArray = Array.from(self.goals.values());
  console.log("Number of goals: " + goalArray.length.toString());
  var sortedGoals = goalArray.toSorted(function (x, y) {
        return Caml.int_compare(x.index, y.index);
      });
  console.log("Goal details before serialization:");
  sortedGoals.forEach(function (goal) {
        console.log("  Goal #" + goal.index.toString() + ": offsets " + goal.start.toString() + "-" + goal.end.toString());
      });
  var result = sortedGoals.map(toString);
  console.log("Serialized goal positions:");
  result.forEach(function (pos) {
        console.log("  " + pos);
      });
  console.log("=== Goals.serializeGoals DEBUG END ===");
  return result;
}

function serializeGoalsWithoutIndices(self) {
  return Array.from(self.goalsWithoutIndices.entries()).map(function (param) {
              return "(" + String(param[0]) + ", " + String(param[1]) + ")";
            });
}

function serializePositions(self) {
  return AVLTree$AgdaModeVscode.toArray(self.positions).map(function (param) {
              return "(" + String(param[0]) + ", " + String(param[1]) + ")";
            });
}

function toString$1(self) {
  var goals = serializeGoals(self).join("\n");
  var goalsWithoutIndices = serializeGoalsWithoutIndices(self).join(", ");
  var positions = serializePositions(self).join(", ");
  return "Goals:\n" + goals + "\nGoals without indices: [" + goalsWithoutIndices + "]\nPositions: [" + positions + "]\nBusy: " + (
          Core__Option.isSome(self.isBusy) ? "true" : "false"
        );
}

function removeGoalByIndex(self, index) {
  var goal = self.goals.get(index);
  if (goal !== undefined) {
    return removeGoal(self, goal);
  }
  
}

function isBusy(self) {
  return Core__Option.isSome(self.isBusy);
}

function setBusy(self) {
  var match = self.isBusy;
  if (match !== undefined) {
    return ;
  } else {
    self.isBusy = Caml_option.some(Resource$AgdaModeVscode.make());
    return ;
  }
}

function waitUntilNotBusy(self) {
  var resource = self.isBusy;
  if (resource !== undefined) {
    return Resource$AgdaModeVscode.get(Caml_option.valFromOption(resource));
  } else {
    return Promise.resolve();
  }
}

function read(goal, $$document) {
  var innerRange = makeInnerRange(goal, $$document);
  return Editor$AgdaModeVscode.$$Text.get($$document, innerRange).trim();
}

function getGoalByIndex(self, index) {
  return Core__Option.map(self.goals.get(index), (function (goal) {
                return {
                        index: goal.index,
                        indexString: goal.index.toString(),
                        start: goal.start,
                        end: goal.end
                      };
              }));
}

async function modify(self, $$document, index, f) {
  var goal = self.goals.get(index);
  if (goal === undefined) {
    return ;
  }
  var innerRange = makeInnerRange(goal, $$document);
  var goalContent = read(goal, $$document);
  await Editor$AgdaModeVscode.$$Text.replace($$document, innerRange, " " + f(goalContent) + " ");
}

async function removeBoundaryAndDestroy(self, $$document, index) {
  var goal = self.goals.get(index);
  if (goal === undefined) {
    return true;
  }
  var outerRange = makeOuterRange(goal, $$document);
  var content = read(goal, $$document);
  if (await Editor$AgdaModeVscode.$$Text.replace($$document, outerRange, content)) {
    removeGoal(self, goal);
    return true;
  } else {
    return false;
  }
}

function getGoalAtCursor(self, editor) {
  var $$document = editor.document;
  var cursorOffset = $$document.offsetAt(Editor$AgdaModeVscode.Cursor.get(editor));
  return Core__Option.flatMap(AVLTree$AgdaModeVscode.lowerBound(self.positions, cursorOffset), (function (index) {
                var goal = self.goals.get(index);
                if (goal !== undefined && containsCursor(goal.start, goal.end, cursorOffset)) {
                  return {
                          index: goal.index,
                          indexString: goal.index.toString(),
                          start: goal.start,
                          end: goal.end
                        };
                }
                
              }));
}

function setCursor(editor, goal) {
  var $$document = editor.document;
  var spaceInsideBoundaries = (goal.end - goal.start | 0) - 4 | 0;
  var offset = spaceInsideBoundaries === 0 ? goal.start + 2 | 0 : goal.start + 3 | 0;
  var position = $$document.positionAt(offset);
  Editor$AgdaModeVscode.Cursor.set(editor, position);
  var range = makeOuterRange(goal, $$document);
  editor.revealRange(range, undefined);
}

function setCursorByIndex(self, editor, index) {
  var goal = self.goals.get(index);
  if (goal !== undefined) {
    return setCursor(editor, goal);
  }
  
}

function clear(self) {
  Array.from(self.goals.values()).forEach(undecorate);
  self.goals = new Map();
  self.positions = AVLTree$AgdaModeVscode.make();
}

function updateGoalPositionByIndex(self, index, deltaStart, deltaEnd) {
  var goal = self.goals.get(index);
  if (goal !== undefined) {
    var newStart = goal.start + deltaStart | 0;
    var newEnd = goal.end + deltaEnd | 0;
    AVLTree$AgdaModeVscode.remove(self.positions, goal.start);
    var wasQuestionMark = (goal.start + 1 | 0) === goal.end;
    var isQuestionMark = (newStart + 1 | 0) === newEnd;
    var isQuestionMarkExpansion = wasQuestionMark && !isQuestionMark;
    if (isQuestionMarkExpansion) {
      removeGoal(self, goal);
      return insertGoal(self, newStart, newEnd, goal.index);
    }
    var updatedGoal = {
      index: goal.index,
      start: newStart,
      end: newEnd,
      decoration: goal.decoration
    };
    AVLTree$AgdaModeVscode.insert(self.positions, newStart, updatedGoal.index);
    self.goals.set(updatedGoal.index, updatedGoal);
    return ;
  }
  
}

function addLeftBoundary(map, index, delta) {
  var match = map.get(index);
  if (match !== undefined) {
    if (match.TAG === "IsQuestionMark") {
      return map;
    }
    var tmp = match._0;
    if (typeof tmp === "object") {
      return map;
    }
    if (tmp === "Damaged") {
      return map;
    }
    map.set(index, {
          TAG: "IsHole",
          _0: {
            TAG: "Intact",
            _0: delta
          },
          _1: match._1
        });
    return map;
  } else {
    map.set(index, {
          TAG: "IsHole",
          _0: {
            TAG: "Intact",
            _0: delta
          },
          _1: "Unknown"
        });
    return map;
  }
}

function markLeftBoundaryDamaged(map, index) {
  var match = map.get(index);
  if (match !== undefined) {
    if (match.TAG === "IsQuestionMark") {
      return map;
    }
    map.set(index, {
          TAG: "IsHole",
          _0: "Damaged",
          _1: match._1
        });
    return map;
  }
  map.set(index, {
        TAG: "IsHole",
        _0: "Damaged",
        _1: "Unknown"
      });
  return map;
}

function addRightBoundary(map, index, delta) {
  var match = map.get(index);
  if (match !== undefined) {
    if (match.TAG === "IsQuestionMark") {
      return map;
    }
    var tmp = match._1;
    if (typeof tmp === "object") {
      return map;
    }
    if (tmp === "Damaged") {
      return map;
    }
    map.set(index, {
          TAG: "IsHole",
          _0: match._0,
          _1: {
            TAG: "Intact",
            _0: delta
          }
        });
    return map;
  } else {
    map.set(index, {
          TAG: "IsHole",
          _0: "Unknown",
          _1: {
            TAG: "Intact",
            _0: delta
          }
        });
    return map;
  }
}

function markRightBoundaryDamaged(map, index) {
  var match = map.get(index);
  if (match !== undefined) {
    if (match.TAG === "IsQuestionMark") {
      return map;
    }
    map.set(index, {
          TAG: "IsHole",
          _0: match._0,
          _1: "Damaged"
        });
    return map;
  }
  map.set(index, {
        TAG: "IsHole",
        _0: "Unknown",
        _1: "Damaged"
      });
  return map;
}

function addQuestionMark(map, index, offset) {
  var match = map.get(index);
  if (match !== undefined) {
    return map;
  } else {
    map.set(index, {
          TAG: "IsQuestionMark",
          _0: offset
        });
    return map;
  }
}

function goalToParts(goal) {
  if ((goal.start + 1 | 0) === goal.end) {
    return [[
              goal.index,
              goal.start,
              "QuestionMark"
            ]];
  } else {
    return [
            [
              goal.index,
              goal.start,
              "LeftBoundary"
            ],
            [
              goal.index,
              goal.end - 2 | 0,
              "RightBoundary"
            ]
          ];
  }
}

function caseAnalysis(removalStart, removalEnd, start, end) {
  if (removalStart === start && removalEnd === start) {
    return "Case1";
  } else if (removalStart < start) {
    if (overlaps(removalStart, removalEnd, start, end)) {
      if (removalEnd <= end) {
        return "Case2";
      } else {
        return "Case3";
      }
    } else {
      return "Case1";
    }
  } else if (isContainedOrOverlapsEnd(start, end, removalStart, removalEnd)) {
    return "Case4";
  } else if (removalStart < end) {
    return "Case5";
  } else {
    return "Case6";
  }
}

async function scanAllGoals(self, editor, changes) {
  var $$document = editor.document;
  var changes$1 = Core__List.fromArray(changes);
  var go = function (_accMap, _accDeltaBeforePart, _accDeltaAfterPart, _parts, _changes) {
    while(true) {
      var changes = _changes;
      var parts = _parts;
      var accDeltaAfterPart = _accDeltaAfterPart;
      var accDeltaBeforePart = _accDeltaBeforePart;
      var accMap = _accMap;
      if (!parts) {
        return accMap;
      }
      var parts$1 = parts.tl;
      var match = parts.hd;
      var part = match[2];
      var start = match[1];
      var index = match[0];
      if (changes) {
        var changes$1 = changes.tl;
        var change = changes.hd;
        var removalStart = change.offset;
        var removalEnd = change.offset + change.removed | 0;
        var delta = change.inserted - change.removed | 0;
        var end;
        switch (part) {
          case "LeftBoundary" :
          case "RightBoundary" :
              end = start + 2 | 0;
              break;
          case "QuestionMark" :
              end = start + 1 | 0;
              break;
          
        }
        var match$1 = caseAnalysis(removalStart, removalEnd, start, end);
        switch (match$1) {
          case "Case1" :
              _changes = changes$1;
              _parts = {
                hd: [
                  index,
                  start,
                  part
                ],
                tl: parts$1
              };
              _accDeltaAfterPart = accDeltaAfterPart + delta | 0;
              _accDeltaBeforePart = accDeltaBeforePart + delta | 0;
              continue ;
          case "Case2" :
              var tmp;
              switch (part) {
                case "LeftBoundary" :
                    tmp = markLeftBoundaryDamaged(accMap, index);
                    break;
                case "RightBoundary" :
                    tmp = markRightBoundaryDamaged(accMap, index);
                    break;
                case "QuestionMark" :
                    tmp = accMap;
                    break;
                
              }
              _changes = changes$1;
              _parts = {
                hd: [
                  index,
                  start,
                  part
                ],
                tl: parts$1
              };
              _accDeltaAfterPart = accDeltaAfterPart + delta | 0;
              _accMap = tmp;
              continue ;
          case "Case3" :
              var tmp$1;
              switch (part) {
                case "LeftBoundary" :
                    tmp$1 = markLeftBoundaryDamaged(accMap, index);
                    break;
                case "RightBoundary" :
                    tmp$1 = markRightBoundaryDamaged(accMap, index);
                    break;
                case "QuestionMark" :
                    tmp$1 = accMap;
                    break;
                
              }
              _changes = {
                hd: change,
                tl: changes$1
              };
              _parts = parts$1;
              _accMap = tmp$1;
              continue ;
          case "Case4" :
              switch (part) {
                case "LeftBoundary" :
                    _changes = changes$1;
                    _parts = {
                      hd: [
                        index,
                        start,
                        part
                      ],
                      tl: parts$1
                    };
                    _accDeltaAfterPart = accDeltaAfterPart + delta | 0;
                    _accMap = markLeftBoundaryDamaged(accMap, index);
                    continue ;
                case "RightBoundary" :
                    _changes = changes$1;
                    _parts = {
                      hd: [
                        index,
                        start,
                        part
                      ],
                      tl: parts$1
                    };
                    _accDeltaAfterPart = accDeltaAfterPart + delta | 0;
                    _accMap = markRightBoundaryDamaged(accMap, index);
                    continue ;
                case "QuestionMark" :
                    _changes = changes$1;
                    _parts = parts$1;
                    _accDeltaAfterPart = accDeltaAfterPart + delta | 0;
                    _accDeltaBeforePart = accDeltaAfterPart + delta | 0;
                    _accMap = addRightBoundary(addLeftBoundary(accMap, index, accDeltaBeforePart), index, accDeltaBeforePart + 6 | 0);
                    continue ;
                
              }
          case "Case5" :
              var tmp$2;
              switch (part) {
                case "LeftBoundary" :
                    tmp$2 = markLeftBoundaryDamaged(accMap, index);
                    break;
                case "RightBoundary" :
                    tmp$2 = markRightBoundaryDamaged(accMap, index);
                    break;
                case "QuestionMark" :
                    tmp$2 = accMap;
                    break;
                
              }
              _changes = {
                hd: change,
                tl: changes$1
              };
              _parts = parts$1;
              _accMap = tmp$2;
              continue ;
          case "Case6" :
              var tmp$3;
              switch (part) {
                case "LeftBoundary" :
                    tmp$3 = addLeftBoundary(accMap, index, accDeltaBeforePart);
                    break;
                case "RightBoundary" :
                    tmp$3 = addRightBoundary(accMap, index, accDeltaBeforePart);
                    break;
                case "QuestionMark" :
                    tmp$3 = addQuestionMark(accMap, index, start + accDeltaBeforePart | 0);
                    break;
                
              }
              _changes = {
                hd: change,
                tl: changes$1
              };
              _parts = parts$1;
              _accDeltaBeforePart = accDeltaAfterPart;
              _accMap = tmp$3;
              continue ;
          
        }
      } else {
        var tmp$4;
        switch (part) {
          case "LeftBoundary" :
              tmp$4 = addLeftBoundary(accMap, index, accDeltaBeforePart);
              break;
          case "RightBoundary" :
              tmp$4 = addRightBoundary(accMap, index, accDeltaBeforePart);
              break;
          case "QuestionMark" :
              tmp$4 = addQuestionMark(accMap, index, start + accDeltaBeforePart | 0);
              break;
          
        }
        _parts = parts$1;
        _accDeltaBeforePart = accDeltaAfterPart;
        _accMap = tmp$4;
        continue ;
      }
    };
  };
  var parts = Core__List.fromArray(Core__Array.filterMap(AVLTree$AgdaModeVscode.toArray(self.positions), (function (param) {
                return Core__Option.map(self.goals.get(param[1]), goalToParts);
              })).flat());
  var map = go(new Map(), 0, 0, parts, changes$1);
  var rewrites = Core__Array.filterMap(Array.from(map.entries()), (function (param) {
          var state = param[1];
          var index = param[0];
          if (state.TAG === "IsQuestionMark") {
            var offset = state._0;
            return [
                    new Vscode.Range($$document.positionAt(offset), $$document.positionAt(offset + 1 | 0)),
                    "{!   !}"
                  ];
          }
          var a = state._0;
          if (typeof a !== "object") {
            a === "Damaged";
          } else {
            var b = state._1;
            if (typeof b !== "object") {
              b === "Damaged";
            } else {
              updateGoalPositionByIndex(self, index, a._0, b._0);
              return ;
            }
          }
          removeGoalByIndex(self, index);
        }));
  if (rewrites.length === 0) {
    var resource = self.isBusy;
    if (resource !== undefined) {
      self.isBusy = undefined;
      return Resource$AgdaModeVscode.set(Caml_option.valFromOption(resource), undefined);
    } else {
      return ;
    }
  }
  var originalCursorPosition = Editor$AgdaModeVscode.Cursor.get(editor);
  setBusy(self);
  await Editor$AgdaModeVscode.$$Text.batchReplace($$document, rewrites);
  var cursorWasWithinRewrites = rewrites.some(function (param) {
        return param[0].contains(originalCursorPosition);
      });
  if (!cursorWasWithinRewrites) {
    return ;
  }
  var goal = getGoalAtCursor(self, editor);
  if (goal !== undefined) {
    return setCursorByIndex(self, editor, goal.index);
  }
  
}

async function resetGoalIndicesOnLoad(self, editor, indices) {
  clear(self);
  var positionsArray = Array.from(self.goalsWithoutIndices.entries());
  positionsArray.forEach(function (param, i) {
        var index = indices[i];
        if (index !== undefined) {
          return insertGoal(self, param[0], param[1], index);
        }
        
      });
  self.goalsWithoutIndices = new Map();
  return await scanAllGoals(self, editor, []);
}

async function resetGoalIndicesOnRefineOrGive(self, editor, indices) {
  var collectExistingGoalPositions = function () {
    return new Map(Array.from(self.goals.values()).map(function (goal) {
                    return [
                            goal.start,
                            [
                              goal.end,
                              goal
                            ]
                          ];
                  }));
  };
  var mergeGoalPositions = function (existingPositions) {
    self.goalsWithoutIndices.forEach(function (end, start) {
          existingPositions.set(start, [
                end,
                undefined
              ]);
        });
    return existingPositions;
  };
  var sortPositionsByOffset = function (positions) {
    return Array.from(positions.entries()).toSorted(function (param, param$1) {
                return Caml.int_compare(param[0], param$1[0]);
              });
  };
  var assignIndices = function (sortedPositions) {
    sortedPositions.forEach(function (param, i) {
          var index = indices[i];
          if (index !== undefined) {
            return insertGoal(self, param[0], param[1][0], index);
          }
          
        });
  };
  var existingPositions = collectExistingGoalPositions();
  var mergedPositions = mergeGoalPositions(existingPositions);
  var sortedPositions = sortPositionsByOffset(mergedPositions);
  clear(self);
  assignIndices(sortedPositions);
  self.goalsWithoutIndices = new Map();
  return await scanAllGoals(self, editor, []);
}

function addGoalPositions(self, positions) {
  positions.forEach(function (param) {
        self.goalsWithoutIndices.set(param[0], param[1]);
      });
}

function getGoalPositionByIndex(self, index) {
  var goal = self.goals.get(index);
  if (goal !== undefined) {
    return [
            goal.start,
            goal.end
          ];
  }
  
}

function parseGoalPositionsFromRefine(raw) {
  var raw$1 = Parser$AgdaModeVscode.splitToLines(raw).join(Nodeos.EOL);
  var delimiters = [
    " ",
    "\t",
    "\n",
    "\r",
    "(",
    ")",
    "{",
    "}",
    "_",
    ";",
    ".",
    "\\",
    "\"",
    "@"
  ];
  var findQuestionMarks = function (text, offset) {
    var index = text.indexOf("?");
    if (index === -1) {
      return [];
    }
    var actualPosition = offset + index | 0;
    var beforeChar = actualPosition > 0 ? raw$1.charAt(actualPosition - 1 | 0) : undefined;
    var afterChar = actualPosition < (raw$1.length - 1 | 0) ? raw$1.charAt(actualPosition + 1 | 0) : undefined;
    var beforeOk = beforeChar !== undefined ? delimiters.includes(beforeChar) : true;
    var afterOk = afterChar !== undefined ? delimiters.includes(afterChar) : true;
    var remainingText = text.slice(index + 1 | 0);
    var nextResults = findQuestionMarks(remainingText, (offset + index | 0) + 1 | 0);
    if (beforeOk && afterOk) {
      return Belt_Array.concatMany([
                  [[
                      actualPosition,
                      actualPosition + 1 | 0
                    ]],
                  nextResults
                ]);
    } else {
      return nextResults;
    }
  };
  return findQuestionMarks(raw$1, 0);
}

function jumpToTheNextGoal(self, editor) {
  var $$document = editor.document;
  var cursorOffset = $$document.offsetAt(Editor$AgdaModeVscode.Cursor.get(editor));
  var index = AVLTree$AgdaModeVscode.upperBound(self.positions, cursorOffset);
  var goal = index !== undefined ? self.goals.get(index) : self.goals.get(0);
  if (goal !== undefined) {
    return setCursor(editor, goal);
  }
  
}

function jumpToThePreviousGoal(self, editor) {
  var $$document = editor.document;
  var cursorOffset = $$document.offsetAt(Editor$AgdaModeVscode.Cursor.get(editor));
  var index = AVLTree$AgdaModeVscode.lowerBound(self.positions, cursorOffset);
  var goal;
  if (index !== undefined) {
    var goal$1 = self.goals.get(index);
    if (goal$1 !== undefined) {
      if (containsCursorExclusive(goal$1.start, goal$1.end, cursorOffset)) {
        var previousIndex = index === 0 ? self.goals.size - 1 | 0 : index - 1 | 0;
        goal = self.goals.get(previousIndex);
      } else {
        goal = goal$1;
      }
    } else {
      goal = undefined;
    }
  } else {
    goal = self.goals.get(self.goals.size - 1 | 0);
  }
  if (goal !== undefined) {
    return setCursor(editor, goal);
  }
  
}

function markAsCaseSplited(self, goal) {
  self.recentlyCaseSplited = goal;
}

function getRecentlyCaseSplited(self) {
  return Core__Option.map(self.recentlyCaseSplited, (function (goal) {
                return {
                        index: goal.index,
                        indexString: goal.index.toString(),
                        start: goal.start,
                        end: goal.end
                      };
              }));
}

var Module = {
  make: make$1,
  redecorate: redecorate,
  destroy: destroy,
  size: size,
  resetGoalIndicesOnLoad: resetGoalIndicesOnLoad,
  resetGoalIndicesOnRefineOrGive: resetGoalIndicesOnRefineOrGive,
  addGoalPositions: addGoalPositions,
  getGoalPositionByIndex: getGoalPositionByIndex,
  parseGoalPositionsFromRefine: parseGoalPositionsFromRefine,
  removeGoalByIndex: removeGoalByIndex,
  scanAllGoals: scanAllGoals,
  getGoalByIndex: getGoalByIndex,
  modify: modify,
  removeBoundaryAndDestroy: removeBoundaryAndDestroy,
  getGoalAtCursor: getGoalAtCursor,
  setCursorByIndex: setCursorByIndex,
  jumpToTheNextGoal: jumpToTheNextGoal,
  jumpToThePreviousGoal: jumpToThePreviousGoal,
  isBusy: isBusy,
  waitUntilNotBusy: waitUntilNotBusy,
  markAsCaseSplited: markAsCaseSplited,
  getRecentlyCaseSplited: getRecentlyCaseSplited,
  serializeGoals: serializeGoals,
  toString: toString$1
};

exports.Module = Module;
exports.make = make$1;
exports.redecorate = redecorate;
exports.destroy = destroy;
exports.size = size;
exports.resetGoalIndicesOnLoad = resetGoalIndicesOnLoad;
exports.resetGoalIndicesOnRefineOrGive = resetGoalIndicesOnRefineOrGive;
exports.addGoalPositions = addGoalPositions;
exports.getGoalPositionByIndex = getGoalPositionByIndex;
exports.parseGoalPositionsFromRefine = parseGoalPositionsFromRefine;
exports.removeGoalByIndex = removeGoalByIndex;
exports.scanAllGoals = scanAllGoals;
exports.getGoalByIndex = getGoalByIndex;
exports.modify = modify;
exports.removeBoundaryAndDestroy = removeBoundaryAndDestroy;
exports.getGoalAtCursor = getGoalAtCursor;
exports.setCursorByIndex = setCursorByIndex;
exports.jumpToTheNextGoal = jumpToTheNextGoal;
exports.jumpToThePreviousGoal = jumpToThePreviousGoal;
exports.isBusy = isBusy;
exports.waitUntilNotBusy = waitUntilNotBusy;
exports.markAsCaseSplited = markAsCaseSplited;
exports.getRecentlyCaseSplited = getRecentlyCaseSplited;
exports.serializeGoals = serializeGoals;
exports.toString = toString$1;
/* vscode Not a pure module */
