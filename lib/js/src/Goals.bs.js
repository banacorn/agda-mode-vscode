// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Caml = require("rescript/lib/js/caml.js");
var Vscode = require("vscode");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Core__List = require("@rescript/core/lib/js/src/Core__List.bs.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Core__Array = require("@rescript/core/lib/js/src/Core__Array.bs.js");
var Core__Option = require("@rescript/core/lib/js/src/Core__Option.bs.js");
var Core__String = require("@rescript/core/lib/js/src/Core__String.bs.js");
var Editor$AgdaModeVscode = require("./Editor.bs.js");
var AVLTree$AgdaModeVscode = require("./Util/AVLTree.bs.js");
var Resource$AgdaModeVscode = require("./Resource.bs.js");
var BinarySearchTree = require("@datastructures-js/binary-search-tree");

function decorate(editor, start, end, index) {
  var $$document = editor.document;
  var backgroundRange = new Vscode.Range($$document.positionAt(start), $$document.positionAt(end));
  var background = Editor$AgdaModeVscode.Decoration.highlightBackground(editor, "editor.selectionHighlightBackground", [backgroundRange]);
  var indexText = String(index);
  var indexRange = new Vscode.Range($$document.positionAt(start), $$document.positionAt(end - 2 | 0));
  var index$1 = Editor$AgdaModeVscode.Decoration.overlayText(editor, "editorLightBulb.foreground", indexText, indexRange);
  return [
          background,
          index$1
        ];
}

function make(editor, start, end, index) {
  var match = decorate(editor, start, end, index);
  return {
          index: index,
          start: start,
          end: end,
          decorationBackground: match[0],
          decorationIndex: match[1]
        };
}

function toString(goal) {
  return "#" + String(goal.index) + " [" + String(goal.start) + "-" + String(goal.end) + ")";
}

function makeInnerRange(goal, $$document) {
  return new Vscode.Range($$document.positionAt(goal.start + 2 | 0), $$document.positionAt(goal.end - 2 | 0));
}

function makeOuterRange(goal, $$document) {
  return new Vscode.Range($$document.positionAt(goal.start), $$document.positionAt(goal.end));
}

function make$1() {
  return {
          goals: new Map(),
          goalsWithoutIndices: new Map(),
          positions: new BinarySearchTree.BinarySearchTree(),
          isBusy: undefined,
          recentlyCaseSplited: undefined,
          goalPositionsFromRefine: []
        };
}

function size(self) {
  return self.goals.size;
}

function destroyGoal(self, goal) {
  Editor$AgdaModeVscode.Decoration.destroy(goal.decorationBackground);
  Editor$AgdaModeVscode.Decoration.destroy(goal.decorationIndex);
  self.goals.delete(goal.index);
  self.positions.remove(goal.start);
}

function destroyGoalByIndex(self, index) {
  var goal = self.goals.get(index);
  if (goal !== undefined) {
    return destroyGoal(self, goal);
  }
  
}

function isBusy(self) {
  return Core__Option.isSome(self.isBusy);
}

function setBusy(self) {
  var match = self.isBusy;
  if (match !== undefined) {
    return ;
  } else {
    self.isBusy = Caml_option.some(Resource$AgdaModeVscode.make());
    return ;
  }
}

function waitUntilNotBusy(self) {
  var resource = self.isBusy;
  if (resource !== undefined) {
    return Resource$AgdaModeVscode.get(Caml_option.valFromOption(resource));
  } else {
    return Promise.resolve();
  }
}

function serialize(self) {
  return Array.from(self.goals.values()).toSorted(function (x, y) {
                return Caml.int_compare(x.index, y.index);
              }).map(toString);
}

function read(goal, $$document) {
  var innerRange = makeInnerRange(goal, $$document);
  return Editor$AgdaModeVscode.$$Text.get($$document, innerRange).trim();
}

function getGoalByIndex(self, index) {
  return Core__Option.map(self.goals.get(index), (function (goal) {
                return {
                        index: goal.index,
                        indexString: goal.index.toString(),
                        start: goal.start,
                        end: goal.end
                      };
              }));
}

async function modify(self, $$document, index, f) {
  var goal = self.goals.get(index);
  if (goal === undefined) {
    return ;
  }
  var innerRange = makeInnerRange(goal, $$document);
  var goalContent = read(goal, $$document);
  await Editor$AgdaModeVscode.$$Text.replace($$document, innerRange, " " + f(goalContent) + " ");
}

async function removeBoundaryAndDestroy(self, $$document, index) {
  var goal = self.goals.get(index);
  if (goal === undefined) {
    return true;
  }
  var outerRange = makeOuterRange(goal, $$document);
  var content = read(goal, $$document);
  if (await Editor$AgdaModeVscode.$$Text.replace($$document, outerRange, content)) {
    destroyGoal(self, goal);
    return true;
  } else {
    return false;
  }
}

function getGoalAtCursor(self, editor) {
  var $$document = editor.document;
  var cursorOffset = $$document.offsetAt(Editor$AgdaModeVscode.Cursor.get(editor));
  return Core__Option.flatMap(AVLTree$AgdaModeVscode.lowerBound(self.positions, cursorOffset), (function (index) {
                var goal = self.goals.get(index);
                if (goal !== undefined && cursorOffset >= goal.start && cursorOffset < goal.end) {
                  return {
                          index: goal.index,
                          indexString: goal.index.toString(),
                          start: goal.start,
                          end: goal.end
                        };
                }
                
              }));
}

function clear(self) {
  Array.from(self.goals.values()).forEach(function (goal) {
        Editor$AgdaModeVscode.Decoration.destroy(goal.decorationBackground);
        Editor$AgdaModeVscode.Decoration.destroy(goal.decorationIndex);
      });
  self.goals = new Map();
  self.positions = new BinarySearchTree.BinarySearchTree();
}

function merge(x, y) {
  if (typeof x !== "object" || typeof y !== "object") {
    return "Destroyed";
  } else {
    return {
            TAG: "UpdatePositionAndRewrite",
            _0: Belt_Array.concatMany([
                  x._0,
                  y._0
                ]),
            _1: Belt_Array.concatMany([
                  x._1,
                  y._1
                ]),
            [Symbol.for("name")]: "UpdatePositionAndRewrite"
          };
  }
}

function insertMany(map, goal, actions) {
  return Core__Array.reduce(actions, map, (function (map, action) {
                var index = goal.index;
                switch (action.TAG) {
                  case "Rewrite" :
                      var text = action._1;
                      var range = action._0;
                      var state = map.get(index);
                      if (state !== undefined) {
                        map.set(index, merge(state, {
                                  TAG: "UpdatePositionAndRewrite",
                                  _0: [],
                                  _1: [[
                                      range,
                                      text
                                    ]],
                                  [Symbol.for("name")]: "UpdatePositionAndRewrite"
                                }));
                      } else {
                        map.set(index, {
                              TAG: "UpdatePositionAndRewrite",
                              _0: [],
                              _1: [[
                                  range,
                                  text
                                ]],
                              [Symbol.for("name")]: "UpdatePositionAndRewrite"
                            });
                      }
                      return map;
                  case "Destroy" :
                      map.set(index, "Destroyed");
                      return map;
                  case "UpdatePosition" :
                      var startDelta = action._1;
                      if (startDelta === 0 && action._2 === 0) {
                        return map;
                      }
                      var redecorate = action._3;
                      var endDelta = action._2;
                      var state$1 = map.get(index);
                      if (state$1 !== undefined) {
                        map.set(index, merge(state$1, {
                                  TAG: "UpdatePositionAndRewrite",
                                  _0: [[
                                      startDelta,
                                      endDelta,
                                      redecorate
                                    ]],
                                  _1: [],
                                  [Symbol.for("name")]: "UpdatePositionAndRewrite"
                                }));
                      } else {
                        map.set(index, {
                              TAG: "UpdatePositionAndRewrite",
                              _0: [[
                                  startDelta,
                                  endDelta,
                                  redecorate
                                ]],
                              _1: [],
                              [Symbol.for("name")]: "UpdatePositionAndRewrite"
                            });
                      }
                      return map;
                  
                }
              }));
}

async function scanAllGoals(self, editor, changes) {
  var $$document = editor.document;
  var changes$1 = Core__List.fromArray(changes);
  var scanGoal = function (delta, goal, deltaStart, deltaEnd, destroyed) {
    console.log("deltaStart: " + deltaStart.toString() + ", deltaEnd: " + deltaEnd.toString() + ", delta: " + delta.toString() + ", goal: " + toString(goal));
    var range = new Vscode.Range($$document.positionAt((goal.start + delta | 0) + deltaStart | 0), $$document.positionAt((goal.end + delta | 0) + deltaEnd | 0));
    var goalText = Editor$AgdaModeVscode.$$Text.get($$document, range);
    var goalTextLength = ((goal.end - goal.start | 0) + deltaEnd | 0) - deltaStart | 0;
    var leftBoundary = Core__String.indexOfOpt(goalText, "{!");
    var rightBoundary = Core__String.lastIndexOfOpt(goalText, "!}");
    var goalIsIntact = Core__Option.isSome(rightBoundary) && Core__Option.isSome(leftBoundary);
    var isQuestionMarkExpansion = destroyed && (goal.start + 1 | 0) === goal.end;
    var match = leftBoundary !== undefined && rightBoundary !== undefined && !(leftBoundary === 0 && (rightBoundary + 2 | 0) === goalText.length) ? [
        -leftBoundary | 0,
        (rightBoundary + 2 | 0) - goalText.length | 0
      ] : [
        0,
        0
      ];
    if (goalText === "?") {
      return [{
                TAG: "Rewrite",
                _0: range,
                _1: "{!   !}",
                [Symbol.for("name")]: "Rewrite"
              }];
    }
    if (destroyed && !isQuestionMarkExpansion) {
      return [{
                TAG: "Destroy",
                _0: goal,
                [Symbol.for("name")]: "Destroy"
              }];
    }
    if (goalIsIntact) {
      return [{
                TAG: "UpdatePosition",
                _0: goal,
                _1: (delta + deltaStart | 0) + match[0] | 0,
                _2: (delta + deltaEnd | 0) + match[1] | 0,
                _3: isQuestionMarkExpansion,
                [Symbol.for("name")]: "UpdatePosition"
              }];
    }
    if (false && goalText.startsWith("{!")) {
      var match$1 = goalText.charAt(goalTextLength - 1 | 0);
      switch (match$1) {
        case "!" :
            return [
                    {
                      TAG: "UpdatePosition",
                      _0: goal,
                      _1: delta + deltaStart | 0,
                      _2: (delta + deltaEnd | 0) + 1 | 0,
                      _3: false,
                      [Symbol.for("name")]: "UpdatePosition"
                    },
                    {
                      TAG: "Rewrite",
                      _0: range,
                      _1: goalText + "}",
                      [Symbol.for("name")]: "Rewrite"
                    }
                  ];
        case "}" :
            return [
                    {
                      TAG: "UpdatePosition",
                      _0: goal,
                      _1: delta + deltaStart | 0,
                      _2: (delta + deltaEnd | 0) + 1 | 0,
                      _3: false,
                      [Symbol.for("name")]: "UpdatePosition"
                    },
                    {
                      TAG: "Rewrite",
                      _0: range,
                      _1: goalText.substring(0, goalTextLength - 1 | 0) + "!}",
                      [Symbol.for("name")]: "Rewrite"
                    }
                  ];
        default:
          return [{
                    TAG: "UpdatePosition",
                    _0: goal,
                    _1: delta + deltaStart | 0,
                    _2: delta + deltaEnd | 0,
                    _3: false,
                    [Symbol.for("name")]: "UpdatePosition"
                  }];
      }
    } else if (false && goalText.endsWith("!}")) {
      var match$2 = goalText.charAt(0);
      switch (match$2) {
        case "!" :
            return [
                    {
                      TAG: "UpdatePosition",
                      _0: goal,
                      _1: delta + deltaStart | 0,
                      _2: (delta + deltaEnd | 0) + 1 | 0,
                      _3: false,
                      [Symbol.for("name")]: "UpdatePosition"
                    },
                    {
                      TAG: "Rewrite",
                      _0: range,
                      _1: "{" + goalText,
                      [Symbol.for("name")]: "Rewrite"
                    }
                  ];
        case "{" :
            return [
                    {
                      TAG: "UpdatePosition",
                      _0: goal,
                      _1: delta + deltaStart | 0,
                      _2: (delta + deltaEnd | 0) + 1 | 0,
                      _3: false,
                      [Symbol.for("name")]: "UpdatePosition"
                    },
                    {
                      TAG: "Rewrite",
                      _0: range,
                      _1: "{!" + goalText.substring(1),
                      [Symbol.for("name")]: "Rewrite"
                    }
                  ];
        default:
          return [{
                    TAG: "UpdatePosition",
                    _0: goal,
                    _1: delta + deltaStart | 0,
                    _2: delta + deltaEnd | 0,
                    _3: false,
                    [Symbol.for("name")]: "UpdatePosition"
                  }];
      }
    } else {
      console.log("Goal text is not intact: " + goalText);
      return [{
                TAG: "Destroy",
                _0: goal,
                [Symbol.for("name")]: "Destroy"
              }];
    }
  };
  var go = function (_delta, _goals, _changes) {
    while(true) {
      var changes = _changes;
      var goals = _goals;
      var delta = _delta;
      if (!goals) {
        return new Map();
      }
      var goals$1 = goals.tl;
      var goal = goals.hd;
      if (changes) {
        var changes$1 = changes.tl;
        var change = changes.hd;
        var removalStart = change.offset;
        var removalEnd = change.offset + change.removed | 0;
        if (removalEnd < goal.start) {
          var delta$1 = (delta + change.inserted | 0) - change.removed | 0;
          _changes = changes$1;
          _goals = {
            hd: goal,
            tl: goals$1
          };
          _delta = delta$1;
          continue ;
        }
        if (removalStart >= goal.end) {
          _changes = {
            hd: change,
            tl: changes$1
          };
          _goals = goals$1;
          continue ;
        }
        if (goal.start >= removalStart && goal.end <= removalEnd) {
          var deltaStart = removalStart - goal.start | 0;
          var deltaEnd = (deltaStart + change.inserted | 0) - change.removed | 0;
          var actions = scanGoal(delta, goal, deltaStart, deltaEnd, true);
          var delta$p = (delta + change.inserted | 0) - change.removed | 0;
          return insertMany(go(delta$p, goals$1, changes$1), goal, actions);
        }
        if (removalStart < goal.start) {
          var deltaStart$1 = removalStart - goal.start | 0;
          var deltaEnd$1 = change.inserted - change.removed | 0;
          var actions$1 = scanGoal(delta, goal, deltaStart$1, deltaEnd$1, false);
          var delta$p$1 = (delta + change.inserted | 0) - change.removed | 0;
          console.log("restore 1: removalStart: " + removalStart.toString() + ", removalEnd: " + removalEnd.toString() + ", goal.start: " + goal.start.toString() + ", goal.end: " + goal.end.toString());
          return insertMany(go(delta$p$1, {
                          hd: goal,
                          tl: goals$1
                        }, changes$1), goal, actions$1);
        }
        if (removalEnd <= goal.end) {
          var deltaEnd$2 = change.inserted - change.removed | 0;
          console.log("restore 2: removalStart: " + removalStart.toString() + ", removalEnd: " + removalEnd.toString() + ", goal.start: " + goal.start.toString() + ", goal.end: " + goal.end.toString());
          var actions$2 = scanGoal(delta, goal, 0, deltaEnd$2, false);
          var delta$p$2 = (delta + change.inserted | 0) - change.removed | 0;
          return insertMany(go(delta$p$2, {
                          hd: goal,
                          tl: goals$1
                        }, changes$1), goal, actions$2);
        }
        console.log("restore 3: removalStart: " + removalStart.toString() + ", removalEnd: " + removalEnd.toString() + ", goal.start: " + goal.start.toString() + ", goal.end: " + goal.end.toString());
        var deltaEnd$3 = (removalStart - goal.end | 0) + change.inserted | 0;
        var actions$3 = scanGoal(delta, goal, 0, deltaEnd$3, false);
        var delta$p$3 = (delta + change.inserted | 0) - change.removed | 0;
        return insertMany(go(delta$p$3, goals$1, changes$1), goal, actions$3);
      }
      var actions$4 = scanGoal(delta, goal, 0, 0, false);
      return insertMany(go(delta, goals$1, changes), goal, actions$4);
    };
  };
  var goals = Core__List.fromArray(Core__Array.filterMap(AVLTree$AgdaModeVscode.toArray(self.positions), (function (index) {
              return self.goals.get(index);
            })));
  var map = go(0, goals, changes$1);
  var rewrites = Core__Array.filterMap(Array.from(map.entries()), (function (param) {
            var state = param[1];
            var index = param[0];
            if (typeof state !== "object") {
              destroyGoalByIndex(self, index);
              return ;
            }
            state._0.forEach(function (param) {
                  var deltaStart = param[0];
                  var deltaEnd = param[1];
                  var redecorate = param[2];
                  var goal = self.goals.get(index);
                  if (goal !== undefined) {
                    var newStart = goal.start + deltaStart | 0;
                    var newEnd = goal.end + deltaEnd | 0;
                    self.positions.remove(goal.start);
                    var updatedGoal = redecorate ? (destroyGoal(self, goal), make(editor, newStart, newEnd, goal.index)) : ({
                          index: goal.index,
                          start: newStart,
                          end: newEnd,
                          decorationBackground: goal.decorationBackground,
                          decorationIndex: goal.decorationIndex
                        });
                    self.positions.insert(newStart, updatedGoal.index);
                    self.goals.set(updatedGoal.index, updatedGoal);
                    return ;
                  }
                  
                });
            return state._1;
          })).flat();
  if (rewrites.length !== 0) {
    setBusy(self);
    await Editor$AgdaModeVscode.$$Text.batchReplace($$document, rewrites);
    return ;
  } else {
    var resource = self.isBusy;
    if (resource !== undefined) {
      self.isBusy = undefined;
      return Resource$AgdaModeVscode.set(Caml_option.valFromOption(resource), undefined);
    } else {
      return ;
    }
  }
}

async function resetGoalIndices(self, editor, indices) {
  clear(self);
  Array.from(self.goalsWithoutIndices.entries()).forEach(function (param, i) {
        var start = param[0];
        var index = indices[i];
        if (index === undefined) {
          return ;
        }
        var goal = make(editor, start, param[1], index);
        self.goals.set(index, goal);
        self.positions.insert(start, index);
      });
  self.goalsWithoutIndices = new Map();
  return await scanAllGoals(self, editor, []);
}

function addGoalPositions(self, positions) {
  positions.forEach(function (param) {
        self.goalsWithoutIndices.set(param[0], param[1]);
      });
}

function parseGoalPositionsFromRefine(raw) {
  var goalQuestionMark = /([\s\(\{\_\;\.\\\"@]|^)(\?)([\s\)\}\_\;\.\\\"@]|$)/gm;
  var chunks = raw.split(goalQuestionMark);
  return Core__Array.reduce(chunks, [
                [],
                0
              ], (function (param, chunk) {
                  var i = param[1];
                  var offsets = param[0];
                  if (chunk !== undefined) {
                    if (chunk === "?") {
                      return [
                              Belt_Array.concatMany([
                                    offsets,
                                    [[
                                        i,
                                        i + 1 | 0
                                      ]]
                                  ]),
                              i + 1 | 0
                            ];
                    } else {
                      return [
                              offsets,
                              i + chunk.length | 0
                            ];
                    }
                  } else {
                    return [
                            offsets,
                            i
                          ];
                  }
                }))[0];
}

function jmupToGoal(editor, goal) {
  var $$document = editor.document;
  var spaceInsideBoundaries = (goal.end - goal.start | 0) - 4 | 0;
  var offset = spaceInsideBoundaries === 0 ? goal.start + 2 | 0 : goal.start + 3 | 0;
  var position = $$document.positionAt(offset);
  Editor$AgdaModeVscode.Cursor.set(editor, position);
}

function jmupToTheNextGoal(self, editor) {
  var $$document = editor.document;
  var cursorOffset = $$document.offsetAt(Editor$AgdaModeVscode.Cursor.get(editor));
  var index = AVLTree$AgdaModeVscode.upperBound(self.positions, cursorOffset);
  var goal = index !== undefined ? self.goals.get(index) : self.goals.get(0);
  if (goal !== undefined) {
    return jmupToGoal(editor, goal);
  }
  
}

function jmupToThePreviousGoal(self, editor) {
  var $$document = editor.document;
  var cursorOffset = $$document.offsetAt(Editor$AgdaModeVscode.Cursor.get(editor));
  var index = AVLTree$AgdaModeVscode.lowerBound(self.positions, cursorOffset);
  var goal;
  if (index !== undefined) {
    var goal$1 = self.goals.get(index);
    if (goal$1 !== undefined) {
      if (cursorOffset >= goal$1.start && cursorOffset < goal$1.end) {
        var previousIndex = index === 0 ? self.goals.size - 1 | 0 : index - 1 | 0;
        goal = self.goals.get(previousIndex);
      } else {
        goal = goal$1;
      }
    } else {
      goal = undefined;
    }
  } else {
    goal = self.goals.get(self.goals.size - 1 | 0);
  }
  if (goal !== undefined) {
    return jmupToGoal(editor, goal);
  }
  
}

function markAsCaseSplited(self, goal) {
  self.recentlyCaseSplited = goal;
}

function getRecentlyCaseSplited(self) {
  return Core__Option.map(self.recentlyCaseSplited, (function (goal) {
                return {
                        index: goal.index,
                        indexString: goal.index.toString(),
                        start: goal.start,
                        end: goal.end
                      };
              }));
}

var Module = {
  make: make$1,
  size: size,
  resetGoalIndices: resetGoalIndices,
  addGoalPositions: addGoalPositions,
  parseGoalPositionsFromRefine: parseGoalPositionsFromRefine,
  destroyGoalByIndex: destroyGoalByIndex,
  scanAllGoals: scanAllGoals,
  getGoalByIndex: getGoalByIndex,
  modify: modify,
  removeBoundaryAndDestroy: removeBoundaryAndDestroy,
  getGoalAtCursor: getGoalAtCursor,
  jmupToTheNextGoal: jmupToTheNextGoal,
  jmupToThePreviousGoal: jmupToThePreviousGoal,
  isBusy: isBusy,
  waitUntilNotBusy: waitUntilNotBusy,
  markAsCaseSplited: markAsCaseSplited,
  getRecentlyCaseSplited: getRecentlyCaseSplited,
  serialize: serialize
};

exports.Module = Module;
exports.make = make$1;
exports.size = size;
exports.resetGoalIndices = resetGoalIndices;
exports.addGoalPositions = addGoalPositions;
exports.parseGoalPositionsFromRefine = parseGoalPositionsFromRefine;
exports.destroyGoalByIndex = destroyGoalByIndex;
exports.scanAllGoals = scanAllGoals;
exports.getGoalByIndex = getGoalByIndex;
exports.modify = modify;
exports.removeBoundaryAndDestroy = removeBoundaryAndDestroy;
exports.getGoalAtCursor = getGoalAtCursor;
exports.jmupToTheNextGoal = jmupToTheNextGoal;
exports.jmupToThePreviousGoal = jmupToThePreviousGoal;
exports.isBusy = isBusy;
exports.waitUntilNotBusy = waitUntilNotBusy;
exports.markAsCaseSplited = markAsCaseSplited;
exports.getRecentlyCaseSplited = getRecentlyCaseSplited;
exports.serialize = serialize;
/* vscode Not a pure module */
