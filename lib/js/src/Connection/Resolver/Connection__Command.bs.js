// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Core__List = require("@rescript/core/lib/js/src/Core__List.bs.js");
var OS$AgdaModeVscode = require("../../Util/OS.bs.js");
var Connection__Endpoint$AgdaModeVscode = require("../Endpoint/Connection__Endpoint.bs.js");
var Connection__Process__Exec$AgdaModeVscode = require("../Shared/Connection__Process__Exec.bs.js");

function toString(error) {
  if (typeof error !== "object") {
    return "Command not found";
  } else if (error.TAG === "SomethingWentWrong") {
    return Connection__Process__Exec$AgdaModeVscode.$$Error.toString(error._0);
  } else {
    return error._0 + " is not a valid target because: " + Connection__Endpoint$AgdaModeVscode.$$Error.toString(error._1);
  }
}

var $$Error = {
  toString: toString
};

async function searchWith(command, name, timeoutOpt) {
  var timeout = timeoutOpt !== undefined ? timeoutOpt : 1000;
  var stdout = await Connection__Process__Exec$AgdaModeVscode.run(command, [name], timeout);
  if (stdout.TAG === "Ok") {
    var path = stdout._0.trim();
    var target = await Connection__Endpoint$AgdaModeVscode.fromRawPath(path);
    if (target.TAG === "Ok") {
      return {
              TAG: "Ok",
              _0: target._0
            };
    } else {
      return {
              TAG: "Error",
              _0: {
                TAG: "NotValidTarget",
                _0: path,
                _1: target._0
              }
            };
    }
  }
  var error = stdout._0;
  if (typeof error !== "object") {
    return {
            TAG: "Error",
            _0: {
              TAG: "SomethingWentWrong",
              _0: error
            }
          };
  }
  if (error.TAG !== "FromStderr") {
    return {
            TAG: "Error",
            _0: {
              TAG: "SomethingWentWrong",
              _0: error
            }
          };
  }
  var match = error._0;
  if (match === undefined) {
    return {
            TAG: "Error",
            _0: {
              TAG: "SomethingWentWrong",
              _0: error
            }
          };
  }
  if (match !== 1) {
    return {
            TAG: "Error",
            _0: {
              TAG: "SomethingWentWrong",
              _0: error
            }
          };
  }
  switch (error._1) {
    case "" :
    case "INFO: Could not find files for the given pattern(s).\r\n" :
        return {
                TAG: "Error",
                _0: "NotFound"
              };
    default:
      return {
              TAG: "Error",
              _0: {
                TAG: "SomethingWentWrong",
                _0: error
              }
            };
  }
}

async function searchWithRaw(command, name, timeoutOpt) {
  var timeout = timeoutOpt !== undefined ? timeoutOpt : 1000;
  var stdout = await Connection__Process__Exec$AgdaModeVscode.run(command, [name], timeout);
  if (stdout.TAG === "Ok") {
    var path = stdout._0.trim();
    return {
            TAG: "Ok",
            _0: path
          };
  }
  var error = stdout._0;
  if (typeof error !== "object") {
    return {
            TAG: "Error",
            _0: {
              TAG: "SomethingWentWrong",
              _0: error
            }
          };
  }
  if (error.TAG !== "FromStderr") {
    return {
            TAG: "Error",
            _0: {
              TAG: "SomethingWentWrong",
              _0: error
            }
          };
  }
  var match = error._0;
  if (match === undefined) {
    return {
            TAG: "Error",
            _0: {
              TAG: "SomethingWentWrong",
              _0: error
            }
          };
  }
  if (match !== 1) {
    return {
            TAG: "Error",
            _0: {
              TAG: "SomethingWentWrong",
              _0: error
            }
          };
  }
  switch (error._1) {
    case "" :
    case "INFO: Could not find files for the given pattern(s).\r\n" :
        return {
                TAG: "Error",
                _0: "NotFound"
              };
    default:
      return {
              TAG: "Error",
              _0: {
                TAG: "SomethingWentWrong",
                _0: error
              }
            };
  }
}

async function search(name, timeoutOpt) {
  var timeout = timeoutOpt !== undefined ? timeoutOpt : 1000;
  if (OS$AgdaModeVscode.onUnix) {
    return await searchWith("which", name, timeout);
  }
  var stdout = await searchWith("which", name, timeout);
  if (stdout.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: stdout._0
          };
  } else {
    return await searchWith("where.exe", name, timeout);
  }
}

async function findCommand(name, timeoutOpt) {
  var timeout = timeoutOpt !== undefined ? timeoutOpt : 1000;
  if (OS$AgdaModeVscode.onUnix) {
    return await searchWithRaw("which", name, timeout);
  }
  var stdout = await searchWithRaw("which", name, timeout);
  if (stdout.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: stdout._0
          };
  } else {
    return await searchWithRaw("where.exe", name, timeout);
  }
}

async function findCommands(commands) {
  var commands$1 = Core__List.fromArray(commands);
  var step = async function (errors, commands) {
    if (!commands) {
      return {
              TAG: "Error",
              _0: errors
            };
    }
    var command = commands.hd;
    var path = await search(command, undefined);
    if (path.TAG === "Ok") {
      return {
              TAG: "Ok",
              _0: path._0
            };
    }
    errors[command] = path._0;
    return await step(errors, commands.tl);
  };
  var errors = await step({}, commands$1);
  if (errors.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: errors._0
          };
  } else {
    return {
            TAG: "Error",
            _0: errors._0
          };
  }
}

exports.$$Error = $$Error;
exports.searchWith = searchWith;
exports.searchWithRaw = searchWithRaw;
exports.search = search;
exports.findCommand = findCommand;
exports.findCommands = findCommands;
/* OS-AgdaModeVscode Not a pure module */
