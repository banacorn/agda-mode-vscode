// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Js_exn = require("rescript/lib/js/js_exn.js");
var Vscode = require("vscode");
var Nodepath = require("node:path");
var Caml_option = require("rescript/lib/js/caml_option.js");
var FS$AgdaModeVscode = require("../FS.bs.js");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");
var Chan$AgdaModeVscode = require("../Util/Chan.bs.js");
var Util$AgdaModeVscode = require("../Util/Util.bs.js");
var Config$AgdaModeVscode = require("../Config.bs.js");
var Parser$AgdaModeVscode = require("../Parser/Parser.bs.js");
var Memento$AgdaModeVscode = require("../Memento.bs.js");
var Request$AgdaModeVscode = require("../Request.bs.js");
var WASMLoader$AgdaModeVscode = require("./Binding/WASMLoader.bs.js");
var Json_Encode$JsonCombinators = require("@glennsl/rescript-json-combinators/lib/js/src/Json_Encode.bs.js");
var Connection__URI$AgdaModeVscode = require("./Shared/Connection__URI.bs.js");
var Connection__Error$AgdaModeVscode = require("./Shared/Connection__Error.bs.js");
var Connection__Endpoint__ALS$AgdaModeVscode = require("./Endpoint/Connection__Endpoint__ALS.bs.js");
var Connection__Process__Exec$AgdaModeVscode = require("./Shared/Connection__Process__Exec.bs.js");
var Connection__Endpoint__Agda$AgdaModeVscode = require("./Endpoint/Connection__Endpoint__Agda.bs.js");
var Connection__Transport__TCP$AgdaModeVscode = require("./Transport/Connection__Transport__TCP.bs.js");

function getFromConfig() {
  var param = {
    commandLineOptions: Config$AgdaModeVscode.Connection.getCommandLineOptions()
  };
  return {
          commandLineOptions: Json_Encode$JsonCombinators.array(function (prim) {
                  return prim;
                })(param.commandLineOptions)
        };
}

function toString(connection) {
  switch (connection.TAG) {
    case "Agda" :
        return "Agda v" + connection._2;
    case "ALS" :
        var match = connection._2;
        if (match !== undefined) {
          return "Agda v" + match[1] + " Language Server v" + match[0];
        } else {
          return "Agda Language Server of unknown version";
        }
    case "ALSWASM" :
        var match$1 = connection._3;
        if (match$1 !== undefined) {
          return "Agda v" + match$1[1] + " Language Server v" + match$1[0] + " (WASM)";
        } else {
          return "Agda Language Server of unknown version (WASM)";
        }
    
  }
}

function getPath(connection) {
  switch (connection.TAG) {
    case "Agda" :
    case "ALS" :
        return connection._1;
    case "ALSWASM" :
        return connection._2;
    
  }
}

async function destroy(connection, logChannel) {
  if (connection === undefined) {
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
  Chan$AgdaModeVscode.emit(logChannel, {
        TAG: "Connection",
        _0: {
          TAG: "Disconnected",
          _0: getPath(connection)
        }
      });
  switch (connection.TAG) {
    case "Agda" :
        await Connection__Endpoint__Agda$AgdaModeVscode.destroy(connection._0);
        return {
                TAG: "Ok",
                _0: undefined
              };
    case "ALS" :
        var error = await Connection__Endpoint__ALS$AgdaModeVscode.destroy(connection._0);
        if (error.TAG === "Ok") {
          return {
                  TAG: "Ok",
                  _0: undefined
                };
        } else {
          return {
                  TAG: "Error",
                  _0: {
                    TAG: "CommWithALS",
                    _0: error._0
                  }
                };
        }
    case "ALSWASM" :
        return {
                TAG: "Ok",
                _0: undefined
              };
    
  }
}

async function checkForPrebuiltDataDirectory(executablePath) {
  var prebuildDataDirPath = Nodepath.join(executablePath, "..", "data");
  var prebuildDataDirURI = Vscode.Uri.file(prebuildDataDirPath);
  var match = await FS$AgdaModeVscode.stat(prebuildDataDirURI);
  if (match.TAG === "Ok") {
    return Nodepath.join(executablePath, "..", "data");
  }
  
}

async function probeFilepath(path) {
  var match = Connection__URI$AgdaModeVscode.parse(path);
  if (match.TAG === "FileURI") {
    var vscodeUri = match._1;
    var fsPath = vscodeUri.fsPath;
    if (fsPath.endsWith(".wasm")) {
      return {
              TAG: "Ok",
              _0: [
                fsPath,
                {
                  TAG: "IsALSWASM",
                  _0: vscodeUri
                }
              ]
            };
    }
    var result = await Connection__Process__Exec$AgdaModeVscode.run(fsPath, ["--version"], 3000);
    if (result.TAG !== "Ok") {
      return {
              TAG: "Error",
              _0: {
                TAG: "CannotDetermineAgdaOrALS",
                _0: result._0
              }
            };
    }
    var output = result._0;
    var match$1 = output.match(/Agda version (.*)/);
    if (!(match$1 == null) && match$1.length === 2) {
      var version = match$1[1];
      if (version !== undefined) {
        return {
                TAG: "Ok",
                _0: [
                  fsPath,
                  {
                    TAG: "IsAgda",
                    _0: version
                  }
                ]
              };
      }
      
    }
    var match$2 = output.match(/Agda v(.*) Language Server v(.*)/);
    if (match$2 == null) {
      return {
              TAG: "Error",
              _0: {
                TAG: "NotAgdaOrALS",
                _0: output
              }
            };
    }
    if (match$2.length !== 3) {
      return {
              TAG: "Error",
              _0: {
                TAG: "NotAgdaOrALS",
                _0: output
              }
            };
    }
    var agdaVersion = match$2[1];
    if (agdaVersion === undefined) {
      return {
              TAG: "Error",
              _0: {
                TAG: "NotAgdaOrALS",
                _0: output
              }
            };
    }
    var alsVersion = match$2[2];
    if (alsVersion === undefined) {
      return {
              TAG: "Error",
              _0: {
                TAG: "NotAgdaOrALS",
                _0: output
              }
            };
    }
    var assetPath = await checkForPrebuiltDataDirectory(fsPath);
    var lspOptions;
    if (assetPath !== undefined) {
      var env = Object.fromEntries([[
              "Agda_datadir",
              assetPath
            ]]);
      lspOptions = {
        env: env
      };
    } else {
      lspOptions = undefined;
    }
    return {
            TAG: "Ok",
            _0: [
              fsPath,
              {
                TAG: "IsALS",
                _0: alsVersion,
                _1: agdaVersion,
                _2: lspOptions
              }
            ]
          };
  }
  var nodejsUrl = match._1;
  var match$3 = await Connection__Transport__TCP$AgdaModeVscode.probe(nodejsUrl, undefined);
  if (match$3.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: [
              path,
              {
                TAG: "IsALSOfUnknownVersion",
                _0: nodejsUrl
              }
            ]
          };
  }
  var timeout = match$3._0;
  if (timeout.TAG === "Timeout") {
    return {
            TAG: "Error",
            _0: {
              TAG: "CannotMakeConnectionWithALS",
              _0: {
                TAG: "ConnectionTimeoutError",
                _0: timeout._0
              }
            }
          };
  } else {
    return {
            TAG: "Error",
            _0: {
              TAG: "CannotMakeConnectionWithALS",
              _0: {
                TAG: "ConnectionError",
                _0: timeout._0
              }
            }
          };
  }
}

async function make(rawpath) {
  var error = await probeFilepath(rawpath);
  if (error.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: Connection__Error$AgdaModeVscode.Establish.fromProbeError(rawpath, error._0)
          };
  }
  var match = error._0;
  var agdaVersion = match[1];
  var path = match[0];
  switch (agdaVersion.TAG) {
    case "IsAgda" :
        var agdaVersion$1 = agdaVersion._0;
        var connection = await Connection__Endpoint__Agda$AgdaModeVscode.make(path, agdaVersion$1);
        return {
                TAG: "Ok",
                _0: {
                  TAG: "Agda",
                  _0: connection,
                  _1: path,
                  _2: agdaVersion$1
                }
              };
    case "IsALS" :
        var lspOptions = agdaVersion._2;
        var error$1 = await Connection__Endpoint__ALS$AgdaModeVscode.make({
              TAG: "ViaPipe",
              _0: rawpath,
              _1: []
            }, lspOptions, getFromConfig());
        if (error$1.TAG === "Ok") {
          return {
                  TAG: "Ok",
                  _0: {
                    TAG: "ALS",
                    _0: error$1._0,
                    _1: path,
                    _2: [
                      agdaVersion._0,
                      agdaVersion._1,
                      lspOptions
                    ]
                  }
                };
        } else {
          return {
                  TAG: "Error",
                  _0: Connection__Error$AgdaModeVscode.Establish.fromProbeError(path, {
                        TAG: "CannotMakeConnectionWithALS",
                        _0: error$1._0
                      })
                };
        }
    case "IsALSOfUnknownVersion" :
        var error$2 = await Connection__Endpoint__ALS$AgdaModeVscode.make({
              TAG: "ViaTCP",
              _0: rawpath,
              _1: agdaVersion._0
            }, undefined, getFromConfig());
        if (error$2.TAG !== "Ok") {
          return {
                  TAG: "Error",
                  _0: Connection__Error$AgdaModeVscode.Establish.fromProbeError(path, {
                        TAG: "CannotMakeConnectionWithALS",
                        _0: error$2._0
                      })
                };
        }
        var conn = error$2._0;
        var alsVersion = conn.alsVersion;
        if (alsVersion !== undefined) {
          return {
                  TAG: "Ok",
                  _0: {
                    TAG: "ALS",
                    _0: conn,
                    _1: path,
                    _2: [
                      alsVersion,
                      conn.agdaVersion,
                      undefined
                    ]
                  }
                };
        } else {
          return {
                  TAG: "Ok",
                  _0: {
                    TAG: "ALS",
                    _0: conn,
                    _1: path,
                    _2: undefined
                  }
                };
        }
    case "IsALSWASM" :
        var extension = Vscode.extensions.getExtension("qbane.als-wasm-loader");
        if (extension === undefined) {
          return {
                  TAG: "Error",
                  _0: Connection__Error$AgdaModeVscode.Establish.fromProbeError(path, "CannotMakeConnectionWithALSWASMYet")
                };
        }
        var extension$1 = Caml_option.valFromOption(extension);
        try {
          if (!extension$1.isActive) {
            await extension$1.activate();
          }
          var error$3 = await FS$AgdaModeVscode.readFile(agdaVersion._0);
          if (error$3.TAG !== "Ok") {
            return {
                    TAG: "Error",
                    _0: Connection__Error$AgdaModeVscode.Establish.fromProbeError(path, "CannotMakeConnectionWithALSWASMYet")
                  };
          }
          var wasmLoader = await WASMLoader$AgdaModeVscode.make(extension$1, error$3._0);
          var errorMsg = await WASMLoader$AgdaModeVscode.prepareAgdaDataDir(extension$1, wasmLoader.memfsAgdaDataDir);
          if (errorMsg.TAG !== "Ok") {
            return {
                    TAG: "Error",
                    _0: Connection__Error$AgdaModeVscode.Establish.fromProbeError(path, "CannotMakeConnectionWithALSWASMYet")
                  };
          }
          var error$4 = await Connection__Endpoint__ALS$AgdaModeVscode.make({
                TAG: "ViaWASM",
                _0: wasmLoader
              }, {
                env: errorMsg._0
              }, getFromConfig());
          if (error$4.TAG !== "Ok") {
            return {
                    TAG: "Error",
                    _0: Connection__Error$AgdaModeVscode.Establish.fromProbeError(path, {
                          TAG: "CannotMakeConnectionWithALS",
                          _0: error$4._0
                        })
                  };
          }
          var conn$1 = error$4._0;
          var version = conn$1.alsVersion;
          var version$1 = version !== undefined ? [
              conn$1.agdaVersion,
              version,
              undefined
            ] : undefined;
          return {
                  TAG: "Ok",
                  _0: {
                    TAG: "ALSWASM",
                    _0: conn$1,
                    _1: wasmLoader,
                    _2: path,
                    _3: version$1
                  }
                };
        }
        catch (raw_error){
          var error$5 = Caml_js_exceptions.internalToOCamlException(raw_error);
          if (error$5.RE_EXN_ID === Js_exn.$$Error) {
            return {
                    TAG: "Error",
                    _0: Connection__Error$AgdaModeVscode.Establish.fromProbeError(path, "CannotMakeConnectionWithALSWASMYet")
                  };
          }
          throw error$5;
        }
    
  }
}

async function tryUntilSuccess(xs) {
  var loop = async function (remaining, errors) {
    var task = remaining[0];
    if (task === undefined) {
      return {
              TAG: "Error",
              _0: errors
            };
    }
    var success = await task();
    if (success.TAG === "Ok") {
      return {
              TAG: "Ok",
              _0: success._0
            };
    }
    var newErrors = errors.concat([success._0]);
    var nextTasks = remaining.slice(1);
    return await loop(nextTasks, newErrors);
  };
  return await loop(xs, []);
}

async function tagFrom(result, from) {
  var connection = await result;
  if (connection.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: [
              connection._0,
              from
            ]
          };
  } else {
    return {
            TAG: "Error",
            _0: connection._0
          };
  }
}

async function fromPaths(platformDeps, paths) {
  var tasks = paths.map(function (path) {
        return function () {
          return make(path);
        };
      });
  var connection = await tryUntilSuccess(tasks);
  if (connection.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: connection._0
          };
  } else {
    return {
            TAG: "Error",
            _0: Connection__Error$AgdaModeVscode.Establish.mergeMany(connection._0)
          };
  }
}

async function fromCommands(platformDeps, commands) {
  var tryCommand = async function (command) {
    var rawPath = await platformDeps.findCommand(command, undefined);
    if (rawPath.TAG === "Ok") {
      return await make(rawPath._0);
    } else {
      return {
              TAG: "Error",
              _0: Connection__Error$AgdaModeVscode.Establish.fromCommandError(command, rawPath._0)
            };
    }
  };
  var tasks = commands.map(function (command) {
        return function () {
          return tryCommand(command);
        };
      });
  var connection = await tryUntilSuccess(tasks);
  if (connection.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: connection._0
          };
  } else {
    return {
            TAG: "Error",
            _0: Connection__Error$AgdaModeVscode.Establish.mergeMany(connection._0)
          };
  }
}

async function fromDownloads(platformDeps, memento, globalStorageUri) {
  var platform = await platformDeps.determinePlatform();
  if (platform.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: Connection__Error$AgdaModeVscode.Establish.fromDownloadError({
                  TAG: "PlatformNotSupported",
                  _0: platform._0
                })
          };
  }
  var policy = Config$AgdaModeVscode.Connection.DownloadPolicy.get();
  var policy$1;
  switch (policy) {
    case "Yes" :
    case "No" :
        policy$1 = policy;
        break;
    case "Undecided" :
        policy$1 = await platformDeps.askUserAboutDownloadPolicy();
        break;
    
  }
  switch (policy$1) {
    case "Yes" :
        await Config$AgdaModeVscode.Connection.DownloadPolicy.set("Yes");
        var path = await platformDeps.alreadyDownloaded(globalStorageUri, "LatestALS");
        var downloadResult;
        if (path !== undefined) {
          downloadResult = {
            TAG: "Ok",
            _0: path
          };
        } else {
          var error = await platformDeps.resolveDownloadOrder("LatestALS", true)(memento, globalStorageUri, platform._0);
          if (error.TAG === "Ok") {
            var error$1 = await platformDeps.download(globalStorageUri, error._0);
            downloadResult = error$1.TAG === "Ok" ? ({
                  TAG: "Ok",
                  _0: error$1._0
                }) : ({
                  TAG: "Error",
                  _0: Connection__Error$AgdaModeVscode.Establish.fromDownloadError(error$1._0)
                });
          } else {
            downloadResult = {
              TAG: "Error",
              _0: Connection__Error$AgdaModeVscode.Establish.fromDownloadError(error._0)
            };
          }
        }
        if (downloadResult.TAG !== "Ok") {
          return {
                  TAG: "Error",
                  _0: downloadResult._0
                };
        }
        var connection = await make(downloadResult._0);
        if (connection.TAG === "Ok") {
          return {
                  TAG: "Ok",
                  _0: connection._0
                };
        } else {
          return {
                  TAG: "Error",
                  _0: connection._0
                };
        }
    case "No" :
    case "Undecided" :
        break;
    
  }
  await Config$AgdaModeVscode.Connection.DownloadPolicy.set("No");
  return {
          TAG: "Error",
          _0: Connection__Error$AgdaModeVscode.Establish.fromDownloadError("OptedNotToDownload")
        };
}

async function makeWithFallback(platformDeps, memento, globalStorageUri, paths, commands, logChannel) {
  var logConnection = function (connection) {
    switch (connection.TAG) {
      case "Agda" :
          return Chan$AgdaModeVscode.emit(logChannel, {
                      TAG: "Connection",
                      _0: {
                        TAG: "ConnectedToAgda",
                        _0: connection._1,
                        _1: connection._2
                      }
                    });
      case "ALS" :
          var match = connection._2;
          var path = connection._1;
          if (match !== undefined) {
            return Chan$AgdaModeVscode.emit(logChannel, {
                        TAG: "Connection",
                        _0: {
                          TAG: "ConnectedToALS",
                          _0: path,
                          _1: [
                            match[0],
                            match[1]
                          ]
                        }
                      });
          } else {
            return Chan$AgdaModeVscode.emit(logChannel, {
                        TAG: "Connection",
                        _0: {
                          TAG: "ConnectedToALS",
                          _0: path,
                          _1: undefined
                        }
                      });
          }
      case "ALSWASM" :
          var match$1 = connection._3;
          var path$1 = connection._2;
          if (match$1 !== undefined) {
            return Chan$AgdaModeVscode.emit(logChannel, {
                        TAG: "Connection",
                        _0: {
                          TAG: "ConnectedToALS",
                          _0: path$1,
                          _1: [
                            match$1[0],
                            match$1[1]
                          ]
                        }
                      });
          } else {
            return Chan$AgdaModeVscode.emit(logChannel, {
                        TAG: "Connection",
                        _0: {
                          TAG: "ConnectedToALS",
                          _0: path$1,
                          _1: undefined
                        }
                      });
          }
      
    }
  };
  var pickedPath = Memento$AgdaModeVscode.Module.PickedConnection.get(memento);
  var pathsWithSelectedConnection = pickedPath !== undefined && paths.includes(pickedPath) ? [pickedPath].concat(paths.filter(function (p) {
              return p !== pickedPath;
            })) : paths;
  var tasks = [
    (function () {
        return tagFrom(fromPaths(platformDeps, pathsWithSelectedConnection), "FromPaths");
      }),
    (function () {
        return tagFrom(fromCommands(platformDeps, commands), "FromCommands");
      }),
    (function () {
        return tagFrom(fromDownloads(platformDeps, memento, globalStorageUri), "FromDownloads");
      })
  ];
  var errors = await tryUntilSuccess(tasks);
  if (errors.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: {
              TAG: "Establish",
              _0: Connection__Error$AgdaModeVscode.Establish.mergeMany(errors._0)
            }
          };
  }
  var match = errors._0;
  var connection = match[0];
  logConnection(connection);
  var exit = 0;
  switch (match[1]) {
    case "FromPaths" :
        break;
    case "FromCommands" :
    case "FromDownloads" :
        exit = 1;
        break;
    
  }
  if (exit === 1) {
    await Config$AgdaModeVscode.Connection.addAgdaPath(logChannel, getPath(connection));
  }
  await Memento$AgdaModeVscode.Module.PickedConnection.set(memento, getPath(connection));
  return {
          TAG: "Ok",
          _0: connection
        };
}

async function sendRequest(connection, $$document, request, handler) {
  var encodeRequest = function ($$document, version) {
    var filepath = Parser$AgdaModeVscode.filepath($$document.fileName);
    var libraryPath = Config$AgdaModeVscode.getLibraryPath();
    var highlightingMethod = Config$AgdaModeVscode.Highlighting.getHighlightingMethod();
    var backend = Config$AgdaModeVscode.getBackend();
    return Request$AgdaModeVscode.encode($$document, version, filepath, backend, libraryPath, highlightingMethod, request);
  };
  var encodeRequestForWASM = function (wasmLoader, $$document, version) {
    var libraryPath = Config$AgdaModeVscode.getLibraryPath();
    var highlightingMethod = Config$AgdaModeVscode.Highlighting.getHighlightingMethod();
    var backend = Config$AgdaModeVscode.getBackend();
    var codeUri = $$document.uri;
    var converters = wasmLoader.createUriConverters();
    var protoUri = (function(conv, uri){ return conv.code2Protocol(uri); })(converters, codeUri);
    var filepath = (function(u){ try { return new URL(u).pathname; } catch(e) { return u; } })(protoUri);
    return Request$AgdaModeVscode.encode($$document, version, filepath, backend, libraryPath, highlightingMethod, request);
  };
  switch (connection.TAG) {
    case "Agda" :
        var error = await Connection__Endpoint__Agda$AgdaModeVscode.sendRequest(connection._0, encodeRequest($$document, connection._2), handler);
        if (error.TAG === "Ok") {
          return {
                  TAG: "Ok",
                  _0: undefined
                };
        }
        await destroy(connection, Chan$AgdaModeVscode.make());
        return {
                TAG: "Error",
                _0: {
                  TAG: "CommWithAgda",
                  _0: error._0
                }
              };
    case "ALS" :
        var conn = connection._0;
        var error$1 = await Connection__Endpoint__ALS$AgdaModeVscode.sendRequest(conn, encodeRequest($$document, conn.agdaVersion), handler);
        if (error$1.TAG === "Ok") {
          return {
                  TAG: "Ok",
                  _0: undefined
                };
        }
        await destroy(connection, Chan$AgdaModeVscode.make());
        return {
                TAG: "Error",
                _0: {
                  TAG: "CommWithALS",
                  _0: error$1._0
                }
              };
    case "ALSWASM" :
        var conn$1 = connection._0;
        var payload = encodeRequestForWASM(connection._1, $$document, conn$1.agdaVersion);
        Util$AgdaModeVscode.log("Sending encoded request to WASM ALS: ", payload);
        var error$2 = await Connection__Endpoint__ALS$AgdaModeVscode.sendRequest(conn$1, payload, handler);
        if (error$2.TAG === "Ok") {
          return {
                  TAG: "Ok",
                  _0: undefined
                };
        }
        await destroy(connection, Chan$AgdaModeVscode.make());
        return {
                TAG: "Error",
                _0: {
                  TAG: "CommWithALS",
                  _0: error$2._0
                }
              };
    
  }
}

var Module = {
  make: make,
  makeWithFallback: makeWithFallback,
  toString: toString,
  getPath: getPath,
  destroy: destroy,
  fromPaths: fromPaths,
  fromCommands: fromCommands,
  fromDownloads: fromDownloads,
  sendRequest: sendRequest,
  checkForPrebuiltDataDirectory: checkForPrebuiltDataDirectory,
  probeFilepath: probeFilepath
};

var $$Error;

var Agda;

var ALS;

var URI;

exports.$$Error = $$Error;
exports.Agda = Agda;
exports.ALS = ALS;
exports.URI = URI;
exports.Module = Module;
exports.make = make;
exports.makeWithFallback = makeWithFallback;
exports.toString = toString;
exports.getPath = getPath;
exports.destroy = destroy;
exports.fromPaths = fromPaths;
exports.fromCommands = fromCommands;
exports.fromDownloads = fromDownloads;
exports.sendRequest = sendRequest;
exports.checkForPrebuiltDataDirectory = checkForPrebuiltDataDirectory;
exports.probeFilepath = probeFilepath;
/* vscode Not a pure module */
