// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Caml_option = require("rescript/lib/js/caml_option.js");
var Chan$AgdaModeVscode = require("../Util/Chan.bs.js");
var Config$AgdaModeVscode = require("../Config.bs.js");
var Parser$AgdaModeVscode = require("../Parser/Parser.bs.js");
var Memento$AgdaModeVscode = require("../Memento.bs.js");
var Request$AgdaModeVscode = require("../Request.bs.js");
var Json_Encode$JsonCombinators = require("@glennsl/rescript-json-combinators/lib/js/src/Json_Encode.bs.js");
var Connection__URI$AgdaModeVscode = require("./Shared/Connection__URI.bs.js");
var Connection__Error$AgdaModeVscode = require("./Shared/Connection__Error.bs.js");
var Connection__Endpoint$AgdaModeVscode = require("./Endpoint/Connection__Endpoint.bs.js");
var Connection__Endpoint__ALS$AgdaModeVscode = require("./Endpoint/ALS/Connection__Endpoint__ALS.bs.js");
var Connection__Process__Exec$AgdaModeVscode = require("./Shared/Connection__Process__Exec.bs.js");
var Connection__Endpoint__Agda$AgdaModeVscode = require("./Endpoint/Agda/Connection__Endpoint__Agda.bs.js");

function getFromConfig() {
  var param = {
    commandLineOptions: Config$AgdaModeVscode.Connection.getCommandLineOptions()
  };
  return {
          commandLineOptions: Json_Encode$JsonCombinators.array(function (prim) {
                  return prim;
                })(param.commandLineOptions)
        };
}

async function destroy(connection, logChannel) {
  if (connection === undefined) {
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
  Chan$AgdaModeVscode.emit(logChannel, {
        TAG: "Connection",
        _0: {
          TAG: "Disconnected",
          _0: connection._1
        }
      });
  if (connection.TAG === "Agda") {
    await Connection__Endpoint__Agda$AgdaModeVscode.destroy(connection._0);
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
  var error = await Connection__Endpoint__ALS$AgdaModeVscode.destroy(connection._0);
  if (error.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: undefined
          };
  } else {
    return {
            TAG: "Error",
            _0: {
              TAG: "ALS",
              _0: error._0
            }
          };
  }
}

function getPath(connection) {
  return connection._1;
}

async function makeWithRawPath(rawpath) {
  var uri = Connection__URI$AgdaModeVscode.parse(rawpath);
  if (uri.TAG !== "FileURI") {
    return {
            TAG: "Error",
            _0: "CannotHandleURLsATM"
          };
  }
  var path = uri._1.fsPath;
  var result = await Connection__Process__Exec$AgdaModeVscode.run(path, ["--version"], undefined);
  if (result.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: {
              TAG: "CannotDetermineAgdaOrALS",
              _0: result._0
            }
          };
  }
  var output = result._0;
  var match = output.match(/Agda version (.*)/);
  if (!(match == null) && match.length === 2) {
    var version = match[1];
    if (version !== undefined) {
      var error = await Connection__Endpoint__Agda$AgdaModeVscode.make(path, version);
      if (error.TAG === "Ok") {
        return {
                TAG: "Ok",
                _0: {
                  TAG: "Agda",
                  _0: error._0,
                  _1: path,
                  _2: version
                }
              };
      } else {
        return {
                TAG: "Error",
                _0: {
                  TAG: "CannotMakeConnectionWithAgda",
                  _0: error._0
                }
              };
      }
    }
    
  }
  var match$1 = output.match(/Agda v(.*) Language Server v(.*)/);
  if (match$1 == null) {
    return {
            TAG: "Error",
            _0: {
              TAG: "NotAgdaOrALS",
              _0: output
            }
          };
  }
  if (match$1.length !== 3) {
    return {
            TAG: "Error",
            _0: {
              TAG: "NotAgdaOrALS",
              _0: output
            }
          };
  }
  var agdaVersion = match$1[1];
  if (agdaVersion === undefined) {
    return {
            TAG: "Error",
            _0: {
              TAG: "NotAgdaOrALS",
              _0: output
            }
          };
  }
  var alsVersion = match$1[2];
  if (alsVersion === undefined) {
    return {
            TAG: "Error",
            _0: {
              TAG: "NotAgdaOrALS",
              _0: output
            }
          };
  }
  var assetPath = await Connection__Endpoint$AgdaModeVscode.checkForPrebuiltDataDirectory(path);
  var lspOptions;
  if (assetPath !== undefined) {
    var env = Object.fromEntries([[
            "Agda_datadir",
            assetPath
          ]]);
    lspOptions = {
      env: env
    };
  } else {
    lspOptions = undefined;
  }
  var error$1 = await Connection__Endpoint__ALS$AgdaModeVscode.make({
        TAG: "ViaPipe",
        _0: path,
        _1: []
      }, lspOptions, getFromConfig());
  if (error$1.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: {
              TAG: "ALS",
              _0: error$1._0,
              _1: path,
              _2: alsVersion,
              _3: agdaVersion
            }
          };
  } else {
    return {
            TAG: "Error",
            _0: {
              TAG: "CannotMakeConnectionWithALS",
              _0: error$1._0
            }
          };
  }
}

async function findCommands(platformDeps, commands) {
  return await platformDeps.findCommands(commands);
}

async function fromPathsAndCommands(platformDeps, memento, paths, commands) {
  var endpointErrors = await Connection__Endpoint$AgdaModeVscode.getPicked(memento, paths);
  if (endpointErrors.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: endpointErrors._0
          };
  }
  var commandErrors = await findCommands(platformDeps, commands);
  if (commandErrors.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: commandErrors._0
          };
  }
  var constructionError_endpoints = endpointErrors._0;
  var constructionError_commands = commandErrors._0;
  var constructionError = {
    endpoints: constructionError_endpoints,
    commands: constructionError_commands,
    download: undefined
  };
  return {
          TAG: "Error",
          _0: constructionError
        };
}

async function tryUntilSuccess(fn, items) {
  var loop = async function (remaining, errors) {
    var item = remaining[0];
    if (item === undefined) {
      return {
              TAG: "Error",
              _0: errors
            };
    }
    var item$1 = Caml_option.valFromOption(item);
    var success = await fn(item$1);
    if (success.TAG === "Ok") {
      return {
              TAG: "Ok",
              _0: success._0
            };
    }
    var newErrors = errors.concat([[
            item$1,
            success._0
          ]]);
    var nextItems = remaining.slice(1);
    return await loop(nextItems, newErrors);
  };
  return await loop(items, []);
}

async function fromPathsAndCommands2(platformDeps, memento, paths, commands) {
  var tryCommand = async function (command) {
    var rawPath = await platformDeps.findCommand(command, undefined);
    if (rawPath.TAG !== "Ok") {
      return {
              TAG: "Error",
              _0: rawPath._0
            };
    }
    var connection = await makeWithRawPath(rawPath._0);
    if (connection.TAG === "Ok") {
      return {
              TAG: "Ok",
              _0: connection._0
            };
    } else {
      return {
              TAG: "Error",
              _0: "NotFound"
            };
    }
  };
  var pickedPath = Memento$AgdaModeVscode.Module.PickedConnection.get(memento);
  var allPaths = pickedPath !== undefined ? [pickedPath].concat(paths) : paths;
  var connection = await tryUntilSuccess(makeWithRawPath, allPaths);
  if (connection.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: connection._0
          };
  }
  var connection$1 = await tryUntilSuccess(tryCommand, commands);
  if (connection$1.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: connection$1._0
          };
  }
  var constructionError_endpoints = Object.fromEntries(connection._0);
  var constructionError_commands = Object.fromEntries(connection$1._0);
  var constructionError = {
    endpoints: constructionError_endpoints,
    commands: constructionError_commands,
    download: undefined
  };
  return {
          TAG: "Error",
          _0: constructionError
        };
}

async function fromDownloads(platformDeps, memento, globalStorageUri, constructionError) {
  var platform = await platformDeps.determinePlatform();
  if (platform.TAG === "Ok") {
    var policy = Config$AgdaModeVscode.Connection.DownloadPolicy.get();
    var policy$1;
    switch (policy) {
      case "Yes" :
      case "No" :
          policy$1 = policy;
          break;
      case "Undecided" :
          policy$1 = await platformDeps.askUserAboutDownloadPolicy();
          break;
      
    }
    switch (policy$1) {
      case "Yes" :
          await Config$AgdaModeVscode.Connection.DownloadPolicy.set("Yes");
          var endpoint = await platformDeps.alreadyDownloaded(globalStorageUri)();
          if (endpoint !== undefined) {
            await Config$AgdaModeVscode.Connection.addAgdaPath(Connection__Endpoint$AgdaModeVscode.toURI(endpoint));
            return {
                    TAG: "Ok",
                    _0: endpoint
                  };
          }
          var error = await platformDeps.downloadLatestALS(memento, globalStorageUri)(platform._0);
          if (error.TAG === "Ok") {
            var endpoint$1 = error._0;
            await Config$AgdaModeVscode.Connection.addAgdaPath(Connection__Endpoint$AgdaModeVscode.toURI(endpoint$1));
            return {
                    TAG: "Ok",
                    _0: endpoint$1
                  };
          }
          var errors = Connection__Error$AgdaModeVscode.Construction.addDownloadError(constructionError, error._0);
          return {
                  TAG: "Error",
                  _0: {
                    TAG: "Construction",
                    _0: errors
                  }
                };
      case "No" :
      case "Undecided" :
          break;
      
    }
    await Config$AgdaModeVscode.Connection.DownloadPolicy.set("No");
    return {
            TAG: "Error",
            _0: {
              TAG: "Construction",
              _0: constructionError
            }
          };
  }
  var errors$1 = Connection__Error$AgdaModeVscode.Construction.addDownloadError(constructionError, {
        TAG: "PlatformNotSupported",
        _0: platform._0
      });
  return {
          TAG: "Error",
          _0: {
            TAG: "Construction",
            _0: errors$1
          }
        };
}

async function fromDownloads2(platformDeps, memento, globalStorageUri, constructionError) {
  var platform = await platformDeps.determinePlatform();
  if (platform.TAG === "Ok") {
    var policy = Config$AgdaModeVscode.Connection.DownloadPolicy.get();
    var policy$1;
    switch (policy) {
      case "Yes" :
      case "No" :
          policy$1 = policy;
          break;
      case "Undecided" :
          policy$1 = await platformDeps.askUserAboutDownloadPolicy();
          break;
      
    }
    switch (policy$1) {
      case "Yes" :
          await Config$AgdaModeVscode.Connection.DownloadPolicy.set("Yes");
          var path = await platformDeps.alreadyDownloaded2(globalStorageUri)();
          var downloadResult;
          if (path !== undefined) {
            downloadResult = {
              TAG: "Ok",
              _0: path
            };
          } else {
            var error = await platformDeps.downloadLatestALS2(memento, globalStorageUri)(platform._0);
            downloadResult = error.TAG === "Ok" ? ({
                  TAG: "Ok",
                  _0: error._0
                }) : ({
                  TAG: "Error",
                  _0: {
                    TAG: "Construction",
                    _0: Connection__Error$AgdaModeVscode.Construction.addDownloadError(constructionError, error._0)
                  }
                });
          }
          if (downloadResult.TAG !== "Ok") {
            return {
                    TAG: "Error",
                    _0: downloadResult._0
                  };
          }
          var path$1 = downloadResult._0;
          var connection = await makeWithRawPath(path$1);
          if (connection.TAG !== "Ok") {
            return {
                    TAG: "Error",
                    _0: {
                      TAG: "Construction",
                      _0: Connection__Error$AgdaModeVscode.Construction.addEndpointError(Connection__Error$AgdaModeVscode.Construction.make(), path$1, connection._0)
                    }
                  };
          }
          var connection$1 = connection._0;
          await Config$AgdaModeVscode.Connection.addAgdaPath2(getPath(connection$1));
          await Memento$AgdaModeVscode.Module.PickedConnection.set(memento, getPath(connection$1));
          return {
                  TAG: "Ok",
                  _0: connection$1
                };
      case "No" :
      case "Undecided" :
          break;
      
    }
    await Config$AgdaModeVscode.Connection.DownloadPolicy.set("No");
    return {
            TAG: "Error",
            _0: {
              TAG: "Construction",
              _0: constructionError
            }
          };
  }
  var errors = Connection__Error$AgdaModeVscode.Construction.addDownloadError(constructionError, {
        TAG: "PlatformNotSupported",
        _0: platform._0
      });
  return {
          TAG: "Error",
          _0: {
            TAG: "Construction",
            _0: errors
          }
        };
}

async function make(platformDeps, memento, globalStorageUri, paths, commands, logChannel) {
  var logConnection = function (connection) {
    if (connection.TAG === "Agda") {
      return Chan$AgdaModeVscode.emit(logChannel, {
                  TAG: "Connection",
                  _0: {
                    TAG: "ConnectedToAgda",
                    _0: connection._1,
                    _1: connection._2
                  }
                });
    } else {
      return Chan$AgdaModeVscode.emit(logChannel, {
                  TAG: "Connection",
                  _0: {
                    TAG: "ConnectedToALS",
                    _0: connection._1,
                    _1: connection._2,
                    _2: connection._3
                  }
                });
    }
  };
  var connection = await fromPathsAndCommands2(platformDeps, memento, paths, commands);
  if (connection.TAG === "Ok") {
    var connection$1 = connection._0;
    logConnection(connection$1);
    await Config$AgdaModeVscode.Connection.addAgdaPath2(getPath(connection$1));
    await Memento$AgdaModeVscode.Module.PickedConnection.set(memento, getPath(connection$1));
    return {
            TAG: "Ok",
            _0: connection$1
          };
  }
  var connection$2 = await fromDownloads2(platformDeps, memento, globalStorageUri, connection._0);
  if (connection$2.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: connection$2._0
          };
  }
  var connection$3 = connection$2._0;
  logConnection(connection$3);
  await Config$AgdaModeVscode.Connection.addAgdaPath2(getPath(connection$3));
  await Memento$AgdaModeVscode.Module.PickedConnection.set(memento, getPath(connection$3));
  return {
          TAG: "Ok",
          _0: connection$3
        };
}

async function sendRequest(connection, $$document, request, handler) {
  var encodeRequest = function ($$document, version) {
    var filepath = Parser$AgdaModeVscode.filepath($$document.fileName);
    var libraryPath = Config$AgdaModeVscode.getLibraryPath();
    var highlightingMethod = Config$AgdaModeVscode.Highlighting.getHighlightingMethod();
    var backend = Config$AgdaModeVscode.getBackend();
    return Request$AgdaModeVscode.encode($$document, version, filepath, backend, libraryPath, highlightingMethod, request);
  };
  if (connection.TAG === "Agda") {
    var version = connection._2;
    var conn = connection._0;
    var error = await Connection__Endpoint__Agda$AgdaModeVscode.sendRequest(conn, encodeRequest($$document, version), handler);
    if (error.TAG === "Ok") {
      return {
              TAG: "Ok",
              _0: undefined
            };
    }
    await destroy({
          TAG: "Agda",
          _0: conn,
          _1: connection._1,
          _2: version
        }, Chan$AgdaModeVscode.make());
    return {
            TAG: "Error",
            _0: {
              TAG: "Agda",
              _0: error._0
            }
          };
  }
  var conn$1 = connection._0;
  var error$1 = await Connection__Endpoint__ALS$AgdaModeVscode.sendRequest(conn$1, encodeRequest($$document, conn$1.agdaVersion), handler);
  if (error$1.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
  await destroy({
        TAG: "ALS",
        _0: conn$1,
        _1: connection._1,
        _2: connection._2,
        _3: connection._3
      }, Chan$AgdaModeVscode.make());
  return {
          TAG: "Error",
          _0: {
            TAG: "ALS",
            _0: error$1._0
          }
        };
}

var Module = {
  make: make,
  destroy: destroy,
  fromPathsAndCommands: fromPathsAndCommands,
  fromDownloads: fromDownloads,
  sendRequest: sendRequest,
  findCommands: findCommands
};

var $$Error;

var Agda;

var ALS;

var Endpoint;

var URI;

exports.$$Error = $$Error;
exports.Agda = Agda;
exports.ALS = ALS;
exports.Endpoint = Endpoint;
exports.URI = URI;
exports.Module = Module;
exports.make = make;
exports.destroy = destroy;
exports.fromPathsAndCommands = fromPathsAndCommands;
exports.fromDownloads = fromDownloads;
exports.sendRequest = sendRequest;
exports.findCommands = findCommands;
/* Chan-AgdaModeVscode Not a pure module */
