// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Nodefs = require("node:fs");
var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Nodepath = require("node:path");
var Core__List = require("@rescript/core/lib/js/src/Core__List.bs.js");
var Util$AgdaModeVscode = require("../Util/Util.bs.js");
var Config$AgdaModeVscode = require("../Config.bs.js");
var Parser$AgdaModeVscode = require("../Parser/Parser.bs.js");
var Request$AgdaModeVscode = require("../Request.bs.js");
var Node__Fs$AgdaModeVscode = require("../Node/Node__Fs.bs.js");
var Json_Encode$JsonCombinators = require("@glennsl/rescript-json-combinators/lib/js/src/Json_Encode.bs.js");
var Connection__URI$AgdaModeVscode = require("./Connection__URI.bs.js");
var Connection__Target$AgdaModeVscode = require("./Connection__Target.bs.js");
var Connection__Command$AgdaModeVscode = require("./Connection__Command.bs.js");
var Connection__Download$AgdaModeVscode = require("./Connection__Download.bs.js");
var Connection__Target__ALS$AgdaModeVscode = require("./Target/ALS/Connection__Target__ALS.bs.js");
var Connection__Target__Agda$AgdaModeVscode = require("./Target/Agda/Connection__Target__Agda.bs.js");
var Connection__Download__GitHub$AgdaModeVscode = require("./Download/Connection__Download__GitHub.bs.js");
var Connection__Download__Platform$AgdaModeVscode = require("./Download/Connection__Download__Platform.bs.js");

function getFromConfig() {
  var param = {
    commandLineOptions: Config$AgdaModeVscode.Connection.getCommandLineOptions()
  };
  return {
          commandLineOptions: Json_Encode$JsonCombinators.array(function (prim) {
                  return prim;
                })(param.commandLineOptions)
        };
}

async function destroy(connection) {
  if (connection === undefined) {
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
  if (connection.TAG === "Agda") {
    await Connection__Target__Agda$AgdaModeVscode.destroy(connection._0);
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
  var error = await Connection__Target__ALS$AgdaModeVscode.destroy(connection._0);
  if (error.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: undefined
          };
  } else {
    return {
            TAG: "Error",
            _0: {
              TAG: "ALS",
              _0: error._0
            }
          };
  }
}

async function makeWithTarget(target) {
  if (target.TAG === "Agda") {
    var path = target._1;
    var method_1 = [];
    var method = {
      TAG: "ViaPipe",
      _0: path,
      _1: method_1,
      _2: undefined
    };
    var error = await Connection__Target__Agda$AgdaModeVscode.make(method, target._0, path);
    if (error.TAG === "Ok") {
      return {
              TAG: "Ok",
              _0: {
                TAG: "Agda",
                _0: error._0,
                _1: target
              }
            };
    } else {
      return {
              TAG: "Error",
              _0: {
                TAG: "Agda",
                _0: error._0,
                _1: path
              }
            };
    }
  }
  var error$1 = await Connection__Target__ALS$AgdaModeVscode.make(target._2, getFromConfig());
  if (error$1.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: {
              TAG: "ALS",
              _0: error$1._0,
              _1: target
            }
          };
  } else {
    return {
            TAG: "Error",
            _0: {
              TAG: "ALS",
              _0: error$1._0
            }
          };
  }
}

async function findCommands(commands) {
  var commands$1 = Core__List.fromArray(commands);
  var step = async function (acc, commands) {
    if (!commands) {
      return {
              TAG: "Error",
              _0: acc
            };
    }
    var path = await Connection__Command$AgdaModeVscode.search(commands.hd, undefined);
    if (path.TAG === "Ok") {
      return {
              TAG: "Ok",
              _0: path._0
            };
    } else {
      return await step({
                  hd: path._0,
                  tl: acc
                }, commands.tl);
    }
  };
  var error = await step(/* [] */0, commands$1);
  if (error.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: error._0
          };
  } else {
    return {
            TAG: "Error",
            _0: Core__List.toArray(error._0)
          };
  }
}

async function fromPathsAndCommands(memento, paths, commands) {
  var targetErrors = await Connection__Target$AgdaModeVscode.getPicked(memento, paths);
  if (targetErrors.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: targetErrors._0
          };
  }
  var commandErrors = await findCommands(commands);
  if (commandErrors.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: commandErrors._0
          };
  }
  var attempts_targets = targetErrors._0;
  var attempts_commands = commandErrors._0;
  var attempts = {
    targets: attempts_targets,
    commands: attempts_commands
  };
  return {
          TAG: "Error",
          _0: attempts
        };
}

async function fromDownloads(attempts, platform, getDownloadPolicyFromUser, alreadyDownloaded, downloadLatestALS) {
  if (platform.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: {
              TAG: "Aggregated",
              _0: {
                TAG: "PlatformNotSupported",
                _0: attempts,
                _1: platform._0
              }
            }
          };
  }
  var policy = Config$AgdaModeVscode.Connection.DownloadPolicy.get();
  var policy$1;
  switch (policy) {
    case "Yes" :
    case "No" :
        policy$1 = policy;
        break;
    case "Undecided" :
        policy$1 = await getDownloadPolicyFromUser();
        break;
    
  }
  switch (policy$1) {
    case "Yes" :
        await Config$AgdaModeVscode.Connection.DownloadPolicy.set("Yes");
        var target = await alreadyDownloaded();
        if (target !== undefined) {
          await Config$AgdaModeVscode.Connection.addAgdaPath(Connection__Target$AgdaModeVscode.toURI(target));
          return {
                  TAG: "Ok",
                  _0: target
                };
        }
        var error = await downloadLatestALS(platform._0);
        if (error.TAG !== "Ok") {
          return {
                  TAG: "Error",
                  _0: {
                    TAG: "Aggregated",
                    _0: {
                      TAG: "DownloadALS",
                      _0: attempts,
                      _1: error._0
                    }
                  }
                };
        }
        var target$1 = error._0;
        await Config$AgdaModeVscode.Connection.addAgdaPath(Connection__Target$AgdaModeVscode.toURI(target$1));
        return {
                TAG: "Ok",
                _0: target$1
              };
    case "No" :
    case "Undecided" :
        break;
    
  }
  await Config$AgdaModeVscode.Connection.DownloadPolicy.set("No");
  return {
          TAG: "Error",
          _0: {
            TAG: "Aggregated",
            _0: {
              TAG: "NoDownloadALS",
              _0: attempts
            }
          }
        };
}

async function make(memento, paths, commands, platform, getDownloadPolicyFromUser, alreadyDownloaded, downloadLatestALS) {
  var attempts = await fromPathsAndCommands(memento, paths, commands);
  if (attempts.TAG === "Ok") {
    var target = attempts._0;
    await Config$AgdaModeVscode.Connection.addAgdaPath(Connection__Target$AgdaModeVscode.toURI(target));
    return await makeWithTarget(target);
  }
  var error = await fromDownloads(attempts._0, platform, getDownloadPolicyFromUser, alreadyDownloaded, downloadLatestALS);
  if (error.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: error._0
          };
  }
  var target$1 = error._0;
  await Config$AgdaModeVscode.Connection.addAgdaPath(Connection__Target$AgdaModeVscode.toURI(target$1));
  return await makeWithTarget(target$1);
}

async function sendRequest(connection, $$document, request, handler) {
  var encodeRequest = function ($$document, version) {
    var filepath = Parser$AgdaModeVscode.filepath($$document.fileName);
    var libraryPath = Config$AgdaModeVscode.getLibraryPath();
    var highlightingMethod = Config$AgdaModeVscode.Highlighting.getHighlightingMethod();
    var backend = Config$AgdaModeVscode.getBackend();
    return Request$AgdaModeVscode.encode($$document, version, filepath, backend, libraryPath, highlightingMethod, request);
  };
  if (connection.TAG === "Agda") {
    var target = connection._1;
    var conn = connection._0;
    var match = Connection__Target__Agda$AgdaModeVscode.getInfo(conn);
    var error = await Connection__Target__Agda$AgdaModeVscode.sendRequest(conn, encodeRequest($$document, match[0]), handler);
    if (error.TAG === "Ok") {
      return {
              TAG: "Ok",
              _0: target
            };
    }
    await destroy({
          TAG: "Agda",
          _0: conn,
          _1: target
        });
    return {
            TAG: "Error",
            _0: {
              TAG: "Agda",
              _0: error._0,
              _1: match[1]
            }
          };
  }
  var target$1 = connection._1;
  var conn$1 = connection._0;
  var error$1 = await Connection__Target__ALS$AgdaModeVscode.sendRequest(conn$1, encodeRequest($$document, conn$1.agdaVersion), handler);
  if (error$1.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: target$1
          };
  }
  await destroy({
        TAG: "ALS",
        _0: conn$1,
        _1: target$1
      });
  return {
          TAG: "Error",
          _0: {
            TAG: "ALS",
            _0: error$1._0
          }
        };
}

async function getInstalledTargetsAndPersistThem(globalStorageUri) {
  var pairs = await Promise.all(Config$AgdaModeVscode.Connection.getAgdaPaths().map(async function (uri) {
            var target = await Connection__Target$AgdaModeVscode.fromURI(uri);
            return [
                    Connection__URI$AgdaModeVscode.toString(uri),
                    target
                  ];
          }));
  var dict = Object.fromEntries(pairs);
  var agda = await findCommands(["agda"]);
  if (agda.TAG === "Ok") {
    var agda$1 = agda._0;
    var uri = Connection__Target$AgdaModeVscode.toURI(agda$1);
    await Config$AgdaModeVscode.Connection.addAgdaPath(uri);
    dict[Connection__URI$AgdaModeVscode.toString(uri)] = {
      TAG: "Ok",
      _0: agda$1
    };
  }
  var als = await findCommands(["als"]);
  if (als.TAG === "Ok") {
    var als$1 = als._0;
    var uri$1 = Connection__Target$AgdaModeVscode.toURI(als$1);
    await Config$AgdaModeVscode.Connection.addAgdaPath(uri$1);
    dict[Connection__URI$AgdaModeVscode.toString(uri$1)] = {
      TAG: "Ok",
      _0: als$1
    };
  }
  var downloadPath = globalStorageUri.fsPath;
  var exit = 0;
  var folders;
  try {
    folders = await Node__Fs$AgdaModeVscode.readdir(downloadPath);
    exit = 1;
  }
  catch (exn){
    
  }
  if (exit === 1) {
    await Promise.all(folders.map(async function (folder) {
              var folderPath = Nodepath.join(downloadPath, folder);
              var files;
              try {
                files = await Node__Fs$AgdaModeVscode.readdir(folderPath);
              }
              catch (exn){
                return ;
              }
              var agdaFile = files.find(function (file) {
                    if (file === "agda") {
                      return true;
                    } else {
                      return file === "agda.exe";
                    }
                  });
              var alsFile = files.find(function (file) {
                    if (file === "als") {
                      return true;
                    } else {
                      return file === "als.exe";
                    }
                  });
              if (agdaFile !== undefined) {
                var executablePath = Nodepath.join(folderPath, agdaFile);
                var target = await Connection__Target$AgdaModeVscode.fromRawPath(executablePath);
                if (target.TAG === "Ok") {
                  var target$1 = target._0;
                  var uri = Connection__Target$AgdaModeVscode.toURI(target$1);
                  await Config$AgdaModeVscode.Connection.addAgdaPath(uri);
                  dict[Connection__URI$AgdaModeVscode.toString(uri)] = {
                    TAG: "Ok",
                    _0: target$1
                  };
                }
                
              }
              if (alsFile === undefined) {
                return ;
              }
              var executablePath$1 = Nodepath.join(folderPath, alsFile);
              var target$2 = await Connection__Target$AgdaModeVscode.fromRawPath(executablePath$1);
              if (target$2.TAG !== "Ok") {
                return ;
              }
              var target$3 = target$2._0;
              var uri$1 = Connection__Target$AgdaModeVscode.toURI(target$3);
              await Config$AgdaModeVscode.Connection.addAgdaPath(uri$1);
              dict[Connection__URI$AgdaModeVscode.toString(uri$1)] = {
                TAG: "Ok",
                _0: target$3
              };
            }));
  }
  return dict;
}

function makeAgdaLanguageServerRepo(memento, globalStorageUri) {
  return {
          username: "agda",
          repository: "agda-language-server",
          userAgent: "agda/agda-mode-vscode",
          memento: memento,
          globalStoragePath: globalStorageUri.fsPath,
          cacheInvalidateExpirationSecs: 86400
        };
}

var Module = {
  make: make,
  destroy: destroy,
  fromPathsAndCommands: fromPathsAndCommands,
  fromDownloads: fromDownloads,
  sendRequest: sendRequest,
  findCommands: findCommands,
  getInstalledTargetsAndPersistThem: getInstalledTargetsAndPersistThem,
  makeAgdaLanguageServerRepo: makeAgdaLanguageServerRepo
};

async function getALSReleaseManifest(memento, globalStorageUri) {
  var match = await Connection__Download__GitHub$AgdaModeVscode.ReleaseManifest.$$fetch(makeAgdaLanguageServerRepo(memento, globalStorageUri));
  var error = match[0];
  if (error.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: error._0
          };
  } else {
    return {
            TAG: "Error",
            _0: {
              TAG: "CannotFetchALSReleases",
              _0: error._0
            }
          };
  }
}

async function chooseAssetByPlatform(release, platform) {
  var assetName = Connection__Download__Platform$AgdaModeVscode.toAssetName(platform);
  return release.assets.filter(function (asset) {
              return asset.name.endsWith(assetName + ".zip");
            });
}

async function getTarget(memento, globalStorageUri, platform) {
  var error = await getALSReleaseManifest(memento, globalStorageUri);
  if (error.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: error._0
          };
  }
  var laterReleases = error._0.filter(function (release) {
        return Caml_obj.greaterequal(new Date(release.published_at), new Date("2024-12-18"));
      });
  var pinnedRelease = laterReleases.find(function (release) {
        return release.name === "v0.2.7.0.1.5";
      });
  if (pinnedRelease === undefined) {
    return {
            TAG: "Error",
            _0: "CannotFindCompatibleALSRelease"
          };
  }
  var getAgdaVersion = function (asset) {
    return asset.name.replace(/als-Agda-/, "").replace(/-.*/, "");
  };
  var assets = await chooseAssetByPlatform(pinnedRelease, platform);
  var result = assets.toSorted(function (a, b) {
            return Util$AgdaModeVscode.Version.compare(getAgdaVersion(b), getAgdaVersion(a));
          }).map(function (asset) {
          return {
                  release: pinnedRelease,
                  asset: asset,
                  saveAsFileName: "latest-als"
                };
        })[0];
  if (result !== undefined) {
    return {
            TAG: "Ok",
            _0: result
          };
  } else {
    return {
            TAG: "Error",
            _0: "CannotFindCompatibleALSRelease"
          };
  }
}

function download(memento, globalStorageUri) {
  return async function (platform) {
    var error = await getTarget(memento, globalStorageUri, platform);
    if (error.TAG === "Ok") {
      return await Connection__Download$AgdaModeVscode.download(memento, globalStorageUri, error._0);
    } else {
      return {
              TAG: "Error",
              _0: error._0
            };
    }
  };
}

function alreadyDownloaded(globalStorageUri) {
  return async function () {
    var path = Nodepath.join(globalStorageUri.fsPath, "latest-als");
    var val;
    try {
      val = await Nodefs.promises.access(path);
    }
    catch (exn){
      return ;
    }
    var target = await Connection__Target$AgdaModeVscode.fromRawPath(path);
    if (target.TAG === "Ok") {
      return target._0;
    }
    
  };
}

var LatestALS = {
  getALSReleaseManifest: getALSReleaseManifest,
  chooseAssetByPlatform: chooseAssetByPlatform,
  getTarget: getTarget,
  download: download,
  alreadyDownloaded: alreadyDownloaded
};

var $$Error;

var Agda;

var ALS;

var Target;

var URI;

exports.$$Error = $$Error;
exports.Agda = Agda;
exports.ALS = ALS;
exports.Target = Target;
exports.URI = URI;
exports.Module = Module;
exports.make = make;
exports.destroy = destroy;
exports.fromPathsAndCommands = fromPathsAndCommands;
exports.fromDownloads = fromDownloads;
exports.sendRequest = sendRequest;
exports.findCommands = findCommands;
exports.getInstalledTargetsAndPersistThem = getInstalledTargetsAndPersistThem;
exports.makeAgdaLanguageServerRepo = makeAgdaLanguageServerRepo;
exports.LatestALS = LatestALS;
/* node:fs Not a pure module */
