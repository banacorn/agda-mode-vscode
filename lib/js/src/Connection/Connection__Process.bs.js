// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Nodeos = require("node:os");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Core__Option = require("@rescript/core/lib/js/src/Core__Option.bs.js");
var Nodechild_process = require("node:child_process");
var Chan$AgdaModeVscode = require("../Util/Chan.bs.js");
var Util$AgdaModeVscode = require("../Util/Util.bs.js");

function toString(x) {
  if (typeof x !== "object") {
    return "Process destroyed";
  } else if (x.TAG === "OnError") {
    return x._0;
  } else {
    return "Process exited with code " + String(x._0);
  }
}

var $$Event = {
  toString: toString
};

function errorMessageIndicatesNotFound(msg) {
  if (/command not found/.test(msg) || /No such file or directory/.test(msg) || /not found/.test(msg) || /The system cannot find the path specified/.test(msg)) {
    return true;
  } else {
    return msg.endsWith("ENOENT");
  }
}

function make(path, args) {
  var chan = Chan$AgdaModeVscode.make();
  var stderr = {
    contents: ""
  };
  var $$process = Nodechild_process.spawn("\"" + path + "\"", args, {shell : true});
  Core__Option.forEach(Caml_option.nullable_to_opt($$process.stdout), (function (stream) {
          stream.on("data", (function (chunk) {
                  Chan$AgdaModeVscode.emit(chan, {
                        TAG: "Stdout",
                        _0: chunk.toString()
                      });
                }));
        }));
  Core__Option.forEach(Caml_option.nullable_to_opt($$process.stderr), (function (stream) {
          stream.on("data", (function (chunk) {
                  Chan$AgdaModeVscode.emit(chan, {
                        TAG: "Stderr",
                        _0: chunk.toString()
                      });
                  stderr.contents = stderr.contents + chunk.toString();
                }));
        }));
  var promiseOnClose = new Promise((function (resolve, param) {
          Core__Option.forEach(Caml_option.nullable_to_opt($$process.stdin), (function (stream) {
                  stream.on("close", (function () {
                          resolve(0);
                        }));
                }));
          $$process.on("close", (function (code) {
                  resolve(code);
                }));
        }));
  var promiseOnExit = new Promise((function (resolve, param) {
          $$process.on("exit", (function (code) {
                  resolve(code);
                }));
        }));
  $$process.on("disconnect", (function () {
            Chan$AgdaModeVscode.emit(chan, {
                  TAG: "Event",
                  _0: "OnDestroyed"
                });
          })).on("error", (function (exn) {
          Chan$AgdaModeVscode.emit(chan, {
                TAG: "Event",
                _0: {
                  TAG: "OnError",
                  _0: Util$AgdaModeVscode.JsError.toString(exn)
                }
              });
        }));
  Promise.race([
          promiseOnExit,
          promiseOnClose
        ]).then(function (exitCode) {
        Chan$AgdaModeVscode.emit(chan, {
              TAG: "Event",
              _0: {
                TAG: "OnExit",
                _0: exitCode
              }
            });
      });
  return {
          chan: chan,
          status: {
            TAG: "Created",
            _0: $$process
          }
        };
}

function destroy(self) {
  var $$process = self.status;
  if (typeof $$process !== "object") {
    return new Promise((function (resolve, param) {
                  resolve();
                }));
  }
  if ($$process.TAG !== "Created") {
    return $$process._0;
  }
  var $$process$1 = $$process._0;
  var promise = new Promise((function (resolve, param) {
          Chan$AgdaModeVscode.on(self.chan, (function (x) {
                  switch (x.TAG) {
                    case "Stdout" :
                    case "Stderr" :
                        return ;
                    case "Event" :
                        var tmp = x._0;
                        if (typeof tmp !== "object") {
                          return ;
                        }
                        if (tmp.TAG === "OnError") {
                          return ;
                        }
                        Chan$AgdaModeVscode.destroy(self.chan);
                        self.status = "Destroyed";
                        return resolve();
                    
                  }
                }));
          $$process$1.kill("SIGTERM");
        }));
  self.status = {
    TAG: "Destroying",
    _0: promise
  };
  return promise;
}

function send(self, request) {
  var $$process = self.status;
  if (typeof $$process !== "object") {
    return false;
  }
  if ($$process.TAG !== "Created") {
    return false;
  }
  var payload = Buffer.from(request + Nodeos.EOL);
  Core__Option.forEach(Caml_option.nullable_to_opt($$process._0.stdin), (function (stream) {
          stream.write(payload);
        }));
  return true;
}

function onOutput(self, callback) {
  return Chan$AgdaModeVscode.on(self.chan, (function (output) {
                switch (output.TAG) {
                  case "Stdout" :
                  case "Stderr" :
                      return callback(output);
                  case "Event" :
                      var tmp = output._0;
                      if (typeof tmp !== "object") {
                        return callback(output);
                      }
                      if (tmp.TAG === "OnError") {
                        return callback(output);
                      }
                      var match = self.status;
                      if (typeof match !== "object" || match.TAG === "Created") {
                        return callback(output);
                      } else {
                        return ;
                      }
                  
                }
              }));
}

var Module = {
  make: make,
  destroy: destroy,
  send: send,
  onOutput: onOutput
};

exports.$$Event = $$Event;
exports.errorMessageIndicatesNotFound = errorMessageIndicatesNotFound;
exports.Module = Module;
exports.make = make;
exports.destroy = destroy;
exports.send = send;
exports.onOutput = onOutput;
/* node:os Not a pure module */
