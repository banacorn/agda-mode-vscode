// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Vscode = require("vscode");
var Js_array = require("rescript/lib/js/js_array.js");
var Core__Option = require("@rescript/core/lib/js/src/Core__Option.bs.js");
var VscodeLanguageclient = require("vscode-languageclient");

var Message = {};

function toEnum(x) {
  if (x === "Continue") {
    return 1;
  } else {
    return 2;
  }
}

var ErrorAction = {
  toEnum: toEnum
};

function toEnum$1(x) {
  if (x === "DoNotRestart") {
    return 1;
  } else {
    return 2;
  }
}

var CloseAction = {
  toEnum: toEnum$1
};

function make(error, closed) {
  var error$1 = function (a, b, c) {
    return toEnum(error(a, b, c));
  };
  var closed$1 = function () {
    return toEnum$1(closed());
  };
  return {
          error: error$1,
          closed: closed$1
        };
}

function makeDefault(name, maxRestartCount) {
  var restarts = [];
  return make((function (param, param$1, count) {
                if (count !== undefined && count <= 3) {
                  return "Continue";
                } else {
                  return "Shutdown";
                }
              }), (function () {
                Js_array.push(Date.now(), restarts);
                var length = restarts.length;
                if (length <= maxRestartCount) {
                  return "Restart";
                }
                var diff = Core__Option.flatMap(restarts[length - 1 | 0], (function (latest) {
                        return Core__Option.map(restarts[0], (function (first) {
                                      return latest - first;
                                    }));
                      }));
                if (diff === undefined) {
                  return "Restart";
                }
                if ((diff | 0) <= 180000) {
                  var max = String(maxRestartCount + 1 | 0);
                  Vscode.window.showErrorMessage("The " + name + "server crashed " + max + " times in the last 3 minutes. The server will not be restarted.");
                  return "DoNotRestart";
                }
                restarts.shift();
                return "Restart";
              }));
}

var ErrorHandler = {
  make: make,
  makeDefault: makeDefault
};

var make$1 = (function (documentSelector, synchronize, errorHandler, initializationOptions) {
      return {
		    documentSelector: documentSelector,
		    synchronize: synchronize,
        errorHandler: errorHandler,
        initializationOptions: initializationOptions
      }
    });

var makeWithUriConverters = (function (documentSelector, synchronize, errorHandler, initializationOptions, uriConverters) {
      return {
        documentSelector: documentSelector,
        synchronize: synchronize,
        errorHandler: errorHandler,
        initializationOptions: initializationOptions,
        uriConverters: uriConverters
      }
    });

var setConfigurationMiddleware = (function (options) {
      if (!options || typeof options !== 'object') {
        return;
      }

      const safeArray = (value) => Array.isArray(value) ? value.filter((item) => typeof item === 'string') : [];

      const readCommandLineOptions = () => {
        try {
          const vscode = require('vscode');
          const config = vscode.workspace.getConfiguration('agdaMode');
          const raw = config.get('connection.commandLineOptions');
          if (typeof raw === 'string') {
            return raw.trim().length === 0 ? [] : raw.trim().split(/\s+/);
          }
          if (Array.isArray(raw)) {
            return safeArray(raw);
          }
        } catch (_) {
          // ignore and fall back to empty array
        }
        return [];
      };

      const createPayload = () => ({ commandLineOptions: readCommandLineOptions() });

      options.middleware = options.middleware || {};
      options.middleware.workspace = options.middleware.workspace || {};
      options.middleware.workspace.configuration = (params) => {
        const count = params && Array.isArray(params.items) ? params.items.length : 1;
        const results = [];
        for (let i = 0; i < count; i += 1) {
          results.push(createPayload());
        }
        return Promise.resolve(results);
      };
    });

var LanguageClientOptions = {
  make: make$1,
  makeWithUriConverters: makeWithUriConverters,
  setConfigurationMiddleware: setConfigurationMiddleware
};

var makeWithCommand = (function (command, args, options) {
      return { 
        command: command, 
        args: args, 
        options: options
       }
    });

var makeWithStreamInfo = (function (port, host) {
      const net = require('net');
      const socket = net.createConnection({ port: port, host: host })
      return (() => { return new Promise(resolve => resolve({
        writer: socket,
        reader: socket
      })
      )})
    });

var makeWithWASM = ((wasmSetup) => {
      const createTransport = () => {
        const attemptWithSetup = () => wasmSetup.factory.createServer(
          wasmSetup.memfsAgdaDataDir,
          {},
          {
            runSetupFirst: true,
            setupCallback(exitCode, stderr) {
              if (exitCode !== 0) {
                console.warn('[agda-mode] ALS WASM setup exited with code ' + exitCode + ': ' + stderr);
              }
            },
          },
        );

        const attemptWithoutSetup = () => wasmSetup.factory.createServer(
          wasmSetup.memfsAgdaDataDir,
          {},
          { runSetupFirst: false },
        );

        return Promise.resolve()
          .then(attemptWithSetup)
          .catch((error) => {
            const message = error && (error.message || String(error));
            if (typeof message === 'string' && message.includes('--setup')) {
              return attemptWithoutSetup();
            }
            throw error;
          });
      };

        Object.defineProperty(createTransport, "__agdaModeWasm", {
          value: true,
          enumerable: false,
          configurable: false,
          writable: false,
        });

        return createTransport;
      });

var ServerOptions = {
  makeWithCommand: makeWithCommand,
  makeWithStreamInfo: makeWithStreamInfo,
  makeWithWASM: makeWithWASM
};

function toVSCodeDisposable(self) {
  return new Vscode.Disposable((function () {
                self.dispose();
              }));
}

var Disposable = {
  toVSCodeDisposable: toVSCodeDisposable
};

var createStreamBackedWorker = ((factory) => {
        const messageListeners = new Set();
        const errorListeners = new Set();
        let onmessageHandler = null;
        let settledTransport = null;
        let disposables = [];

        const emitMessage = (data) => {
          const event = { data };
          if (typeof onmessageHandler === "function") {
            onmessageHandler(event);
          }
          messageListeners.forEach((listener) => listener(event));
        };

        const emitError = (error) => {
          console.error('[agda-mode] worker emitError', error instanceof Error ? error.stack : JSON.stringify(error, null, 2));
          const event = { type: "error", error };
          errorListeners.forEach((listener) => listener(event));
        };

        const ensureTransport = Promise.resolve()
          .then(() => (typeof factory === "function" ? factory() : factory))
          .then((transport) => {
            if (!transport || typeof transport !== "object") {
              throw new Error("agda-mode: invalid WASM transport");
            }
            const reader = transport.reader;
            const writer = transport.writer;
            if (!reader || typeof reader.listen !== "function") {
              throw new Error("agda-mode: WASM transport missing reader");
            }
            if (!writer || typeof writer.write !== "function") {
              throw new Error("agda-mode: WASM transport missing writer");
            }
            settledTransport = transport;
            const listenerDisposable = reader.listen((data) => {
              emitMessage(data);
            });
            if (listenerDisposable && typeof listenerDisposable.dispose === "function") {
              disposables.push(listenerDisposable);
            }
            if (typeof reader.onError === "function") {
              const errorDisposable = reader.onError((arg) => emitError(Array.isArray(arg) ? arg[0] : arg));
              if (errorDisposable && typeof errorDisposable.dispose === "function") {
                disposables.push(errorDisposable);
              }
            }
            if (typeof reader.onClose === "function") {
              const closeDisposable = reader.onClose(() => emitError(new Error("Language server stream closed")));
              if (closeDisposable && typeof closeDisposable.dispose === "function") {
                disposables.push(closeDisposable);
              }
            }
            return transport;
          });

        ensureTransport.catch((error) => {
          emitError(error);
          throw error;
        });

        const worker = {};
        Object.defineProperty(worker, "onmessage", {
          get() {
            return onmessageHandler;
          },
          set(handler) {
            onmessageHandler = typeof handler === "function" ? handler : null;
          },
          enumerable: true,
          configurable: true,
        });

        worker.addEventListener = (type, listener) => {
          if (type === "message") {
            messageListeners.add(listener);
          } else if (type === "error") {
            errorListeners.add(listener);
          }
        };

        worker.removeEventListener = (type, listener) => {
          if (type === "message") {
            messageListeners.delete(listener);
          } else if (type === "error") {
            errorListeners.delete(listener);
          }
        };

        worker.postMessage = (message) => {
          ensureTransport
            .then((transport) => {
              transport.writer.write(message).catch(emitError);
            })
            .catch(() => {});
        };

        worker.terminate = () => {
          disposables.forEach((disposable) => {
            try {
              if (disposable && typeof disposable.dispose === "function") {
                disposable.dispose();
              }
            } catch (_) {}
          });
          disposables = [];
          if (settledTransport && settledTransport.writer && typeof settledTransport.writer.end === "function") {
            try {
              settledTransport.writer.end();
            } catch (_) {}
          }
          settledTransport = null;
        };

        return worker;
      });

function makeShim(_languageClientCtor, _createStreamBackedWorker) {
  return ((id, name, serverOptions, clientOptions) => {

      let ctor = _languageClientCtor;
      let createStreamBackedWorker = _createStreamBackedWorker;
      if (ctor && typeof ctor !== "function" && ctor.default && typeof ctor.default === "function") {
        ctor = ctor.default;
      }
      if (typeof ctor !== "function") {
        throw new Error("agda-mode: unable to locate vscode-languageclient constructor");
      }

      const ctorArity = typeof ctor.length === "number" ? ctor.length : 0;
      if (ctorArity === 4) {
        if (typeof serverOptions !== "function" || !serverOptions.__agdaModeWasm) {
          throw new Error("agda-mode: browser LanguageClient requires WASM transport");
        }
        const worker = createStreamBackedWorker(serverOptions);
        return new ctor(id, name, clientOptions, worker);
      }

      return new ctor(id, name, serverOptions, clientOptions);
    });
}

var make$2 = makeShim(VscodeLanguageclient.LanguageClient, createStreamBackedWorker);

var LanguageClient = {
  createStreamBackedWorker: createStreamBackedWorker,
  makeShim: makeShim,
  make: make$2
};

exports.Message = Message;
exports.ErrorAction = ErrorAction;
exports.CloseAction = CloseAction;
exports.ErrorHandler = ErrorHandler;
exports.LanguageClientOptions = LanguageClientOptions;
exports.ServerOptions = ServerOptions;
exports.Disposable = Disposable;
exports.LanguageClient = LanguageClient;
/* make Not a pure module */
