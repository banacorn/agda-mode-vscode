// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Vscode = require("vscode");
var Nodepath = require("node:path");
var Core__Array = require("@rescript/core/lib/js/src/Core__Array.bs.js");
var FS$AgdaModeVscode = require("../../FS.bs.js");
var Util$AgdaModeVscode = require("../../Util/Util.bs.js");
var Memento$AgdaModeVscode = require("../../Memento.bs.js");
var Connection__URI$AgdaModeVscode = require("../Shared/Connection__URI.bs.js");
var Connection__Process__Exec$AgdaModeVscode = require("../Shared/Connection__Process__Exec.bs.js");
var Connection__Endpoint__ALS__Error$AgdaModeVscode = require("./ALS/Connection__Endpoint__ALS__Error.bs.js");
var Connection__Endpoint__Agda__Error$AgdaModeVscode = require("./Agda/Connection__Endpoint__Agda__Error.bs.js");

async function checkForPrebuiltDataDirectory(executablePath) {
  var prebuildDataDirPath = Nodepath.join(executablePath, "..", "data");
  var prebuildDataDirURI = Vscode.Uri.file(prebuildDataDirPath);
  var match = await FS$AgdaModeVscode.stat(prebuildDataDirURI);
  if (match.TAG === "Ok") {
    return Nodepath.join(executablePath, "..", "data");
  }
  
}

function toString(x) {
  if (typeof x !== "object") {
    return "Cannot handle URLs at the moment, this will be supported again in the future";
  }
  switch (x.TAG) {
    case "NotAgdaOrALS" :
        var output = x._0;
        var outputInfo = output === "" ? "no output (empty string)" : "'" + output + "'";
        return "doesn't seem to be an Agda executable or an Agda Language Server. Output received: " + outputInfo;
    case "CannotDetermineAgdaOrALS" :
        return Connection__Process__Exec$AgdaModeVscode.$$Error.toString(x._0);
    case "CannotMakeConnectionWithAgda" :
        return "Cannot make connection with Agda: " + Connection__Endpoint__Agda__Error$AgdaModeVscode.toString(x._0)[1];
    case "CannotMakeConnectionWithALS" :
        return "Cannot make connection with Agda Language Server: " + Connection__Endpoint__ALS__Error$AgdaModeVscode.toString(x._0)[1];
    
  }
}

var $$Error = {
  toString: toString
};

async function probeFilepath(uri) {
  if (uri.TAG !== "FileURI") {
    return {
            TAG: "Error",
            _0: "CannotHandleURLsATM"
          };
  }
  var path = uri._1.fsPath;
  var result = await Connection__Process__Exec$AgdaModeVscode.run(path, ["--version"], undefined);
  if (result.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: {
              TAG: "CannotDetermineAgdaOrALS",
              _0: result._0
            }
          };
  }
  var output = result._0;
  var match = output.match(/Agda version (.*)/);
  if (!(match == null) && match.length === 2) {
    var version = match[1];
    if (version !== undefined) {
      return {
              TAG: "Ok",
              _0: {
                TAG: "Agda",
                _0: version,
                _1: path
              }
            };
    }
    
  }
  var match$1 = output.match(/Agda v(.*) Language Server v(.*)/);
  if (match$1 == null) {
    return {
            TAG: "Error",
            _0: {
              TAG: "NotAgdaOrALS",
              _0: output
            }
          };
  }
  if (match$1.length !== 3) {
    return {
            TAG: "Error",
            _0: {
              TAG: "NotAgdaOrALS",
              _0: output
            }
          };
  }
  var agdaVersion = match$1[1];
  if (agdaVersion === undefined) {
    return {
            TAG: "Error",
            _0: {
              TAG: "NotAgdaOrALS",
              _0: output
            }
          };
  }
  var alsVersion = match$1[2];
  if (alsVersion === undefined) {
    return {
            TAG: "Error",
            _0: {
              TAG: "NotAgdaOrALS",
              _0: output
            }
          };
  }
  var assetPath = await checkForPrebuiltDataDirectory(path);
  var lspOptions;
  if (assetPath !== undefined) {
    var env = Object.fromEntries([[
            "Agda_datadir",
            assetPath
          ]]);
    lspOptions = {
      env: env
    };
  } else {
    lspOptions = undefined;
  }
  return {
          TAG: "Ok",
          _0: {
            TAG: "ALS",
            _0: alsVersion,
            _1: agdaVersion,
            _2: {
              TAG: "ViaPipe",
              _0: path,
              _1: []
            },
            _3: lspOptions
          }
        };
}

async function fromURI(uri) {
  if (uri.TAG !== "FileURI") {
    return {
            TAG: "Error",
            _0: "CannotHandleURLsATM"
          };
  }
  var endpoint = await probeFilepath(uri);
  if (endpoint.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: endpoint._0
          };
  } else {
    return {
            TAG: "Error",
            _0: endpoint._0
          };
  }
}

async function fromRawPath(rawPath) {
  var uri = Connection__URI$AgdaModeVscode.parse(rawPath);
  return await fromURI(uri);
}

function fromVSCodeUri(uri) {
  return fromRawPath(uri.toString());
}

function fromRawPaths(paths) {
  return Promise.all(paths.map(fromRawPath));
}

function toURI(endpoint) {
  if (endpoint.TAG === "Agda") {
    var raw = endpoint._1;
    return {
            TAG: "FileURI",
            _0: raw,
            _1: Vscode.Uri.file(raw)
          };
  }
  var match = endpoint._2;
  if (match.TAG !== "ViaPipe") {
    return {
            TAG: "LspURI",
            _0: match._0,
            _1: match._1
          };
  }
  var raw$1 = match._0;
  return {
          TAG: "FileURI",
          _0: raw$1,
          _1: Vscode.Uri.file(raw$1)
        };
}

async function getPicked(memento, rawSuppliedPaths) {
  var errors = {};
  var suppliedEndpoints = await Promise.all(rawSuppliedPaths.map(async function (path) {
            var endpoint = await fromURI(path);
            if (endpoint.TAG === "Ok") {
              return endpoint._0;
            }
            errors[Connection__URI$AgdaModeVscode.getOriginalPath(path)] = endpoint._0;
          }));
  var suppliedEndpoints$1 = Core__Array.filterMap(suppliedEndpoints, (function (x) {
          return x;
        }));
  var endpoint = suppliedEndpoints$1[0];
  var pickFromSuppliedEndpointsInstead = endpoint !== undefined ? ({
        TAG: "Ok",
        _0: endpoint
      }) : ({
        TAG: "Error",
        _0: errors
      });
  var rawPathFromMemento = Memento$AgdaModeVscode.Module.PickedConnection.get(memento);
  if (rawPathFromMemento === undefined) {
    return pickFromSuppliedEndpointsInstead;
  }
  var endpointFromMemento = await fromRawPath(rawPathFromMemento);
  if (endpointFromMemento.TAG === "Ok") {
    var endpointFromMemento$1 = endpointFromMemento._0;
    var existsInSuppliedEndpoints = Util$AgdaModeVscode.$$Array.includes(suppliedEndpoints$1, endpointFromMemento$1);
    if (existsInSuppliedEndpoints) {
      return {
              TAG: "Ok",
              _0: endpointFromMemento$1
            };
    } else {
      await Memento$AgdaModeVscode.Module.PickedConnection.set(memento, undefined);
      return pickFromSuppliedEndpointsInstead;
    }
  }
  await Memento$AgdaModeVscode.Module.PickedConnection.set(memento, undefined);
  return pickFromSuppliedEndpointsInstead;
}

async function getPickedRaw(memento, fromSystem) {
  var fromMemento = Memento$AgdaModeVscode.Module.PickedConnection.get(memento);
  if (fromMemento === undefined) {
    return ;
  }
  var existsInSuppliedPaths = fromSystem.includes(fromMemento);
  if (existsInSuppliedPaths) {
    return fromMemento;
  } else {
    await Memento$AgdaModeVscode.Module.PickedConnection.set(memento, undefined);
    return ;
  }
}

function setPicked(memento, endpoint) {
  if (endpoint !== undefined) {
    return Memento$AgdaModeVscode.Module.PickedConnection.set(memento, Connection__URI$AgdaModeVscode.toString(toURI(endpoint)));
  } else {
    return Memento$AgdaModeVscode.Module.PickedConnection.set(memento, undefined);
  }
}

var Module = {
  probeFilepath: probeFilepath,
  fromURI: fromURI,
  toURI: toURI,
  fromRawPath: fromRawPath,
  fromRawPaths: fromRawPaths,
  fromVSCodeUri: fromVSCodeUri,
  getPicked: getPicked,
  getPickedRaw: getPickedRaw,
  setPicked: setPicked
};

var IPC;

var URI;

exports.IPC = IPC;
exports.URI = URI;
exports.checkForPrebuiltDataDirectory = checkForPrebuiltDataDirectory;
exports.$$Error = $$Error;
exports.Module = Module;
exports.probeFilepath = probeFilepath;
exports.fromURI = fromURI;
exports.toURI = toURI;
exports.fromRawPath = fromRawPath;
exports.fromRawPaths = fromRawPaths;
exports.fromVSCodeUri = fromVSCodeUri;
exports.getPicked = getPicked;
exports.getPickedRaw = getPickedRaw;
exports.setPicked = setPicked;
/* vscode Not a pure module */
