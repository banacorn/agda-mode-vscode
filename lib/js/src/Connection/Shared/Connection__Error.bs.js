// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Core__Dict = require("@rescript/core/lib/js/src/Core__Dict.bs.js");
var Core__Array = require("@rescript/core/lib/js/src/Core__Array.bs.js");
var Util$AgdaModeVscode = require("../../Util/Util.bs.js");
var Parser$AgdaModeVscode = require("../../Parser/Parser.bs.js");
var Json_Decode$JsonCombinators = require("@glennsl/rescript-json-combinators/lib/js/src/Json_Decode.bs.js");
var Connection__Command$AgdaModeVscode = require("../Resolver/Connection__Command.bs.js");
var Connection__Download$AgdaModeVscode = require("../Download/Connection__Download.bs.js");
var Connection__Process__Exec$AgdaModeVscode = require("./Connection__Process__Exec.bs.js");
var Connection__Transport__Process$AgdaModeVscode = require("../Transport/Connection__Transport__Process.bs.js");

function toString(x) {
  switch (x.TAG) {
    case "Process" :
        return [
                "Process Error",
                Connection__Transport__Process$AgdaModeVscode.$$Event.toString(x._0)
              ];
    case "ErrorFromAgda" :
        return [
                "Error from Agda",
                x._0
              ];
    case "ResponseParseError" :
        return [
                "Internal Parse Error",
                Parser$AgdaModeVscode.$$Error.toString(x._0)
              ];
    
  }
}

var CommWithAgda = {
  toString: toString
};

function toString$1(x) {
  if (x.TAG === "CannotDecodeJSON") {
    return "Cannot decode JSON: \n" + x._0;
  } else {
    return "Cannot read IOTCM: \n" + x._0;
  }
}

var decode = Util$AgdaModeVscode.Decode.sum(function (x) {
      switch (x) {
        case "CmdErrCannotDecodeJSON" :
            return {
                    TAG: "Payload",
                    _0: Json_Decode$JsonCombinators.map(Json_Decode$JsonCombinators.string, (function (message) {
                            return {
                                    TAG: "CannotDecodeJSON",
                                    _0: message
                                  };
                          }))
                  };
        case "CmdErrCannotParseCommand" :
            return {
                    TAG: "Payload",
                    _0: Json_Decode$JsonCombinators.map(Json_Decode$JsonCombinators.string, (function (message) {
                            return {
                                    TAG: "CannotParseCommand",
                                    _0: message
                                  };
                          }))
                  };
        default:
          throw {
                RE_EXN_ID: Json_Decode$JsonCombinators.DecodeError,
                _1: "[Connection.Target.ALS.Error.CommandErr] Unknown constructor: " + x,
                Error: new Error()
              };
      }
    });

var CommandErr = {
  toString: toString$1,
  decode: decode
};

function toString$2(error) {
  if (typeof error !== "object") {
    return [
            "Cannot Initialize Connection",
            ""
          ];
  }
  switch (error.TAG) {
    case "ConnectionError" :
        var errorString = Util$AgdaModeVscode.JsError.toString(error._0);
        if (errorString === "") {
          return [
                  "Connection Error",
                  "(empty error message)"
                ];
        } else {
          return [
                  "Connection Error",
                  errorString
                ];
        }
    case "ConnectionTimeoutError" :
        return [
                "Connection Timeout",
                "Expected to connect within " + String(error._0) + "ms"
              ];
    case "SendCommand" :
        return [
                "Cannot Send Command",
                toString$1(error._0)
              ];
    case "CannotDecodeCommandRes" :
        return [
                "Cannot Send Command",
                "Cannot decode the result after sending command" + error._0 + "\n" + JSON.stringify(error._1)
              ];
    case "CannotDecodeResponse" :
        return [
                "Cannot Parse Response",
                "Cannot decode responses from the server" + error._0 + "\n" + JSON.stringify(error._1)
              ];
    case "ResponseParseError" :
        return [
                "Internal Parse Error",
                Parser$AgdaModeVscode.$$Error.toString(error._0)
              ];
    
  }
}

var CommWithALS = {
  CommandErr: CommandErr,
  toString: toString$2
};

function toString$3(x) {
  switch (x.TAG) {
    case "NotAgdaOrALS" :
        var output = x._0;
        var outputInfo = output === "" ? "no output (empty string)" : "'" + output + "'";
        return "doesn't seem to be an Agda executable or an Agda Language Server. Output received: " + outputInfo;
    case "CannotDetermineAgdaOrALS" :
        return Connection__Process__Exec$AgdaModeVscode.$$Error.toString(x._0);
    case "CannotMakeConnectionWithALS" :
        return "Cannot make connection with Agda Language Server: " + toString$2(x._0)[1];
    case "CannotMakeConnectionWithALSWASMYet" :
        return "WASM connection failed: " + x._0;
    
  }
}

var Probe = {
  toString: toString$3
};

function pathSourceToString(source) {
  if (typeof source !== "object") {
    return "from config";
  }
  if (source.TAG !== "FromDownload") {
    return "from `which " + source._0 + "`";
  }
  switch (source._0) {
    case "LatestALS" :
        return "from LatestALS download";
    case "DevALS" :
        return "from DevALS download";
    case "DevWASMALS" :
        return "from DevWASMALS download";
    
  }
}

function toString$4(x) {
  var probesStr = Object.entries(x.probes).length === 0 ? "Tried to connect with the path from the settings and the system but there are none.\n" : "Tried to connect with these paths but all failed:\n" + Object.entries(x.probes).map(function (param) {
            var match = param[1];
            return "  " + param[0] + " (" + pathSourceToString(match[1]) + "): " + toString$3(match[0]);
          }).join("\n") + "\n";
  var commandsStr = Object.entries(x.commands).length === 0 ? "" : Object.entries(x.commands).map(function (param) {
            return "Tried to connect with `" + param[0] + "` but failed:\n  " + Connection__Command$AgdaModeVscode.$$Error.toString(param[1]);
          }).join("\n") + "\n";
  var error = x.download;
  var downloadStr;
  downloadStr = typeof error !== "object" ? (
      error === "NotAttempted" ? "Opted not to download prebuilt Agda Language Server" : ""
    ) : "Tried to download the Agda Language Server but failed:\n  " + Connection__Download$AgdaModeVscode.$$Error.toString(error._0);
  return probesStr + commandsStr + downloadStr;
}

function fromProbeError(path, error, source) {
  return {
          probes: Object.fromEntries([[
                  path,
                  [
                    error,
                    source
                  ]
                ]]),
          commands: {},
          download: "NotAttempted"
        };
}

function fromCommandError(command, error) {
  return {
          probes: {},
          commands: Object.fromEntries([[
                  command,
                  error
                ]]),
          download: "NotAttempted"
        };
}

function fromDownloadError(error) {
  return {
          probes: {},
          commands: {},
          download: {
            TAG: "Failed",
            _0: error
          }
        };
}

function merge(x, y) {
  var dict = {};
  var dict$1 = {};
  var match = x.download;
  var match$1 = y.download;
  var tmp;
  var exit = 0;
  if (typeof match !== "object") {
    if (match === "NotAttempted" && typeof match$1 !== "object" && match$1 === "NotAttempted") {
      tmp = "NotAttempted";
    } else {
      exit = 1;
    }
  } else {
    tmp = {
      TAG: "Failed",
      _0: match._0
    };
  }
  if (exit === 1) {
    tmp = typeof match$1 !== "object" ? "Succeeded" : ({
          TAG: "Failed",
          _0: match$1._0
        });
  }
  return {
          probes: (Core__Dict.forEachWithKey(x.probes, (function (errorAndSource, path) {
                    dict[path] = errorAndSource;
                  })), Core__Dict.forEachWithKey(y.probes, (function (errorAndSource, path) {
                    dict[path] = errorAndSource;
                  })), dict),
          commands: (Core__Dict.forEachWithKey(x.commands, (function (error, command) {
                    dict$1[command] = error;
                  })), Core__Dict.forEachWithKey(y.commands, (function (error, command) {
                    dict$1[command] = error;
                  })), dict$1),
          download: tmp
        };
}

function mergeMany(xs) {
  return Core__Array.reduce(xs, {
              probes: {},
              commands: {},
              download: "NotAttempted"
            }, (function (acc, x) {
                return merge(acc, x);
              }));
}

var Establish = {
  pathSourceToString: pathSourceToString,
  toString: toString$4,
  fromProbeError: fromProbeError,
  fromCommandError: fromCommandError,
  fromDownloadError: fromDownloadError,
  merge: merge,
  mergeMany: mergeMany
};

function toString$5(x) {
  switch (x.TAG) {
    case "Establish" :
        return [
                "Cannot Establish Connection",
                toString$4(x._0)
              ];
    case "CommWithAgda" :
        return toString(x._0);
    case "CommWithALS" :
        return toString$2(x._0);
    
  }
}

exports.CommWithAgda = CommWithAgda;
exports.CommWithALS = CommWithALS;
exports.Probe = Probe;
exports.Establish = Establish;
exports.toString = toString$5;
/* decode Not a pure module */
