// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Core__Dict = require("@rescript/core/lib/js/src/Core__Dict.bs.js");
var Core__Array = require("@rescript/core/lib/js/src/Core__Array.bs.js");
var Core__Option = require("@rescript/core/lib/js/src/Core__Option.bs.js");
var Util$AgdaModeVscode = require("../../Util/Util.bs.js");
var Parser$AgdaModeVscode = require("../../Parser/Parser.bs.js");
var Json_Decode$JsonCombinators = require("@glennsl/rescript-json-combinators/lib/js/src/Json_Decode.bs.js");
var Connection__Command$AgdaModeVscode = require("../Resolver/Connection__Command.bs.js");
var Connection__Download$AgdaModeVscode = require("../Download/Connection__Download.bs.js");
var Connection__Process__Exec$AgdaModeVscode = require("./Connection__Process__Exec.bs.js");
var Connection__Transport__Process$AgdaModeVscode = require("../Transport/Connection__Transport__Process.bs.js");

function toString(x) {
  switch (x.TAG) {
    case "Process" :
        return [
                "Process Error",
                Connection__Transport__Process$AgdaModeVscode.$$Event.toString(x._0)
              ];
    case "ErrorFromAgda" :
        return [
                "Error from Agda",
                x._0
              ];
    case "ResponseParseError" :
        return [
                "Internal Parse Error",
                Parser$AgdaModeVscode.$$Error.toString(x._0)
              ];
    
  }
}

var CommWithAgda = {
  toString: toString
};

function toString$1(x) {
  if (x.TAG === "CannotDecodeJSON") {
    return "Cannot decode JSON: \n" + x._0;
  } else {
    return "Cannot read IOTCM: \n" + x._0;
  }
}

var decode = Util$AgdaModeVscode.Decode.sum(function (x) {
      switch (x) {
        case "CmdErrCannotDecodeJSON" :
            return {
                    TAG: "Payload",
                    _0: Json_Decode$JsonCombinators.map(Json_Decode$JsonCombinators.string, (function (message) {
                            return {
                                    TAG: "CannotDecodeJSON",
                                    _0: message
                                  };
                          }))
                  };
        case "CmdErrCannotParseCommand" :
            return {
                    TAG: "Payload",
                    _0: Json_Decode$JsonCombinators.map(Json_Decode$JsonCombinators.string, (function (message) {
                            return {
                                    TAG: "CannotParseCommand",
                                    _0: message
                                  };
                          }))
                  };
        default:
          throw {
                RE_EXN_ID: Json_Decode$JsonCombinators.DecodeError,
                _1: "[Connection.Target.ALS.Error.CommandErr] Unknown constructor: " + x,
                Error: new Error()
              };
      }
    });

var CommandErr = {
  toString: toString$1,
  decode: decode
};

function toString$2(error) {
  if (typeof error !== "object") {
    return [
            "Cannot Initialize Connection",
            ""
          ];
  }
  switch (error.TAG) {
    case "ConnectionError" :
        var exn = error._0;
        var isECONNREFUSED = Core__Option.mapOr(exn.message, false, (function (extra) {
                return "connect ECONNREFUSED".startsWith(extra);
              }));
        if (isECONNREFUSED) {
          return [
                  "Connection Error",
                  "Please enter \":main -d\" in ghci"
                ];
        } else {
          return [
                  "Client Internal Connection Error",
                  Core__Option.getOr(exn.message, "")
                ];
        }
    case "SendCommand" :
        return [
                "Cannot Send Command",
                toString$1(error._0)
              ];
    case "CannotDecodeCommandRes" :
        return [
                "Cannot Send Command",
                "Cannot decode the result after sending command" + error._0 + "\n" + JSON.stringify(error._1)
              ];
    case "CannotDecodeResponse" :
        return [
                "Cannot Parse Response",
                "Cannot decode responses from the server" + error._0 + "\n" + JSON.stringify(error._1)
              ];
    case "ResponseParseError" :
        return [
                "Internal Parse Error",
                Parser$AgdaModeVscode.$$Error.toString(error._0)
              ];
    
  }
}

var CommWithALS = {
  CommandErr: CommandErr,
  toString: toString$2
};

function toString$3(x) {
  if (typeof x !== "object") {
    return "Cannot handle URLs at the moment, this will be supported again in the future";
  }
  switch (x.TAG) {
    case "NotAgdaOrALS" :
        var output = x._0;
        var outputInfo = output === "" ? "no output (empty string)" : "'" + output + "'";
        return "doesn't seem to be an Agda executable or an Agda Language Server. Output received: " + outputInfo;
    case "CannotDetermineAgdaOrALS" :
        return Connection__Process__Exec$AgdaModeVscode.$$Error.toString(x._0);
    case "CannotMakeConnectionWithALS" :
        return "Cannot make connection with Agda Language Server: " + toString$2(x._0)[1];
    
  }
}

var Probe = {
  toString: toString$3
};

function toString$4(x) {
  var probesStr = Object.entries(x.probes).length === 0 ? "Tried to connect with the path from the settings and the system but there are none.\n" : "Tried to connect with these paths but all failed:\n" + Object.entries(x.probes).map(function (param) {
            return "  " + param[0] + ": " + toString$3(param[1]);
          }).join("\n") + "\n";
  var commandsStr = Object.entries(x.commands).length === 0 ? "" : Object.entries(x.commands).map(function (param) {
            return "Tried to connect with `" + param[0] + "` but failed:\n. " + Connection__Command$AgdaModeVscode.$$Error.toString(param[1]);
          }).join("\n") + "\n";
  var error = x.download;
  var downloadStr = error !== undefined ? "Tried to download the Agda Language Server but failed:\n" + Connection__Download$AgdaModeVscode.$$Error.toString(error) : "Opted not to download prebuilt Agda Language Server";
  return probesStr + commandsStr + downloadStr;
}

function fromProbeError(path, error) {
  return {
          probes: Object.fromEntries([[
                  path,
                  error
                ]]),
          commands: {},
          download: undefined
        };
}

function fromCommandError(command, error) {
  return {
          probes: {},
          commands: Object.fromEntries([[
                  command,
                  error
                ]]),
          download: undefined
        };
}

function fromDownloadError(error) {
  return {
          probes: {},
          commands: {},
          download: error
        };
}

function merge(x, y) {
  var dict = {};
  var dict$1 = {};
  var match = x.download;
  var match$1 = y.download;
  var tmp;
  if (match !== undefined) {
    if (Core__Option.isSome(match$1) && !Core__Option.isSome(match$1)) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "Connection__Error.res",
              192,
              8
            ],
            Error: new Error()
          };
    }
    tmp = match;
  } else {
    tmp = match$1 !== undefined ? match$1 : undefined;
  }
  return {
          probes: (Core__Dict.forEachWithKey(x.probes, (function (error, path) {
                    dict[path] = error;
                  })), Core__Dict.forEachWithKey(y.probes, (function (error, path) {
                    dict[path] = error;
                  })), dict),
          commands: (Core__Dict.forEachWithKey(x.commands, (function (error, command) {
                    dict$1[command] = error;
                  })), Core__Dict.forEachWithKey(y.commands, (function (error, command) {
                    dict$1[command] = error;
                  })), dict$1),
          download: tmp
        };
}

function mergeMany(xs) {
  return Core__Array.reduce(xs, {
              probes: {},
              commands: {},
              download: undefined
            }, (function (acc, x) {
                return merge(acc, x);
              }));
}

var Establish = {
  toString: toString$4,
  fromProbeError: fromProbeError,
  fromCommandError: fromCommandError,
  fromDownloadError: fromDownloadError,
  merge: merge,
  mergeMany: mergeMany
};

function toString$5(x) {
  switch (x.TAG) {
    case "Establish" :
        return [
                "Cannot Establish Connection",
                toString$4(x._0)
              ];
    case "CommWithAgda" :
        return toString(x._0);
    case "CommWithALS" :
        return toString$2(x._0);
    
  }
}

exports.CommWithAgda = CommWithAgda;
exports.CommWithALS = CommWithALS;
exports.Probe = Probe;
exports.Establish = Establish;
exports.toString = toString$5;
/* decode Not a pure module */
