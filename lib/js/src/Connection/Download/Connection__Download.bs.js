// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Js_exn = require("rescript/lib/js/js_exn.js");
var Vscode = require("vscode");
var Core__Array = require("@rescript/core/lib/js/src/Core__Array.bs.js");
var Core__Option = require("@rescript/core/lib/js/src/Core__Option.bs.js");
var FS$AgdaModeVscode = require("../../FS.bs.js");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");
var Connection__Download__Util$AgdaModeVscode = require("./Connection__Download__Util.bs.js");
var Connection__Download__Unzip$AgdaModeVscode = require("./Connection__Download__Unzip.bs.js");
var Connection__Download__GitHub$AgdaModeVscode = require("./Connection__Download__GitHub.bs.js");

function toString(order) {
  if (order === "LatestALS") {
    return "Latest Agda Language Server";
  } else {
    return "Development Agda Language Server";
  }
}

var DownloadOrderAbstract = {
  toString: toString
};

function toString$1(order) {
  return toString(order._0) + Connection__Download__GitHub$AgdaModeVscode.DownloadDescriptor.toString(order._1);
}

function toVersionString(order) {
  var descriptor = order._1;
  var abstractOrder = order._0;
  var getAgdaVersion = function (asset) {
    if (abstractOrder === "LatestALS") {
      return asset.name.replace(/als-Agda-/, "").replace(/-.*/, "");
    } else {
      return asset.name.replace(/als-dev-Agda-/, "").replace(/-.*/, "");
    }
  };
  var agdaVersion = getAgdaVersion(descriptor.asset);
  if (abstractOrder !== "LatestALS") {
    return "Agda v" + agdaVersion + " Language Server (dev build)";
  }
  var alsVersion = Core__Option.getOr(Core__Array.last(descriptor.release.name.split(".")), descriptor.release.name);
  return "Agda v" + agdaVersion + " Language Server v" + alsVersion;
}

var DownloadOrderConcrete = {
  toString: toString$1,
  toVersionString: toVersionString
};

function toString$2(x) {
  if (typeof x !== "object") {
    if (x === "OptedNotToDownload") {
      return "Opted not to download the Agda Language Server";
    } else {
      return "Cannot find compatible Agda Language Server release for download. Prebuilts are only available for download on Ubuntu, Windows, and macOS (arm64, x64).\nPlease build from source if you are on a different platform. \nSee https://github.com/agda/agda-language-server for more information.";
    }
  }
  switch (x.TAG) {
    case "PlatformNotSupported" :
        var platform = x._0;
        return "The platform `" + platform.os + "/" + platform.dist + "` is not supported for downloading the Agda Language Server.\n";
    case "CannotFetchALSReleases" :
        return "Cannot fetch releases of Agda Language Server: " + Connection__Download__GitHub$AgdaModeVscode.$$Error.toString(x._0);
    case "CannotDownloadALS" :
        return "Failed to download the Agda Language Server: " + Connection__Download__GitHub$AgdaModeVscode.$$Error.toString(x._0);
    case "CannotDownloadFromURL" :
        return "Failed to download from URL: " + Connection__Download__GitHub$AgdaModeVscode.$$Error.toString(x._0);
    
  }
}

var $$Error = {
  toString: toString$2
};

async function getReleaseManifestFromGitHub(memento, repo, useCacheOpt) {
  var useCache = useCacheOpt !== undefined ? useCacheOpt : true;
  var match = await Connection__Download__GitHub$AgdaModeVscode.ReleaseManifest.$$fetch(memento, repo, useCache);
  var error = match[0];
  if (error.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: error._0
          };
  } else {
    return {
            TAG: "Error",
            _0: {
              TAG: "CannotFetchALSReleases",
              _0: error._0
            }
          };
  }
}

async function download(globalStorageUri, order) {
  var downloadDescriptor = order._1;
  var reportProgress = await Connection__Download__Util$AgdaModeVscode.Progress.report("Agda Language Server");
  var error = await Connection__Download__GitHub$AgdaModeVscode.download(downloadDescriptor, globalStorageUri, reportProgress);
  if (error.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: {
              TAG: "CannotDownloadALS",
              _0: error._0
            }
          };
  }
  var fileName = downloadDescriptor.asset.name.includes("wasm") ? "als.wasm" : "als";
  var destUri = Vscode.Uri.joinPath(globalStorageUri, downloadDescriptor.saveAsFileName, fileName);
  var destPath = destUri.fsPath;
  return {
          TAG: "Ok",
          _0: destPath
        };
}

async function downloadFromURL(globalStorageUri, url, saveAsFileName, displayName) {
  var reportProgress = await Connection__Download__Util$AgdaModeVscode.Progress.report(displayName);
  var destDirUri = Vscode.Uri.joinPath(globalStorageUri, saveAsFileName);
  var match = await FS$AgdaModeVscode.stat(destDirUri);
  if (match.TAG !== "Ok") {
    await FS$AgdaModeVscode.createDirectory(destDirUri);
  }
  var isWasm = url.endsWith(".wasm");
  var execFileName = isWasm ? "als.wasm" : "als";
  var execPathUri = Vscode.Uri.joinPath(destDirUri, execFileName);
  var match$1 = await FS$AgdaModeVscode.stat(execPathUri);
  if (match$1.TAG === "Ok") {
    if (isWasm) {
      return {
              TAG: "Ok",
              _0: execPathUri.toString()
            };
    } else {
      return {
              TAG: "Ok",
              _0: execPathUri.fsPath
            };
    }
  }
  try {
    var urlObj = new URL(url);
    var host = urlObj.host;
    var path = urlObj.pathname + urlObj.search;
    var tempFileUri = Vscode.Uri.joinPath(destDirUri, "download.tmp");
    var httpOptions = {
      host: host,
      path: path,
      headers: {
        "User-Agent": "agda/agda-mode-vscode",
        Accept: "*/*"
      }
    };
    var error = await Connection__Download__Util$AgdaModeVscode.asFile(httpOptions, tempFileUri, reportProgress);
    if (error.TAG === "Ok") {
      if (isWasm) {
        await FS$AgdaModeVscode.rename(tempFileUri, execPathUri);
        return {
                TAG: "Ok",
                _0: execPathUri.toString()
              };
      }
      var readResult = await FS$AgdaModeVscode.readFile(tempFileUri);
      var isPKHeader;
      if (readResult.TAG === "Ok") {
        var uint8Array = readResult._0;
        isPKHeader = uint8Array.length >= 4 ? Core__Option.getOr(uint8Array[0], 0) === 80 && Core__Option.getOr(uint8Array[1], 0) === 75 && Core__Option.getOr(uint8Array[2], 0) === 3 && Core__Option.getOr(uint8Array[3], 0) === 4 : false;
      } else {
        isPKHeader = false;
      }
      if (isPKHeader) {
        var zipFileUri = Vscode.Uri.joinPath(destDirUri, "download.zip");
        await FS$AgdaModeVscode.rename(tempFileUri, zipFileUri);
        await Connection__Download__Unzip$AgdaModeVscode.run(zipFileUri, destDirUri);
        await FS$AgdaModeVscode.$$delete(zipFileUri);
        return {
                TAG: "Ok",
                _0: execPathUri.fsPath
              };
      }
      await FS$AgdaModeVscode.$$delete(tempFileUri);
      var genericError = {
        message: "Downloaded file is not a ZIP file. The URL may require authentication or may not be a direct download link."
      };
      return {
              TAG: "Error",
              _0: {
                TAG: "CannotDownloadFromURL",
                _0: {
                  TAG: "CannotReadFile",
                  _0: genericError
                }
              }
            };
    }
    var error$1 = error._0;
    var convertedError;
    if (typeof error$1 !== "object") {
      convertedError = {
        TAG: "CannotReadFile",
        _0: {
          message: "No redirect location"
        }
      };
    } else {
      switch (error$1.TAG) {
        case "Timeout" :
            convertedError = {
              TAG: "CannotReadFile",
              _0: {
                message: "Timeout after " + String(error$1._0) + "ms"
              }
            };
            break;
        case "JsonParseError" :
            convertedError = {
              TAG: "CannotReadFile",
              _0: {
                message: "JSON parse error: " + error$1._0
              }
            };
            break;
        case "ServerResponseError" :
        case "CannotWriteFile" :
            convertedError = {
              TAG: "CannotReadFile",
              _0: error$1._0
            };
            break;
        
      }
    }
    return {
            TAG: "Error",
            _0: {
              TAG: "CannotDownloadFromURL",
              _0: convertedError
            }
          };
  }
  catch (raw_obj){
    var obj = Caml_js_exceptions.internalToOCamlException(raw_obj);
    if (obj.RE_EXN_ID === Js_exn.$$Error) {
      return {
              TAG: "Error",
              _0: {
                TAG: "CannotDownloadFromURL",
                _0: {
                  TAG: "CannotReadFile",
                  _0: obj._1
                }
              }
            };
    }
    var genericError$1 = {
      message: "Invalid URL"
    };
    return {
            TAG: "Error",
            _0: {
              TAG: "CannotDownloadFromURL",
              _0: {
                TAG: "CannotReadFile",
                _0: genericError$1
              }
            }
          };
  }
}

async function alreadyDownloaded(globalStorageUri, order) {
  if (order === "LatestALS") {
    var uri = Vscode.Uri.joinPath(globalStorageUri, "latest-als", "als");
    var match = await FS$AgdaModeVscode.stat(uri);
    if (match.TAG === "Ok") {
      return uri.fsPath;
    } else {
      return ;
    }
  }
  var wasmUri = Vscode.Uri.joinPath(globalStorageUri, "dev-als", "als.wasm");
  var match$1 = await FS$AgdaModeVscode.stat(wasmUri);
  if (match$1.TAG === "Ok") {
    return wasmUri.toString();
  }
  var alsUri = Vscode.Uri.joinPath(globalStorageUri, "dev-als", "als");
  var match$2 = await FS$AgdaModeVscode.stat(alsUri);
  if (match$2.TAG === "Ok") {
    return alsUri.fsPath;
  }
  
}

exports.DownloadOrderAbstract = DownloadOrderAbstract;
exports.DownloadOrderConcrete = DownloadOrderConcrete;
exports.$$Error = $$Error;
exports.getReleaseManifestFromGitHub = getReleaseManifestFromGitHub;
exports.download = download;
exports.downloadFromURL = downloadFromURL;
exports.alreadyDownloaded = alreadyDownloaded;
/* vscode Not a pure module */
