// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Url = require("url");
var Js_exn = require("rescript/lib/js/js_exn.js");
var Vscode = require("vscode");
var Core__Option = require("@rescript/core/lib/js/src/Core__Option.bs.js");
var Caml_splice_call = require("rescript/lib/js/caml_splice_call.js");
var FS$AgdaModeVscode = require("../../FS.bs.js");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");
var Connection__Download__Util$AgdaModeVscode = require("./Connection__Download__Util.bs.js");
var Connection__Download__Unzip$AgdaModeVscode = require("./Connection__Download__Unzip.bs.js");
var Connection__Download__GitHub$AgdaModeVscode = require("./Connection__Download__GitHub.bs.js");

function toString(x) {
  if (typeof x !== "object") {
    if (x === "OptedNotToDownload") {
      return "Opted not to download the Agda Language Server";
    } else {
      return "Cannot find compatible Agda Language Server release for download. Prebuilts are only available for download on Ubuntu, Windows, and macOS (arm64, x64).\nPlease build from source if you are on a different platform. \nSee https://github.com/agda/agda-language-server for more information.";
    }
  }
  switch (x.TAG) {
    case "PlatformNotSupported" :
        var platform = x._0;
        return "The platform `" + platform.os + "/" + platform.dist + "` is not supported for downloading the Agda Language Server.\n";
    case "CannotFetchALSReleases" :
        return "Cannot fetch releases of Agda Language Server: " + Connection__Download__GitHub$AgdaModeVscode.$$Error.toString(x._0);
    case "CannotDownloadALS" :
        return "Failed to download the Agda Language Server: " + Connection__Download__GitHub$AgdaModeVscode.$$Error.toString(x._0);
    case "CannotDownloadFromURL" :
        return "Failed to download from URL: " + Connection__Download__GitHub$AgdaModeVscode.$$Error.toString(x._0);
    
  }
}

var $$Error = {
  toString: toString
};

async function getReleaseManifestFromGitHub(memento, repo, useCacheOpt) {
  var useCache = useCacheOpt !== undefined ? useCacheOpt : true;
  var match = await Connection__Download__GitHub$AgdaModeVscode.ReleaseManifest.$$fetch(memento, repo, useCache);
  var error = match[0];
  if (error.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: error._0
          };
  } else {
    return {
            TAG: "Error",
            _0: {
              TAG: "CannotFetchALSReleases",
              _0: error._0
            }
          };
  }
}

async function download(globalStorageUri, downloadDescriptor) {
  var reportProgress = await Connection__Download__Util$AgdaModeVscode.Progress.report("Agda Language Server");
  var error = await Connection__Download__GitHub$AgdaModeVscode.download(downloadDescriptor, globalStorageUri, reportProgress);
  if (error.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: {
              TAG: "CannotDownloadALS",
              _0: error._0
            }
          };
  }
  var fileName = downloadDescriptor.saveAsFileName === "dev-wasm-als" ? "als.wasm" : "als";
  var destUri = Vscode.Uri.joinPath(globalStorageUri, downloadDescriptor.saveAsFileName, fileName);
  var destPath = destUri.fsPath;
  return {
          TAG: "Ok",
          _0: destPath
        };
}

async function downloadFromURL(globalStorageUri, url, saveAsFileName, displayName) {
  var reportProgress = await Connection__Download__Util$AgdaModeVscode.Progress.report(displayName);
  var destDirUri = Vscode.Uri.joinPath(globalStorageUri, saveAsFileName);
  var match = await FS$AgdaModeVscode.stat(destDirUri);
  if (match.TAG !== "Ok") {
    await FS$AgdaModeVscode.createDirectory(destDirUri);
  }
  var execPathUri = Vscode.Uri.joinPath(destDirUri, "als");
  var match$1 = await FS$AgdaModeVscode.stat(execPathUri);
  if (match$1.TAG === "Ok") {
    var path = execPathUri.fsPath;
    return {
            TAG: "Ok",
            _0: path
          };
  }
  try {
    var urlObj = Url.parse(url);
    var host = urlObj.hostname;
    var path$1 = urlObj.pathname + Core__Option.getOr(urlObj.search, "");
    var tempFileUri = Vscode.Uri.joinPath(destDirUri, "download.tmp");
    var httpOptions = {
      host: host,
      path: path$1,
      headers: {
        "User-Agent": "agda/agda-mode-vscode"
      }
    };
    var error = await Connection__Download__Util$AgdaModeVscode.asFile(httpOptions, tempFileUri, reportProgress);
    if (error.TAG === "Ok") {
      if (saveAsFileName === "dev-wasm-als") {
        var wasmExecUri = Vscode.Uri.joinPath(destDirUri, "als.wasm");
        await FS$AgdaModeVscode.rename(tempFileUri, wasmExecUri);
        return {
                TAG: "Ok",
                _0: wasmExecUri.fsPath
              };
      }
      var readResult = await FS$AgdaModeVscode.readFile(tempFileUri);
      var isPKHeader;
      if (readResult.TAG === "Ok") {
        var uint8Array = readResult._0;
        isPKHeader = uint8Array.length >= 4 ? Core__Option.getOr(uint8Array[0], 0) === 80 && Core__Option.getOr(uint8Array[1], 0) === 75 && Core__Option.getOr(uint8Array[2], 0) === 3 && Core__Option.getOr(uint8Array[3], 0) === 4 : false;
      } else {
        isPKHeader = false;
      }
      if (isPKHeader) {
        var zipFileUri = Vscode.Uri.joinPath(destDirUri, "download.zip");
        await FS$AgdaModeVscode.rename(tempFileUri, zipFileUri);
        await Connection__Download__Unzip$AgdaModeVscode.run(zipFileUri, destDirUri);
        await FS$AgdaModeVscode.$$delete(zipFileUri);
        return {
                TAG: "Ok",
                _0: execPathUri.fsPath
              };
      }
      await FS$AgdaModeVscode.$$delete(tempFileUri);
      var genericError = {
        message: "Downloaded file is not a ZIP file. The URL may require authentication or may not be a direct download link."
      };
      return {
              TAG: "Error",
              _0: {
                TAG: "CannotDownloadFromURL",
                _0: {
                  TAG: "CannotReadFile",
                  _0: genericError
                }
              }
            };
    }
    var error$1 = error._0;
    var convertedError;
    if (typeof error$1 !== "object") {
      convertedError = {
        TAG: "CannotReadFile",
        _0: {
          message: "No redirect location"
        }
      };
    } else {
      switch (error$1.TAG) {
        case "Timeout" :
            convertedError = {
              TAG: "CannotReadFile",
              _0: {
                message: "Timeout after " + String(error$1._0) + "ms"
              }
            };
            break;
        case "JsonParseError" :
            convertedError = {
              TAG: "CannotReadFile",
              _0: {
                message: "JSON parse error: " + error$1._0
              }
            };
            break;
        case "ServerResponseError" :
        case "CannotWriteFile" :
            convertedError = {
              TAG: "CannotReadFile",
              _0: error$1._0
            };
            break;
        
      }
    }
    return {
            TAG: "Error",
            _0: {
              TAG: "CannotDownloadFromURL",
              _0: convertedError
            }
          };
  }
  catch (raw_obj){
    var obj = Caml_js_exceptions.internalToOCamlException(raw_obj);
    if (obj.RE_EXN_ID === Js_exn.$$Error) {
      return {
              TAG: "Error",
              _0: {
                TAG: "CannotDownloadFromURL",
                _0: {
                  TAG: "CannotReadFile",
                  _0: obj._1
                }
              }
            };
    }
    var genericError$1 = {
      message: "Invalid URL"
    };
    return {
            TAG: "Error",
            _0: {
              TAG: "CannotDownloadFromURL",
              _0: {
                TAG: "CannotReadFile",
                _0: genericError$1
              }
            }
          };
  }
}

async function alreadyDownloaded(globalStorageUri, target) {
  var paths;
  switch (target) {
    case "LatestALS" :
        paths = [
          "latest-als",
          "als"
        ];
        break;
    case "DevALS" :
        paths = [
          "dev-als",
          "als"
        ];
        break;
    case "DevWASMALS" :
        paths = [
          "dev-wasm-als",
          "als.wasm"
        ];
        break;
    
  }
  var uri = Caml_splice_call.spliceApply(Vscode.Uri.joinPath, [
        globalStorageUri,
        paths
      ]);
  var match = await FS$AgdaModeVscode.stat(uri);
  if (match.TAG === "Ok") {
    return uri.fsPath;
  }
  
}

exports.$$Error = $$Error;
exports.getReleaseManifestFromGitHub = getReleaseManifestFromGitHub;
exports.download = download;
exports.downloadFromURL = downloadFromURL;
exports.alreadyDownloaded = alreadyDownloaded;
/* url Not a pure module */
