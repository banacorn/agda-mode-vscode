// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Https = require("https");
var Vscode = require("vscode");
var Nodefs = require("node:fs");
var Caml_format = require("rescript/lib/js/caml_format.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Core__Option = require("@rescript/core/lib/js/src/Core__Option.bs.js");
var Util$AgdaModeVscode = require("../../Util/Util.bs.js");

var Https$1 = {};

function toString(x) {
  if (typeof x !== "object") {
    return "Got HTTP 301/302 from GitHub without location in headers";
  }
  switch (x.TAG) {
    case "ServerResponseError" :
        return "Server response error:\n" + Util$AgdaModeVscode.JsError.toString(x._0);
    case "Timeout" :
        return "Timeout after " + String(x._0) + "ms. Please check your internet connection";
    case "JsonParseError" :
        return "Cannot parse downloaded file as JSON:\n" + x._0;
    case "CannotWriteFile" :
        return "Failed to write downloaded content to files:\n" + Util$AgdaModeVscode.JsError.toString(x._0);
    
  }
}

var $$Error = {
  toString: toString
};

function toString$1($$event) {
  if (typeof $$event !== "object") {
    if ($$event === "Start") {
      return "Starting";
    } else {
      return "Done";
    }
  }
  var total = $$event._1;
  var accum = $$event._0;
  if (total > 10485760) {
    return String(accum / 1048576 | 0) + " MB / " + String(total / 1048576 | 0) + " MB";
  } else {
    return String(accum / 1024 | 0) + " KB / " + String(total / 1024 | 0) + " MB";
  }
}

var $$Event = {
  toString: toString$1
};

async function report(name) {
  var progressRef = {
    contents: undefined
  };
  var match = Util$AgdaModeVscode.Promise_.pending();
  var resolve = match[1];
  var promise = match[0];
  var percentage = {
    contents: 0
  };
  return function ($$event) {
    if (typeof $$event !== "object") {
      if ($$event === "Start") {
        Vscode.window.withProgress({
              location: 15,
              title: "Downloading " + name
            }, (function (progress, _cancellationToken) {
                progress.report({
                      increment: 0,
                      message: toString$1($$event)
                    });
                progressRef.contents = Caml_option.some(progress);
                return promise;
              }));
        return ;
      }
      Core__Option.forEach(progressRef.contents, (function (progress) {
              progress.report({
                    increment: 100,
                    message: toString$1($$event)
                  });
            }));
      return resolve();
    } else {
      var percentageNew = $$event._0 / $$event._1 * 100.0 | 0;
      var increment = percentageNew - percentage.contents | 0;
      percentage.contents = percentageNew;
      if (increment > 0) {
        return Core__Option.forEach(progressRef.contents, (function (progress) {
                      progress.report({
                            increment: increment,
                            message: toString$1($$event)
                          });
                    }));
      } else {
        return ;
      }
    }
  };
}

var Progress = {
  report: report
};

function gatherDataFromResponseStream(res) {
  var body = {
    contents: ""
  };
  return new Promise((function (resolve, param) {
                res.on("data", (function (buf) {
                        body.contents = body.contents + buf.toString();
                      }));
                res.on("error", (function (error) {
                        resolve({
                              TAG: "Error",
                              _0: {
                                TAG: "ServerResponseError",
                                _0: error
                              }
                            });
                      }));
                res.on("close", (function () {
                        resolve({
                              TAG: "Ok",
                              _0: body.contents
                            });
                      }));
              }));
}

function getWithRedirects(options) {
  return new Promise((function (resolve, param) {
                Https.get(options, (function (res) {
                        var statusCode = res.statusCode;
                        if (!(statusCode === 302 || statusCode === 301)) {
                          return resolve({
                                      TAG: "Ok",
                                      _0: res
                                    });
                        }
                        var headers = res.headers;
                        var urlAfterRedirect = headers.location;
                        if (urlAfterRedirect !== undefined) {
                          Https.get(urlAfterRedirect, (function (resAfterRedirect) {
                                  resolve({
                                        TAG: "Ok",
                                        _0: resAfterRedirect
                                      });
                                }));
                          return ;
                        } else {
                          return resolve({
                                      TAG: "Error",
                                      _0: "NoRedirectLocation"
                                    });
                        }
                      }));
              }));
}

function timeoutAfter(p, n) {
  return Promise.race([
              new Promise((function (resolve, param) {
                      setTimeout((function () {
                              resolve({
                                    TAG: "Error",
                                    _0: {
                                      TAG: "Timeout",
                                      _0: n
                                    }
                                  });
                            }), n);
                    })),
              p
            ]);
}

async function asJson(httpOptions) {
  var res = await getWithRedirects(httpOptions);
  if (res.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: res._0
          };
  }
  var raw = await gatherDataFromResponseStream(res._0);
  if (raw.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: raw._0
          };
  }
  var raw$1 = raw._0;
  try {
    return {
            TAG: "Ok",
            _0: JSON.parse(raw$1)
          };
  }
  catch (exn){
    return {
            TAG: "Error",
            _0: {
              TAG: "JsonParseError",
              _0: raw$1
            }
          };
  }
}

async function asFile(httpOptions, destPath, onDownload) {
  var res = await getWithRedirects(httpOptions);
  if (res.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: res._0
          };
  }
  var res$1 = res._0;
  onDownload("Start");
  var totalSize = Core__Option.mapOr(res$1.headers["content-length"], 0, Caml_format.int_of_string);
  var accumSize = {
    contents: 0
  };
  res$1.on("data", (function (chunk) {
          var chunkSize = chunk.length;
          accumSize.contents = accumSize.contents + chunkSize | 0;
          onDownload({
                TAG: "Progress",
                _0: accumSize.contents,
                _1: totalSize
              });
        }));
  return await new Promise((function (resolve, param) {
                var fileStream = Nodefs.createWriteStream(destPath);
                fileStream.on("error", (function (exn) {
                        resolve({
                              TAG: "Error",
                              _0: {
                                TAG: "CannotWriteFile",
                                _0: exn
                              }
                            });
                      }));
                fileStream.on("close", (function () {
                        onDownload("Finish");
                        resolve({
                              TAG: "Ok",
                              _0: undefined
                            });
                      }));
                res$1.pipe(fileStream);
              }));
}

var Module = {
  asJson: asJson,
  asFile: asFile,
  timeoutAfter: timeoutAfter
};

exports.Https = Https$1;
exports.$$Error = $$Error;
exports.$$Event = $$Event;
exports.Progress = Progress;
exports.Module = Module;
exports.asJson = asJson;
exports.asFile = asFile;
exports.timeoutAfter = timeoutAfter;
/* https Not a pure module */
