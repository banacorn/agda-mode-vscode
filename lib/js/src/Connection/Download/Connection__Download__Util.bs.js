// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Js_exn = require("rescript/lib/js/js_exn.js");
var Vscode = require("vscode");
var Belt_Int = require("rescript/lib/js/belt_Int.js");
var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Core__Option = require("@rescript/core/lib/js/src/Core__Option.bs.js");
var FS$AgdaModeVscode = require("../../FS.bs.js");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");
var Util$AgdaModeVscode = require("../../Util/Util.bs.js");

var Fetch = {};

function toString(x) {
  if (typeof x !== "object") {
    return "Got HTTP 301/302 from GitHub without location in headers";
  }
  switch (x.TAG) {
    case "ServerResponseError" :
        return "Server response error:\n" + Util$AgdaModeVscode.JsError.toString(x._0);
    case "Timeout" :
        return "Timeout after " + String(x._0) + "ms. Please check your internet connection";
    case "JsonParseError" :
        return "Cannot parse downloaded file as JSON:\n" + x._0;
    case "CannotWriteFile" :
        return "Failed to write downloaded content to files:\n" + Util$AgdaModeVscode.JsError.toString(x._0);
    
  }
}

var $$Error = {
  toString: toString
};

function toString$1($$event) {
  if (typeof $$event !== "object") {
    if ($$event === "Start") {
      return "Starting";
    } else {
      return "Done";
    }
  }
  var total = $$event._1;
  var accum = $$event._0;
  if (total > 10485760) {
    return String(accum / 1048576 | 0) + " MB / " + String(total / 1048576 | 0) + " MB";
  } else {
    return String(accum / 1024 | 0) + " KB / " + String(total / 1024 | 0) + " MB";
  }
}

var $$Event = {
  toString: toString$1
};

async function report(name) {
  var progressRef = {
    contents: undefined
  };
  var match = Util$AgdaModeVscode.Promise_.pending();
  var resolve = match[1];
  var promise = match[0];
  var percentage = {
    contents: 0
  };
  return function ($$event) {
    if (typeof $$event !== "object") {
      if ($$event === "Start") {
        Vscode.window.withProgress({
              location: 15,
              title: "Downloading " + name
            }, (function (progress, _cancellationToken) {
                progress.report({
                      increment: 0,
                      message: toString$1($$event)
                    });
                progressRef.contents = Caml_option.some(progress);
                return promise;
              }));
        return ;
      }
      Core__Option.forEach(progressRef.contents, (function (progress) {
              progress.report({
                    increment: 100,
                    message: toString$1($$event)
                  });
            }));
      return resolve();
    } else {
      var percentageNew = $$event._0 / $$event._1 * 100.0 | 0;
      var increment = percentageNew - percentage.contents | 0;
      percentage.contents = percentageNew;
      if (increment > 0) {
        return Core__Option.forEach(progressRef.contents, (function (progress) {
                      progress.report({
                            increment: increment,
                            message: toString$1($$event)
                          });
                    }));
      } else {
        return ;
      }
    }
  };
}

var Progress = {
  report: report
};

function optionsToUrl(options) {
  return "https://" + options.host + options.path;
}

async function fetchWithRedirects(url, options) {
  try {
    var response = await fetch(url, options);
    if (response.ok) {
      return {
              TAG: "Ok",
              _0: response
            };
    }
    var error = {
      message: "HTTP " + String(response.status)
    };
    return {
            TAG: "Error",
            _0: {
              TAG: "ServerResponseError",
              _0: error
            }
          };
  }
  catch (raw_obj){
    var obj = Caml_js_exceptions.internalToOCamlException(raw_obj);
    if (obj.RE_EXN_ID === Js_exn.$$Error) {
      return {
              TAG: "Error",
              _0: {
                TAG: "ServerResponseError",
                _0: obj._1
              }
            };
    }
    var error$1 = {
      message: "Network error"
    };
    return {
            TAG: "Error",
            _0: {
              TAG: "ServerResponseError",
              _0: error$1
            }
          };
  }
}

async function gatherDataFromResponse(response) {
  try {
    var text = await (response.text());
    return {
            TAG: "Ok",
            _0: text
          };
  }
  catch (raw_obj){
    var obj = Caml_js_exceptions.internalToOCamlException(raw_obj);
    if (obj.RE_EXN_ID === Js_exn.$$Error) {
      return {
              TAG: "Error",
              _0: {
                TAG: "ServerResponseError",
                _0: obj._1
              }
            };
    }
    var error = {
      message: "Failed to read response body"
    };
    return {
            TAG: "Error",
            _0: {
              TAG: "ServerResponseError",
              _0: error
            }
          };
  }
}

function timeoutAfter(p, n) {
  return Promise.race([
              new Promise((function (resolve, param) {
                      setTimeout((function () {
                              resolve({
                                    TAG: "Error",
                                    _0: {
                                      TAG: "Timeout",
                                      _0: n
                                    }
                                  });
                            }), n);
                    })),
              p
            ]);
}

async function asJson(httpOptions) {
  var url = optionsToUrl(httpOptions);
  var fetchOptions = {
    headers: httpOptions.headers
  };
  var response = await fetchWithRedirects(url, fetchOptions);
  if (response.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: response._0
          };
  }
  var raw = await gatherDataFromResponse(response._0);
  if (raw.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: raw._0
          };
  }
  var raw$1 = raw._0;
  try {
    return {
            TAG: "Ok",
            _0: JSON.parse(raw$1)
          };
  }
  catch (exn){
    return {
            TAG: "Error",
            _0: {
              TAG: "JsonParseError",
              _0: raw$1
            }
          };
  }
}

async function asFile(httpOptions, destUri, onDownload) {
  var url = optionsToUrl(httpOptions);
  var fetchOptions = {
    headers: httpOptions.headers
  };
  var response = await fetchWithRedirects(url, fetchOptions);
  if (response.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: response._0
          };
  }
  onDownload("Start");
  try {
    var contentLength;
    try {
      contentLength = Caml_option.some((response.headers.get('content-length')));
    }
    catch (exn){
      contentLength = undefined;
    }
    var totalSize = contentLength !== undefined && Caml_obj.notequal(Caml_option.valFromOption(contentLength), null) ? Core__Option.getOr(Belt_Int.fromString(length), 0) : 0;
    var reader;
    try {
      if ((response.body === null || response.body === undefined)) {
        throw {
              RE_EXN_ID: "Failure",
              _1: "Response body is null or undefined",
              Error: new Error()
            };
      }
      reader = {
        TAG: "Ok",
        _0: (response.body.getReader())
      };
    }
    catch (raw_msg){
      var msg = Caml_js_exceptions.internalToOCamlException(raw_msg);
      reader = msg.RE_EXN_ID === "Failure" ? ({
            TAG: "Error",
            _0: msg._1
          }) : (
          msg.RE_EXN_ID === Js_exn.$$Error ? ({
                TAG: "Error",
                _0: Core__Option.getOr(msg._1.message, "Failed to get response body reader")
              }) : ({
                TAG: "Error",
                _0: "Unknown error getting response body reader"
              })
        );
    }
    if (reader.TAG === "Ok") {
      var chunks = {
        contents: []
      };
      var accumSize = {
        contents: 0
      };
      var readChunks = async function () {
        await (reader.read());
        var done = result.done;
        var value = result.value;
        if (done) {
          return ;
        }
        chunks.contents = chunks.contents.concat([value]);
        var chunkSize = value.length;
        accumSize.contents = accumSize.contents + chunkSize | 0;
        onDownload({
              TAG: "Progress",
              _0: accumSize.contents,
              _1: totalSize
            });
        return await readChunks();
      };
      await readChunks();
      var combinedArray = (new Uint8Array(totalLength));
      var offset = {
        contents: 0
      };
      chunks.contents.forEach(function (chunk) {
            ((combinedArray.set(chunk, offset.contents)));
            var chunkLength = chunk.length;
            offset.contents = offset.contents + chunkLength | 0;
          });
      var error = await FS$AgdaModeVscode.writeFile(destUri, combinedArray);
      if (error.TAG === "Ok") {
        onDownload("Finish");
        return {
                TAG: "Ok",
                _0: undefined
              };
      }
      var exn$1 = {
        message: error._0
      };
      return {
              TAG: "Error",
              _0: {
                TAG: "CannotWriteFile",
                _0: exn$1
              }
            };
    }
    var error$1 = {
      message: reader._0
    };
    return {
            TAG: "Error",
            _0: {
              TAG: "CannotWriteFile",
              _0: error$1
            }
          };
  }
  catch (raw_obj){
    var obj = Caml_js_exceptions.internalToOCamlException(raw_obj);
    if (obj.RE_EXN_ID === Js_exn.$$Error) {
      return {
              TAG: "Error",
              _0: {
                TAG: "CannotWriteFile",
                _0: obj._1
              }
            };
    }
    var error$2 = {
      message: "Failed to download file"
    };
    return {
            TAG: "Error",
            _0: {
              TAG: "CannotWriteFile",
              _0: error$2
            }
          };
  }
}

var Module = {
  asJson: asJson,
  asFile: asFile,
  timeoutAfter: timeoutAfter
};

exports.Fetch = Fetch;
exports.$$Error = $$Error;
exports.$$Event = $$Event;
exports.Progress = Progress;
exports.Module = Module;
exports.asJson = asJson;
exports.asFile = asFile;
exports.timeoutAfter = timeoutAfter;
/* vscode Not a pure module */
