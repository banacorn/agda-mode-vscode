// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Js_exn = require("rescript/lib/js/js_exn.js");
var Vscode = require("vscode");
var Belt_Int = require("rescript/lib/js/belt_Int.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Core__Option = require("@rescript/core/lib/js/src/Core__Option.bs.js");
var FS$AgdaModeVscode = require("../../FS.bs.js");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");
var Util$AgdaModeVscode = require("../../Util/Util.bs.js");

function toString(x) {
  if (typeof x !== "object") {
    return "Got HTTP 301/302 from GitHub without location in headers";
  }
  switch (x.TAG) {
    case "ServerResponseError" :
        return "Server response error:\n" + Util$AgdaModeVscode.JsError.toString(x._0);
    case "Timeout" :
        return "Timeout after " + String(x._0) + "ms. Please check your internet connection";
    case "JsonParseError" :
        return "Cannot parse downloaded file as JSON:\n" + x._0;
    case "CannotWriteFile" :
        return "Failed to write downloaded content to files:\n" + Util$AgdaModeVscode.JsError.toString(x._0);
    
  }
}

var $$Error = {
  toString: toString
};

function toString$1($$event) {
  if (typeof $$event !== "object") {
    if ($$event === "Start") {
      return "Starting";
    } else {
      return "Done";
    }
  }
  var total = $$event._1;
  var accum = $$event._0;
  if (total > 10485760) {
    return String(accum / 1048576 | 0) + " MB / " + String(total / 1048576 | 0) + " MB";
  } else {
    return String(accum / 1024 | 0) + " KB / " + String(total / 1024 | 0) + " MB";
  }
}

var $$Event = {
  toString: toString$1
};

async function report(name) {
  var progressRef = {
    contents: undefined
  };
  var match = Util$AgdaModeVscode.Promise_.pending();
  var resolve = match[1];
  var promise = match[0];
  var percentage = {
    contents: 0
  };
  return function ($$event) {
    if (typeof $$event !== "object") {
      if ($$event === "Start") {
        Vscode.window.withProgress({
              location: 15,
              title: "Downloading " + name
            }, (function (progress, _cancellationToken) {
                progress.report({
                      increment: 0,
                      message: toString$1($$event)
                    });
                progressRef.contents = Caml_option.some(progress);
                return promise;
              }));
        return ;
      }
      Core__Option.forEach(progressRef.contents, (function (progress) {
              progress.report({
                    increment: 100,
                    message: toString$1($$event)
                  });
            }));
      return resolve();
    } else {
      var percentageNew = $$event._0 / $$event._1 * 100.0 | 0;
      var increment = percentageNew - percentage.contents | 0;
      percentage.contents = percentageNew;
      if (increment > 0) {
        return Core__Option.forEach(progressRef.contents, (function (progress) {
                      progress.report({
                            increment: increment,
                            message: toString$1($$event)
                          });
                    }));
      } else {
        return ;
      }
    }
  };
}

var Progress = {
  report: report
};

function optionsToUrl(options) {
  return "https://" + options.host + options.path;
}

async function fetchWithRedirects(url, options) {
  try {
    var response = await fetch(url, {
          method: "GET",
          headers: Caml_option.some(new Headers(options))
        });
    if (response.ok) {
      return {
              TAG: "Ok",
              _0: response
            };
    }
    var error = {
      message: "HTTP " + String(response.status)
    };
    return {
            TAG: "Error",
            _0: {
              TAG: "ServerResponseError",
              _0: error
            }
          };
  }
  catch (raw_obj){
    var obj = Caml_js_exceptions.internalToOCamlException(raw_obj);
    if (obj.RE_EXN_ID === Js_exn.$$Error) {
      return {
              TAG: "Error",
              _0: {
                TAG: "ServerResponseError",
                _0: obj._1
              }
            };
    }
    var error$1 = {
      message: "Network error"
    };
    return {
            TAG: "Error",
            _0: {
              TAG: "ServerResponseError",
              _0: error$1
            }
          };
  }
}

async function gatherDataFromResponse(response) {
  try {
    var text = await response.text();
    return {
            TAG: "Ok",
            _0: text
          };
  }
  catch (raw_obj){
    var obj = Caml_js_exceptions.internalToOCamlException(raw_obj);
    if (obj.RE_EXN_ID === Js_exn.$$Error) {
      return {
              TAG: "Error",
              _0: {
                TAG: "ServerResponseError",
                _0: obj._1
              }
            };
    }
    var error = {
      message: "Failed to read response body"
    };
    return {
            TAG: "Error",
            _0: {
              TAG: "ServerResponseError",
              _0: error
            }
          };
  }
}

function timeoutAfter(p, n) {
  return Promise.race([
              new Promise((function (resolve, param) {
                      setTimeout((function () {
                              resolve({
                                    TAG: "Error",
                                    _0: {
                                      TAG: "Timeout",
                                      _0: n
                                    }
                                  });
                            }), n);
                    })),
              p
            ]);
}

async function asJson(httpOptions) {
  var url = optionsToUrl(httpOptions);
  var fetchOptions = (typeof process !== 'undefined' && process.versions && process.versions.node) ? ({
        headers: httpOptions.headers
      }) : {};
  var response = await fetchWithRedirects(url, fetchOptions);
  if (response.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: response._0
          };
  }
  var raw = await gatherDataFromResponse(response._0);
  if (raw.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: raw._0
          };
  }
  var raw$1 = raw._0;
  try {
    return {
            TAG: "Ok",
            _0: JSON.parse(raw$1)
          };
  }
  catch (exn){
    return {
            TAG: "Error",
            _0: {
              TAG: "JsonParseError",
              _0: raw$1
            }
          };
  }
}

async function asFile(httpOptions, destUri, onDownload) {
  var url = optionsToUrl(httpOptions);
  var fetchOptions = (typeof process !== 'undefined' && process.versions && process.versions.node) ? ({
        headers: httpOptions.headers
      }) : {};
  var response = await fetchWithRedirects(url, fetchOptions);
  if (response.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: response._0
          };
  }
  var response$1 = response._0;
  onDownload("Start");
  try {
    var contentLength;
    try {
      contentLength = Caml_option.some(Caml_option.nullable_to_opt(response$1.headers.get("content-length")));
    }
    catch (exn){
      contentLength = undefined;
    }
    var totalSize;
    if (contentLength !== undefined) {
      var length = Caml_option.valFromOption(contentLength);
      totalSize = length !== undefined ? Core__Option.getOr(Belt_Int.fromString(length), 0) : 0;
    } else {
      totalSize = 0;
    }
    var arrayBuffer = await response$1.arrayBuffer();
    var uint8Array = new Uint8Array(arrayBuffer);
    var fileSize = uint8Array.length;
    onDownload({
          TAG: "Progress",
          _0: fileSize,
          _1: totalSize
        });
    var error = await FS$AgdaModeVscode.writeFile(destUri, uint8Array);
    if (error.TAG === "Ok") {
      onDownload("Finish");
      return {
              TAG: "Ok",
              _0: undefined
            };
    }
    var exn$1 = {
      message: error._0
    };
    return {
            TAG: "Error",
            _0: {
              TAG: "CannotWriteFile",
              _0: exn$1
            }
          };
  }
  catch (raw_obj){
    var obj = Caml_js_exceptions.internalToOCamlException(raw_obj);
    if (obj.RE_EXN_ID === Js_exn.$$Error) {
      return {
              TAG: "Error",
              _0: {
                TAG: "CannotWriteFile",
                _0: obj._1
              }
            };
    }
    var error$1 = {
      message: "Failed to download file"
    };
    return {
            TAG: "Error",
            _0: {
              TAG: "CannotWriteFile",
              _0: error$1
            }
          };
  }
}

var Module = {
  asJson: asJson,
  asFile: asFile,
  timeoutAfter: timeoutAfter
};

exports.$$Error = $$Error;
exports.$$Event = $$Event;
exports.Progress = Progress;
exports.Module = Module;
exports.asJson = asJson;
exports.asFile = asFile;
exports.timeoutAfter = timeoutAfter;
/* vscode Not a pure module */
