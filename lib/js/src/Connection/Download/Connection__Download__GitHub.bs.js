// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Caml = require("rescript/lib/js/caml.js");
var Js_exn = require("rescript/lib/js/js_exn.js");
var Vscode = require("vscode");
var Js_dict = require("rescript/lib/js/js_dict.js");
var Nodefs = require("node:fs");
var Js_array = require("rescript/lib/js/js_array.js");
var Nodeurl = require("node:url");
var Nodepath = require("node:path");
var Caml_option = require("rescript/lib/js/caml_option.js");
var PervasivesU = require("rescript/lib/js/pervasivesU.js");
var Core__Option = require("@rescript/core/lib/js/src/Core__Option.bs.js");
var FS$AgdaModeVscode = require("../../FS.bs.js");
var OS$AgdaModeVscode = require("../../Util/OS.bs.js");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");
var Util$AgdaModeVscode = require("../../Util/Util.bs.js");
var Json$JsonCombinators = require("@glennsl/rescript-json-combinators/lib/js/src/Json.bs.js");
var Memento$AgdaModeVscode = require("../../Memento.bs.js");
var Json_Decode$JsonCombinators = require("@glennsl/rescript-json-combinators/lib/js/src/Json_Decode.bs.js");
var Json_Encode$JsonCombinators = require("@glennsl/rescript-json-combinators/lib/js/src/Json_Encode.bs.js");
var Connection__Download__Util$AgdaModeVscode = require("./Connection__Download__Util.bs.js");
var Connection__Download__Unzip$AgdaModeVscode = require("./Connection__Download__Unzip.bs.js");

function toString(x) {
  if (typeof x !== "object") {
    return "Already downloading";
  }
  switch (x.TAG) {
    case "ResponseDecodeError" :
        return "Cannot decode release metadata JSON from GitHub:\n" + x._0;
    case "CannotDownload" :
        return "Cannot download file from GitHub:\n" + Connection__Download__Util$AgdaModeVscode.$$Error.toString(x._0);
    case "CannotGetReleases" :
        return "Cannot get release info from GitHub:\n" + Connection__Download__Util$AgdaModeVscode.$$Error.toString(x._0);
    case "CannotReadReleasesCache" :
        return "Cannot read releases cache:\n" + x._0;
    case "CannotChmodFile" :
        return "Cannot chmod file \"" + x._0 + "\"";
    case "CannotStatFile" :
        return "Cannot stat file \"" + x._0 + "\"";
    case "CannotReadFile" :
        return "Cannot to read files:\n" + Util$AgdaModeVscode.JsError.toString(x._0);
    case "CannotDeleteFile" :
        return "Cannot to delete files:\n" + x._0;
    case "CannotRenameFile" :
        return "Cannot to rename files:\n" + x._0;
    
  }
}

var $$Error = {
  toString: toString
};

function toString$1(asset) {
  return "{" + Js_dict.entries(Js_dict.fromArray([
                      [
                        "url",
                        asset.url
                      ],
                      [
                        "id",
                        String(asset.id)
                      ],
                      [
                        "node_id",
                        asset.node_id
                      ],
                      [
                        "name",
                        asset.name
                      ],
                      [
                        "label",
                        asset.label
                      ],
                      [
                        "content_type",
                        asset.content_type
                      ],
                      [
                        "state",
                        asset.state
                      ],
                      [
                        "size",
                        String(asset.size)
                      ],
                      [
                        "created_at",
                        asset.created_at
                      ],
                      [
                        "updated_at",
                        asset.updated_at
                      ],
                      [
                        "browser_download_url",
                        asset.browser_download_url
                      ]
                    ])).map(function (param) {
                return param[0] + ": " + param[1];
              }).join(", ") + "}";
}

var decode = Json_Decode$JsonCombinators.object(function (field) {
      return {
              url: field.required("url", Json_Decode$JsonCombinators.string),
              id: field.required("id", Json_Decode$JsonCombinators.$$int),
              node_id: field.required("node_id", Json_Decode$JsonCombinators.string),
              name: field.required("name", Json_Decode$JsonCombinators.string),
              label: field.required("label", Json_Decode$JsonCombinators.string),
              content_type: field.required("content_type", Json_Decode$JsonCombinators.string),
              state: field.required("state", Json_Decode$JsonCombinators.string),
              size: field.required("size", Json_Decode$JsonCombinators.$$int),
              created_at: field.required("created_at", Json_Decode$JsonCombinators.string),
              updated_at: field.required("updated_at", Json_Decode$JsonCombinators.string),
              browser_download_url: field.required("browser_download_url", Json_Decode$JsonCombinators.string)
            };
    });

function encode(asset) {
  return {
          url: asset.url,
          id: asset.id,
          node_id: asset.node_id,
          name: asset.name,
          label: asset.label,
          content_type: asset.content_type,
          state: asset.state,
          size: asset.size,
          created_at: asset.created_at,
          updated_at: asset.updated_at,
          browser_download_url: asset.browser_download_url
        };
}

function chooseByName(assets, name) {
  return assets.find(function (asset) {
              return asset.name === name;
            });
}

var Asset = {
  toString: toString$1,
  decode: decode,
  encode: encode,
  chooseByName: chooseByName
};

function toString$2(release) {
  return "{" + Js_dict.entries(Js_dict.fromArray([
                      [
                        "url",
                        release.url
                      ],
                      [
                        "assets_url",
                        release.assets_url
                      ],
                      [
                        "upload_url",
                        release.upload_url
                      ],
                      [
                        "html_url",
                        release.html_url
                      ],
                      [
                        "id",
                        String(release.id)
                      ],
                      [
                        "node_id",
                        release.node_id
                      ],
                      [
                        "tag_name",
                        release.tag_name
                      ],
                      [
                        "target_commitish",
                        release.target_commitish
                      ],
                      [
                        "name",
                        release.name
                      ],
                      [
                        "draft",
                        PervasivesU.string_of_bool(release.draft)
                      ],
                      [
                        "prerelease",
                        PervasivesU.string_of_bool(release.prerelease)
                      ],
                      [
                        "created_at",
                        release.created_at
                      ],
                      [
                        "published_at",
                        release.published_at
                      ],
                      [
                        "assets",
                        release.assets.map(toString$1).join(", ")
                      ],
                      [
                        "tarball_url",
                        release.tarball_url
                      ],
                      [
                        "zipball_url",
                        release.zipball_url
                      ],
                      [
                        "body",
                        Core__Option.getOr(Core__Option.map(release.body, (function (s) {
                                    return "\"" + s + "\"";
                                  })), "null")
                      ]
                    ])).map(function (param) {
                return param[0] + ": " + param[1];
              }).join(", ") + "}";
}

var decode$1 = Json_Decode$JsonCombinators.object(function (field) {
      return {
              url: field.required("url", Json_Decode$JsonCombinators.string),
              assets_url: field.required("assets_url", Json_Decode$JsonCombinators.string),
              upload_url: field.required("upload_url", Json_Decode$JsonCombinators.string),
              html_url: field.required("html_url", Json_Decode$JsonCombinators.string),
              id: field.required("id", Json_Decode$JsonCombinators.$$int),
              node_id: field.required("node_id", Json_Decode$JsonCombinators.string),
              tag_name: field.required("tag_name", Json_Decode$JsonCombinators.string),
              target_commitish: field.required("target_commitish", Json_Decode$JsonCombinators.string),
              name: field.required("name", Json_Decode$JsonCombinators.string),
              draft: field.required("draft", Json_Decode$JsonCombinators.bool),
              prerelease: field.required("prerelease", Json_Decode$JsonCombinators.bool),
              created_at: field.required("created_at", Json_Decode$JsonCombinators.string),
              published_at: field.required("published_at", Json_Decode$JsonCombinators.string),
              assets: field.required("assets", Json_Decode$JsonCombinators.array(decode)),
              tarball_url: field.required("tarball_url", Json_Decode$JsonCombinators.string),
              zipball_url: field.required("zipball_url", Json_Decode$JsonCombinators.string),
              body: field.required("body", Json_Decode$JsonCombinators.option(Json_Decode$JsonCombinators.string))
            };
    });

function encode$1(release) {
  return {
          url: release.url,
          assets_url: release.assets_url,
          upload_url: release.upload_url,
          html_url: release.html_url,
          id: release.id,
          node_id: release.node_id,
          tag_name: release.tag_name,
          target_commitish: release.target_commitish,
          name: release.name,
          draft: release.draft,
          prerelease: release.prerelease,
          created_at: release.created_at,
          published_at: release.published_at,
          assets: Json_Encode$JsonCombinators.array(encode)(release.assets),
          tarball_url: release.tarball_url,
          zipball_url: release.zipball_url,
          body: Json_Encode$JsonCombinators.option(function (prim) {
                  return prim;
                })(release.body)
        };
}

function encodeReleases(releases) {
  return Json_Encode$JsonCombinators.array(encode$1)(releases);
}

function decodeReleases(json) {
  var releases = Json$JsonCombinators.decode(json, Json_Decode$JsonCombinators.array(decode$1));
  if (releases.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: releases._0
          };
  } else {
    return {
            TAG: "Error",
            _0: {
              TAG: "ResponseDecodeError",
              _0: releases._0,
              _1: json
            }
          };
  }
}

function chooseByTagName(releases, tagName) {
  return releases.find(function (release) {
              return release.tag_name === tagName;
            });
}

function chooseLatest(releases) {
  var compare = function (x, y) {
    var xTime = new Date(x.created_at).getTime();
    var yTime = new Date(y.created_at).getTime();
    return Caml.float_compare(yTime, xTime);
  };
  var sorted = Js_array.sortInPlaceWith(compare, releases);
  return sorted[0];
}

var Release = {
  toString: toString$2,
  decode: decode$1,
  encode: encode$1,
  encodeReleases: encodeReleases,
  decodeReleases: decodeReleases,
  chooseByTagName: chooseByTagName,
  chooseLatest: chooseLatest
};

function toString$3(desc) {
  return "{" + Js_dict.entries(Js_dict.fromArray([
                      [
                        "release",
                        toString$2(desc.release)
                      ],
                      [
                        "asset",
                        toString$1(desc.asset)
                      ],
                      [
                        "saveAsFileName",
                        desc.saveAsFileName
                      ]
                    ])).map(function (param) {
                return param[0] + ": " + param[1];
              }).join(", ") + "}";
}

var DownloadDescriptor = {
  toString: toString$3
};

async function chmodExecutable(path) {
  try {
    await Nodefs.promises.chmod(path, 484);
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === Js_exn.$$Error) {
      return {
              TAG: "Error",
              _0: {
                TAG: "CannotChmodFile",
                _0: path
              }
            };
    }
    throw exn;
  }
}

function toString$4(self) {
  return "{" + Js_dict.entries(Js_dict.fromArray([
                      [
                        "username",
                        self.username
                      ],
                      [
                        "repository",
                        self.repository
                      ],
                      [
                        "userAgent",
                        self.userAgent
                      ],
                      [
                        "globalStorageUri",
                        self.globalStorageUri.toString()
                      ],
                      [
                        "cacheInvalidateExpirationSecs",
                        String(self.cacheInvalidateExpirationSecs)
                      ]
                    ])).map(function (param) {
                return param[0] + ": " + param[1];
              }).join(", ") + "}";
}

var Repo = {
  toString: toString$4
};

var Callbacks = {};

async function fetchWithoutCache(repo) {
  var httpOptions = {
    host: "api.github.com",
    path: "/repos/" + repo.username + "/" + repo.repository + "/releases",
    headers: {
      "User-Agent": repo.userAgent
    }
  };
  var e = await Connection__Download__Util$AgdaModeVscode.timeoutAfter(Connection__Download__Util$AgdaModeVscode.asJson(httpOptions), 10000);
  if (e.TAG === "Ok") {
    return decodeReleases(e._0);
  } else {
    return {
            TAG: "Error",
            _0: {
              TAG: "CannotGetReleases",
              _0: e._0
            }
          };
  }
}

async function fetchFromCache(memento, repo) {
  var string = Memento$AgdaModeVscode.Module.ALSReleaseCache.getReleases(memento, repo.username, repo.repository);
  if (string === undefined) {
    return {
            TAG: "Ok",
            _0: []
          };
  }
  var string$1 = Caml_option.valFromOption(string);
  var json;
  try {
    json = JSON.parse(string$1);
  }
  catch (exn){
    return {
            TAG: "Error",
            _0: {
              TAG: "CannotReadReleasesCache",
              _0: string$1
            }
          };
  }
  var e = decodeReleases(json);
  if (e.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: e._0
          };
  } else {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
}

async function writeToCache(memento, repo, result) {
  if (result.TAG !== "Ok") {
    return ;
  }
  var json = JSON.stringify(encodeReleases(result._0));
  await Memento$AgdaModeVscode.Module.ALSReleaseCache.setTimestamp(memento, repo.username, repo.repository, new Date());
  return await Memento$AgdaModeVscode.Module.ALSReleaseCache.setReleases(memento, repo.username, repo.repository, json);
}

async function $$fetch(memento, repo, useCacheOpt) {
  var useCache = useCacheOpt !== undefined ? useCacheOpt : true;
  if (useCache) {
    var cacheAge = Memento$AgdaModeVscode.Module.ALSReleaseCache.getCacheAgeInSecs(memento, repo.username, repo.repository);
    var cacheInvalidated = cacheAge !== undefined ? cacheAge > repo.cacheInvalidateExpirationSecs : true;
    if (!cacheInvalidated) {
      return [
              await fetchFromCache(memento, repo),
              true
            ];
    }
    var result = await fetchWithoutCache(repo);
    await writeToCache(memento, repo, result);
    return [
            result,
            false
          ];
  }
  var result$1 = await fetchWithoutCache(repo);
  return [
          result$1,
          false
        ];
}

var ReleaseManifest = {
  $$fetch: $$fetch
};

var inFlightDownloadFileName = "in-flight.download";

async function isDownloading(globalStorageUri) {
  try {
    var match = await FS$AgdaModeVscode.stat(globalStorageUri);
    var exists;
    exists = match.TAG === "Ok" ? true : false;
    if (exists) {
      var inFlightDownloadUri = Vscode.Uri.joinPath(globalStorageUri, inFlightDownloadFileName);
      var match$1 = await FS$AgdaModeVscode.stat(inFlightDownloadUri);
      if (match$1.TAG === "Ok") {
        return true;
      } else {
        return false;
      }
    }
    await FS$AgdaModeVscode.createDirectory(globalStorageUri);
    return false;
  }
  catch (exn){
    return false;
  }
}

async function downloadLanguageServer(repo, onDownload, downloadDescriptor) {
  var url = new Nodeurl.URL(downloadDescriptor.asset.browser_download_url);
  var httpOptions = {
    host: url.host,
    path: url.pathname,
    headers: {
      "User-Agent": repo.userAgent
    }
  };
  var inFlightDownloadUri = Vscode.Uri.joinPath(repo.globalStorageUri, inFlightDownloadFileName);
  var inFlightDownloadZipUri = Vscode.Uri.joinPath(repo.globalStorageUri, inFlightDownloadFileName + ".zip");
  var destPath = Vscode.Uri.joinPath(repo.globalStorageUri, downloadDescriptor.saveAsFileName);
  var e = await Connection__Download__Util$AgdaModeVscode.asFile(httpOptions, inFlightDownloadUri, onDownload);
  var result;
  if (e.TAG === "Ok") {
    if (downloadDescriptor.saveAsFileName === "dev-wasm-als") {
      await FS$AgdaModeVscode.createDirectory(destPath);
      var wasmDestUri = Vscode.Uri.joinPath(destPath, "als.wasm");
      var e$1 = await FS$AgdaModeVscode.rename(inFlightDownloadUri, wasmDestUri);
      result = e$1.TAG === "Ok" ? ({
            TAG: "Ok",
            _0: undefined
          }) : ({
            TAG: "Error",
            _0: {
              TAG: "CannotRenameFile",
              _0: e$1._0
            }
          });
    } else {
      var e$2 = await FS$AgdaModeVscode.rename(inFlightDownloadUri, inFlightDownloadZipUri);
      if (e$2.TAG === "Ok") {
        await Connection__Download__Unzip$AgdaModeVscode.run(inFlightDownloadZipUri, destPath);
        var e$3 = await FS$AgdaModeVscode.$$delete(inFlightDownloadZipUri);
        result = e$3.TAG === "Ok" ? ({
              TAG: "Ok",
              _0: undefined
            }) : ({
              TAG: "Error",
              _0: {
                TAG: "CannotDeleteFile",
                _0: e$3._0
              }
            });
      } else {
        result = {
          TAG: "Error",
          _0: {
            TAG: "CannotRenameFile",
            _0: e$2._0
          }
        };
      }
    }
  } else {
    result = {
      TAG: "Error",
      _0: {
        TAG: "CannotDownload",
        _0: e._0
      }
    };
  }
  if (result.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
  var $$delete = async function (uri) {
    await FS$AgdaModeVscode.$$delete(uri);
  };
  await Promise.all([
        $$delete(inFlightDownloadUri),
        $$delete(inFlightDownloadZipUri)
      ]);
  return {
          TAG: "Error",
          _0: result._0
        };
}

async function download(downloadDescriptor, globalStorageUri, reportProgress) {
  var repo = {
    username: "agda",
    repository: "agda-language-server",
    userAgent: "agda/agda-mode-vscode",
    globalStorageUri: globalStorageUri,
    cacheInvalidateExpirationSecs: 86400
  };
  var ifIsDownloading = await isDownloading(globalStorageUri);
  if (ifIsDownloading) {
    return {
            TAG: "Error",
            _0: "AlreadyDownloading"
          };
  }
  var destUri = Vscode.Uri.joinPath(globalStorageUri, downloadDescriptor.saveAsFileName);
  var match = await FS$AgdaModeVscode.stat(destUri);
  if (match.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: true
          };
  }
  var error = await downloadLanguageServer(repo, reportProgress, downloadDescriptor);
  if (error.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: error._0
          };
  }
  var destPath = destUri.fsPath;
  var execPath = Nodepath.join(destPath, "als");
  if (OS$AgdaModeVscode.onUnix) {
    await chmodExecutable(execPath);
  }
  return {
          TAG: "Ok",
          _0: false
        };
}

var Module = {
  download: download,
  isDownloading: isDownloading
};

var Unzip;

var Download;

exports.Unzip = Unzip;
exports.Download = Download;
exports.$$Error = $$Error;
exports.Asset = Asset;
exports.Release = Release;
exports.DownloadDescriptor = DownloadDescriptor;
exports.chmodExecutable = chmodExecutable;
exports.Repo = Repo;
exports.Callbacks = Callbacks;
exports.ReleaseManifest = ReleaseManifest;
exports.Module = Module;
exports.download = download;
exports.isDownloading = isDownloading;
/* decode Not a pure module */
