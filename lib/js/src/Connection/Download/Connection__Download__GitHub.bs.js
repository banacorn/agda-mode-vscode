// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Caml = require("rescript/lib/js/caml.js");
var Js_exn = require("rescript/lib/js/js_exn.js");
var Vscode = require("vscode");
var Js_dict = require("rescript/lib/js/js_dict.js");
var Nodefs = require("node:fs");
var Js_array = require("rescript/lib/js/js_array.js");
var Nodeurl = require("node:url");
var Nodepath = require("node:path");
var Caml_option = require("rescript/lib/js/caml_option.js");
var PervasivesU = require("rescript/lib/js/pervasivesU.js");
var Core__Option = require("@rescript/core/lib/js/src/Core__Option.bs.js");
var FS$AgdaModeVscode = require("../../FS.bs.js");
var OS$AgdaModeVscode = require("../../Util/OS.bs.js");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");
var Util$AgdaModeVscode = require("../../Util/Util.bs.js");
var Json$JsonCombinators = require("@glennsl/rescript-json-combinators/lib/js/src/Json.bs.js");
var Json_Decode$JsonCombinators = require("@glennsl/rescript-json-combinators/lib/js/src/Json_Decode.bs.js");
var Json_Encode$JsonCombinators = require("@glennsl/rescript-json-combinators/lib/js/src/Json_Encode.bs.js");
var State__Memento$AgdaModeVscode = require("../../State/State__Memento.bs.js");
var Connection__Download__Util$AgdaModeVscode = require("./Connection__Download__Util.bs.js");
var Connection__Download__Unzip$AgdaModeVscode = require("./Connection__Download__Unzip.bs.js");

function toString(x) {
  if (typeof x !== "object") {
    if (x === "NoMatchingRelease") {
      return "Cannot find matching release from GitHub";
    } else {
      return "Already downloading";
    }
  }
  switch (x.TAG) {
    case "ResponseDecodeError" :
        return "Cannot decode release metadata JSON from GitHub:\n" + x._0;
    case "CannotDownload" :
        return "Cannot download file from GitHub:\n" + Connection__Download__Util$AgdaModeVscode.$$Error.toString(x._0);
    case "CannotGetReleases" :
        return "Cannot get release info from GitHub:\n" + Connection__Download__Util$AgdaModeVscode.$$Error.toString(x._0);
    case "CannotReadReleasesCache" :
        return "Cannot read releases cache:\n" + x._0;
    case "CannotCacheReleases" :
        return "Failed to cache releases:\n" + Util$AgdaModeVscode.JsError.toString(x._0);
    case "CannotChmodFile" :
        return "Cannot chmod file \"" + x._0 + "\"";
    case "CannotStatFile" :
        return "Cannot stat file \"" + x._0 + "\"";
    case "CannotReadFile" :
        return "Cannot to read files:\n" + Util$AgdaModeVscode.JsError.toString(x._0);
    case "CannotDeleteFile" :
        return "Cannot to delete files:\n" + x._0;
    case "CannotRenameFile" :
        return "Cannot to rename files:\n" + x._0;
    case "CannotDetermineOS" :
        return "Cannot determine OS:\n" + Util$AgdaModeVscode.JsError.toString(x._0);
    
  }
}

var $$Error = {
  toString: toString
};

function toString$1(asset) {
  return "{" + Js_dict.entries(Js_dict.fromArray([
                      [
                        "url",
                        asset.url
                      ],
                      [
                        "id",
                        String(asset.id)
                      ],
                      [
                        "node_id",
                        asset.node_id
                      ],
                      [
                        "name",
                        asset.name
                      ],
                      [
                        "label",
                        asset.label
                      ],
                      [
                        "content_type",
                        asset.content_type
                      ],
                      [
                        "state",
                        asset.state
                      ],
                      [
                        "size",
                        String(asset.size)
                      ],
                      [
                        "created_at",
                        asset.created_at
                      ],
                      [
                        "updated_at",
                        asset.updated_at
                      ],
                      [
                        "browser_download_url",
                        asset.browser_download_url
                      ]
                    ])).map(function (param) {
                return param[0] + ": " + param[1];
              }).join(", ") + "}";
}

var decode = Json_Decode$JsonCombinators.object(function (field) {
      return {
              url: field.required("url", Json_Decode$JsonCombinators.string),
              id: field.required("id", Json_Decode$JsonCombinators.$$int),
              node_id: field.required("node_id", Json_Decode$JsonCombinators.string),
              name: field.required("name", Json_Decode$JsonCombinators.string),
              label: field.required("label", Json_Decode$JsonCombinators.string),
              content_type: field.required("content_type", Json_Decode$JsonCombinators.string),
              state: field.required("state", Json_Decode$JsonCombinators.string),
              size: field.required("size", Json_Decode$JsonCombinators.$$int),
              created_at: field.required("created_at", Json_Decode$JsonCombinators.string),
              updated_at: field.required("updated_at", Json_Decode$JsonCombinators.string),
              browser_download_url: field.required("browser_download_url", Json_Decode$JsonCombinators.string)
            };
    });

function encode(asset) {
  return {
          url: asset.url,
          id: asset.id,
          node_id: asset.node_id,
          name: asset.name,
          label: asset.label,
          content_type: asset.content_type,
          state: asset.state,
          size: asset.size,
          created_at: asset.created_at,
          updated_at: asset.updated_at,
          browser_download_url: asset.browser_download_url
        };
}

function chooseByName(assets, name) {
  return assets.find(function (asset) {
              return asset.name === name;
            });
}

var Asset = {
  toString: toString$1,
  decode: decode,
  encode: encode,
  chooseByName: chooseByName
};

function toString$2(release) {
  return "{" + Js_dict.entries(Js_dict.fromArray([
                      [
                        "url",
                        release.url
                      ],
                      [
                        "assets_url",
                        release.assets_url
                      ],
                      [
                        "upload_url",
                        release.upload_url
                      ],
                      [
                        "html_url",
                        release.html_url
                      ],
                      [
                        "id",
                        String(release.id)
                      ],
                      [
                        "node_id",
                        release.node_id
                      ],
                      [
                        "tag_name",
                        release.tag_name
                      ],
                      [
                        "target_commitish",
                        release.target_commitish
                      ],
                      [
                        "name",
                        release.name
                      ],
                      [
                        "draft",
                        PervasivesU.string_of_bool(release.draft)
                      ],
                      [
                        "prerelease",
                        PervasivesU.string_of_bool(release.prerelease)
                      ],
                      [
                        "created_at",
                        release.created_at
                      ],
                      [
                        "published_at",
                        release.published_at
                      ],
                      [
                        "assets",
                        release.assets.map(toString$1).join(", ")
                      ],
                      [
                        "tarball_url",
                        release.tarball_url
                      ],
                      [
                        "zipball_url",
                        release.zipball_url
                      ],
                      [
                        "body",
                        Core__Option.getOr(Core__Option.map(release.body, (function (s) {
                                    return "\"" + s + "\"";
                                  })), "null")
                      ]
                    ])).map(function (param) {
                return param[0] + ": " + param[1];
              }).join(", ") + "}";
}

var decode$1 = Json_Decode$JsonCombinators.object(function (field) {
      return {
              url: field.required("url", Json_Decode$JsonCombinators.string),
              assets_url: field.required("assets_url", Json_Decode$JsonCombinators.string),
              upload_url: field.required("upload_url", Json_Decode$JsonCombinators.string),
              html_url: field.required("html_url", Json_Decode$JsonCombinators.string),
              id: field.required("id", Json_Decode$JsonCombinators.$$int),
              node_id: field.required("node_id", Json_Decode$JsonCombinators.string),
              tag_name: field.required("tag_name", Json_Decode$JsonCombinators.string),
              target_commitish: field.required("target_commitish", Json_Decode$JsonCombinators.string),
              name: field.required("name", Json_Decode$JsonCombinators.string),
              draft: field.required("draft", Json_Decode$JsonCombinators.bool),
              prerelease: field.required("prerelease", Json_Decode$JsonCombinators.bool),
              created_at: field.required("created_at", Json_Decode$JsonCombinators.string),
              published_at: field.required("published_at", Json_Decode$JsonCombinators.string),
              assets: field.required("assets", Json_Decode$JsonCombinators.array(decode)),
              tarball_url: field.required("tarball_url", Json_Decode$JsonCombinators.string),
              zipball_url: field.required("zipball_url", Json_Decode$JsonCombinators.string),
              body: field.required("body", Json_Decode$JsonCombinators.option(Json_Decode$JsonCombinators.string))
            };
    });

function encode$1(release) {
  return {
          url: release.url,
          assets_url: release.assets_url,
          upload_url: release.upload_url,
          html_url: release.html_url,
          id: release.id,
          node_id: release.node_id,
          tag_name: release.tag_name,
          target_commitish: release.target_commitish,
          name: release.name,
          draft: release.draft,
          prerelease: release.prerelease,
          created_at: release.created_at,
          published_at: release.published_at,
          assets: Json_Encode$JsonCombinators.array(encode)(release.assets),
          tarball_url: release.tarball_url,
          zipball_url: release.zipball_url,
          body: Json_Encode$JsonCombinators.option(function (prim) {
                  return prim;
                })(release.body)
        };
}

function encodeReleases(releases) {
  return Json_Encode$JsonCombinators.array(encode$1)(releases);
}

function decodeReleases(json) {
  var releases = Json$JsonCombinators.decode(json, Json_Decode$JsonCombinators.array(decode$1));
  if (releases.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: releases._0
          };
  } else {
    return {
            TAG: "Error",
            _0: {
              TAG: "ResponseDecodeError",
              _0: releases._0,
              _1: json
            }
          };
  }
}

function chooseByTagName(releases, tagName) {
  return releases.find(function (release) {
              return release.tag_name === tagName;
            });
}

function chooseLatest(releases) {
  var compare = function (x, y) {
    var xTime = new Date(x.created_at).getTime();
    var yTime = new Date(y.created_at).getTime();
    return Caml.float_compare(yTime, xTime);
  };
  var sorted = Js_array.sortInPlaceWith(compare, releases);
  return sorted[0];
}

var Release = {
  toString: toString$2,
  decode: decode$1,
  encode: encode$1,
  encodeReleases: encodeReleases,
  decodeReleases: decodeReleases,
  chooseByTagName: chooseByTagName,
  chooseLatest: chooseLatest
};

var FetchSpec = {};

async function chmodExecutable(path) {
  try {
    await Nodefs.promises.chmod(path, 484);
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === Js_exn.$$Error) {
      return {
              TAG: "Error",
              _0: {
                TAG: "CannotChmodFile",
                _0: path
              }
            };
    }
    throw exn;
  }
}

function toString$3(self) {
  return "{" + Js_dict.entries(Js_dict.fromArray([
                      [
                        "username",
                        self.username
                      ],
                      [
                        "repository",
                        self.repository
                      ],
                      [
                        "userAgent",
                        self.userAgent
                      ],
                      [
                        "globalStorageUri",
                        self.globalStorageUri.toString()
                      ],
                      [
                        "cacheInvalidateExpirationSecs",
                        String(self.cacheInvalidateExpirationSecs)
                      ]
                    ])).map(function (param) {
                return param[0] + ": " + param[1];
              }).join(", ") + "}";
}

var Repo = {
  toString: toString$3
};

var Callbacks = {};

function readTimestamp(memento) {
  return Core__Option.map(State__Memento$AgdaModeVscode.get(memento, "alsReleaseCacheTimestamp"), (function (prim) {
                return new Date(prim);
              }));
}

function writeTimestamp(memento, timestamp) {
  return State__Memento$AgdaModeVscode.set(memento, "alsReleaseCacheTimestamp", timestamp.toString());
}

function writeReleaseCache(memento, releases) {
  return State__Memento$AgdaModeVscode.set(memento, "alsReleaseCache", releases);
}

function cacheAgeInSecs(memento) {
  var timestamp = readTimestamp(memento);
  if (timestamp === undefined) {
    return ;
  }
  var currentTime = Date.now();
  var lastModifiedTime = Caml_option.valFromOption(timestamp).getTime();
  return (currentTime - lastModifiedTime) / 1000.0 | 0;
}

async function fetchFromCache(memento) {
  var string = State__Memento$AgdaModeVscode.get(memento, "alsReleaseCache");
  if (string === undefined) {
    return {
            TAG: "Ok",
            _0: []
          };
  }
  var string$1 = Caml_option.valFromOption(string);
  var json;
  try {
    json = JSON.parse(string$1);
  }
  catch (exn){
    return {
            TAG: "Error",
            _0: {
              TAG: "CannotReadReleasesCache",
              _0: string$1
            }
          };
  }
  var e = decodeReleases(json);
  if (e.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: e._0
          };
  } else {
    return {
            TAG: "Error",
            _0: e._0
          };
  }
}

async function writeToCache(memento, releases) {
  var json = JSON.stringify(encodeReleases(releases));
  await writeTimestamp(memento, new Date());
  return await writeReleaseCache(memento, json);
}

async function fetchFromGitHubAndCache(repo) {
  var httpOptions = {
    host: "api.github.com",
    path: "/repos/" + repo.username + "/" + repo.repository + "/releases",
    headers: {
      "User-Agent": repo.userAgent
    }
  };
  var e = await Connection__Download__Util$AgdaModeVscode.timeoutAfter(Connection__Download__Util$AgdaModeVscode.asJson(httpOptions), 10000);
  if (e.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: {
              TAG: "CannotGetReleases",
              _0: e._0
            }
          };
  }
  var e$1 = decodeReleases(e._0);
  if (e$1.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: e$1._0
          };
  }
  var releases = e$1._0;
  await writeToCache(repo.memento, releases);
  return {
          TAG: "Ok",
          _0: releases
        };
}

async function $$fetch(repo) {
  var cacheAge = cacheAgeInSecs(repo.memento);
  var cacheInvalidated = cacheAge !== undefined ? cacheAge > repo.cacheInvalidateExpirationSecs : true;
  if (cacheInvalidated) {
    return [
            await fetchFromGitHubAndCache(repo),
            false
          ];
  } else {
    return [
            await fetchFromCache(repo.memento),
            true
          ];
  }
}

var ReleaseManifest = {
  cacheAgeInSecs: cacheAgeInSecs,
  $$fetch: $$fetch,
  fetchFromGitHubAndCache: fetchFromGitHubAndCache
};

var inFlightDownloadFileName = "in-flight.download";

async function isDownloading(globalStorageUri) {
  try {
    var match = await FS$AgdaModeVscode.stat(globalStorageUri);
    var exists;
    exists = match.TAG === "Ok" ? true : false;
    if (exists) {
      var inFlightDownloadUri = Vscode.Uri.joinPath(globalStorageUri, inFlightDownloadFileName);
      var match$1 = await FS$AgdaModeVscode.stat(inFlightDownloadUri);
      if (match$1.TAG === "Ok") {
        return true;
      } else {
        return false;
      }
    }
    await FS$AgdaModeVscode.createDirectory(globalStorageUri);
    return false;
  }
  catch (exn){
    return false;
  }
}

async function downloadLanguageServer(repo, onDownload, fetchSpec) {
  var url = new Nodeurl.URL(fetchSpec.asset.browser_download_url);
  var httpOptions = {
    host: url.host,
    path: url.pathname,
    headers: {
      "User-Agent": repo.userAgent
    }
  };
  var inFlightDownloadUri = Vscode.Uri.joinPath(repo.globalStorageUri, inFlightDownloadFileName);
  var inFlightDownloadZipUri = Vscode.Uri.joinPath(inFlightDownloadUri, ".zip");
  var destPath = Vscode.Uri.joinPath(repo.globalStorageUri, fetchSpec.saveAsFileName);
  var e = await Connection__Download__Util$AgdaModeVscode.asFile(httpOptions, inFlightDownloadUri, onDownload);
  var result;
  if (e.TAG === "Ok") {
    var e$1 = await FS$AgdaModeVscode.rename(inFlightDownloadUri, inFlightDownloadZipUri);
    if (e$1.TAG === "Ok") {
      await Connection__Download__Unzip$AgdaModeVscode.run(inFlightDownloadZipUri, destPath);
      var e$2 = await FS$AgdaModeVscode.$$delete(inFlightDownloadZipUri);
      result = e$2.TAG === "Ok" ? ({
            TAG: "Ok",
            _0: undefined
          }) : ({
            TAG: "Error",
            _0: {
              TAG: "CannotDeleteFile",
              _0: e$2._0
            }
          });
    } else {
      result = {
        TAG: "Error",
        _0: {
          TAG: "CannotRenameFile",
          _0: e$1._0
        }
      };
    }
  } else {
    result = {
      TAG: "Error",
      _0: {
        TAG: "CannotDownload",
        _0: e._0
      }
    };
  }
  if (result.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
  var $$delete = async function (uri) {
    await FS$AgdaModeVscode.$$delete(uri);
  };
  await Promise.all([
        $$delete(inFlightDownloadUri),
        $$delete(inFlightDownloadZipUri)
      ]);
  return {
          TAG: "Error",
          _0: result._0
        };
}

async function download(fetchSpec, memento, globalStorageUri, reportProgress) {
  var repo = {
    username: "agda",
    repository: "agda-language-server",
    userAgent: "agda/agda-mode-vscode",
    memento: memento,
    globalStorageUri: globalStorageUri,
    cacheInvalidateExpirationSecs: 86400
  };
  var ifIsDownloading = await isDownloading(globalStorageUri);
  if (ifIsDownloading) {
    return {
            TAG: "Error",
            _0: "AlreadyDownloading"
          };
  }
  var destUri = Vscode.Uri.joinPath(globalStorageUri, fetchSpec.saveAsFileName);
  var match = await FS$AgdaModeVscode.stat(destUri);
  if (match.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: true
          };
  }
  var error = await downloadLanguageServer(repo, reportProgress, fetchSpec);
  if (error.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: error._0
          };
  }
  var destPath = destUri.fsPath;
  var execPath = Nodepath.join(destPath, "als");
  if (OS$AgdaModeVscode.onUnix) {
    await chmodExecutable(execPath);
  }
  return {
          TAG: "Ok",
          _0: false
        };
}

var Module = {
  download: download,
  isDownloading: isDownloading
};

var Unzip;

var Download;

exports.Unzip = Unzip;
exports.Download = Download;
exports.$$Error = $$Error;
exports.Asset = Asset;
exports.Release = Release;
exports.FetchSpec = FetchSpec;
exports.chmodExecutable = chmodExecutable;
exports.Repo = Repo;
exports.Callbacks = Callbacks;
exports.ReleaseManifest = ReleaseManifest;
exports.Module = Module;
exports.download = download;
exports.isDownloading = isDownloading;
/* decode Not a pure module */
