// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Url = require("url");
var Js_exn = require("rescript/lib/js/js_exn.js");
var Nodefs = require("node:fs");
var Nodepath = require("node:path");
var Core__Option = require("@rescript/core/lib/js/src/Core__Option.bs.js");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");
var Config$AgdaModeVscode = require("../Config.bs.js");
var Connection__URI$AgdaModeVscode = require("./Connection__URI.bs.js");
var Connection__Target$AgdaModeVscode = require("./Connection__Target.bs.js");
var Connection__Download__Util$AgdaModeVscode = require("./Download/Connection__Download__Util.bs.js");
var Connection__Download__Unzip$AgdaModeVscode = require("./Download/Connection__Download__Unzip.bs.js");
var Connection__Download__GitHub$AgdaModeVscode = require("./Download/Connection__Download__GitHub.bs.js");

function toString(x) {
  if (typeof x !== "object") {
    return "Cannot find compatible Agda Language Server release for download. Prebuilts are only available for download on Ubuntu, Windows, and macOS (arm64, x64).\nPlease build from source if you are on a different platform. \nSee https://github.com/agda/agda-language-server for more information.";
  }
  switch (x.TAG) {
    case "CannotFetchALSReleases" :
        return "Cannot fetch releases of Agda Language Server: " + Connection__Download__GitHub$AgdaModeVscode.$$Error.toString(x._0);
    case "CannotDownloadALS" :
        return "Failed to download the Agda Language Server: " + Connection__Download__GitHub$AgdaModeVscode.$$Error.toString(x._0);
    case "CannotConnectToALS" :
        return Connection__Target$AgdaModeVscode.$$Error.toString(x._0);
    case "CannotDownloadFromURL" :
        return "Failed to download from URL: " + Connection__Download__GitHub$AgdaModeVscode.$$Error.toString(x._0);
    
  }
}

var $$Error = {
  toString: toString
};

function makeRepo(memento, globalStorageUri) {
  return {
          username: "agda",
          repository: "agda-language-server",
          userAgent: "agda/agda-mode-vscode",
          memento: memento,
          globalStoragePath: globalStorageUri.fsPath,
          cacheInvalidateExpirationSecs: 86400
        };
}

async function getReleaseManifest(memento, globalStorageUri) {
  var match = await Connection__Download__GitHub$AgdaModeVscode.ReleaseManifest.$$fetch(makeRepo(memento, globalStorageUri));
  var error = match[0];
  if (error.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: error._0
          };
  } else {
    return {
            TAG: "Error",
            _0: {
              TAG: "CannotFetchALSReleases",
              _0: error._0
            }
          };
  }
}

async function download(memento, globalStorageUri, fetchSpec) {
  var reportProgress = await Connection__Download__Util$AgdaModeVscode.Progress.report("Agda Language Server");
  var globalStoragePath = globalStorageUri.fsPath;
  var error = await Connection__Download__GitHub$AgdaModeVscode.download(fetchSpec, memento, globalStoragePath, reportProgress);
  if (error.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: {
              TAG: "CannotDownloadALS",
              _0: error._0
            }
          };
  }
  var destPath = Connection__URI$AgdaModeVscode.parse(Nodepath.join(globalStoragePath, fetchSpec.saveAsFileName, "als"));
  await Config$AgdaModeVscode.Connection.addAgdaPath(destPath);
  var e = await Connection__Target$AgdaModeVscode.fromURI(destPath);
  if (e.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: e._0
          };
  } else {
    return {
            TAG: "Error",
            _0: {
              TAG: "CannotConnectToALS",
              _0: e._0
            }
          };
  }
}

async function downloadFromURL(globalStorageUri, url, saveAsFileName, displayName) {
  var reportProgress = await Connection__Download__Util$AgdaModeVscode.Progress.report(displayName);
  var globalStoragePath = globalStorageUri.fsPath;
  var destDir = Nodepath.join(globalStoragePath, saveAsFileName);
  if (!Nodefs.existsSync(destDir)) {
    await Nodefs.promises.mkdir(destDir, {
          recursive: true,
          mode: 511
        });
  }
  var execPath = Nodepath.join(destDir, "als");
  if (Nodefs.existsSync(execPath)) {
    var destPath = Connection__URI$AgdaModeVscode.parse(execPath);
    await Config$AgdaModeVscode.Connection.addAgdaPath(destPath);
    var e = await Connection__Target$AgdaModeVscode.fromURI(destPath);
    if (e.TAG === "Ok") {
      return {
              TAG: "Ok",
              _0: e._0
            };
    } else {
      return {
              TAG: "Error",
              _0: {
                TAG: "CannotConnectToALS",
                _0: e._0
              }
            };
    }
  }
  try {
    var urlObj = Url.parse(url);
    var host = urlObj.hostname;
    var path = urlObj.pathname + Core__Option.getOr(urlObj.search, "");
    var tempFilePath = Nodepath.join(destDir, "download.tmp");
    var httpOptions = {
      host: host,
      path: path,
      headers: {
        "User-Agent": "agda/agda-mode-vscode"
      }
    };
    var error = await Connection__Download__Util$AgdaModeVscode.asFile(httpOptions, tempFilePath, reportProgress);
    if (error.TAG === "Ok") {
      var fileHandle = await Nodefs.promises.open(tempFilePath, "r");
      var buffer = await fileHandle.readFile();
      await fileHandle.close();
      var isPKHeader = buffer.length >= 4 ? buffer.readUint8(0) === 80 && buffer.readUint8(1) === 75 && buffer.readUint8(2) === 3 && buffer.readUint8(3) === 4 : false;
      if (isPKHeader) {
        var zipFilePath = Nodepath.join(destDir, "download.zip");
        await Connection__Download__GitHub$AgdaModeVscode.Nd.Fs.rename(tempFilePath, zipFilePath);
        await Connection__Download__Unzip$AgdaModeVscode.run(zipFilePath, destDir);
        await Connection__Download__GitHub$AgdaModeVscode.Nd.Fs.unlink(zipFilePath);
        var destPath$1 = Connection__URI$AgdaModeVscode.parse(execPath);
        await Config$AgdaModeVscode.Connection.addAgdaPath(destPath$1);
        var e$1 = await Connection__Target$AgdaModeVscode.fromURI(destPath$1);
        if (e$1.TAG === "Ok") {
          return {
                  TAG: "Ok",
                  _0: e$1._0
                };
        } else {
          return {
                  TAG: "Error",
                  _0: {
                    TAG: "CannotConnectToALS",
                    _0: e$1._0
                  }
                };
        }
      }
      await Connection__Download__GitHub$AgdaModeVscode.Nd.Fs.unlink(tempFilePath);
      var genericError = {
        message: "Downloaded file is not a ZIP file. The URL may require authentication or may not be a direct download link."
      };
      return {
              TAG: "Error",
              _0: {
                TAG: "CannotDownloadFromURL",
                _0: {
                  TAG: "CannotReadFile",
                  _0: genericError
                }
              }
            };
    }
    var error$1 = error._0;
    var convertedError;
    if (typeof error$1 !== "object") {
      convertedError = {
        TAG: "CannotReadFile",
        _0: {
          message: "No redirect location"
        }
      };
    } else {
      switch (error$1.TAG) {
        case "Timeout" :
            convertedError = {
              TAG: "CannotReadFile",
              _0: {
                message: "Timeout after " + String(error$1._0) + "ms"
              }
            };
            break;
        case "JsonParseError" :
            convertedError = {
              TAG: "CannotReadFile",
              _0: {
                message: "JSON parse error: " + error$1._0
              }
            };
            break;
        case "ServerResponseError" :
        case "CannotWriteFile" :
            convertedError = {
              TAG: "CannotReadFile",
              _0: error$1._0
            };
            break;
        
      }
    }
    return {
            TAG: "Error",
            _0: {
              TAG: "CannotDownloadFromURL",
              _0: convertedError
            }
          };
  }
  catch (raw_obj){
    var obj = Caml_js_exceptions.internalToOCamlException(raw_obj);
    if (obj.RE_EXN_ID === Js_exn.$$Error) {
      return {
              TAG: "Error",
              _0: {
                TAG: "CannotDownloadFromURL",
                _0: {
                  TAG: "CannotReadFile",
                  _0: obj._1
                }
              }
            };
    }
    var genericError$1 = {
      message: "Invalid URL"
    };
    return {
            TAG: "Error",
            _0: {
              TAG: "CannotDownloadFromURL",
              _0: {
                TAG: "CannotReadFile",
                _0: genericError$1
              }
            }
          };
  }
}

exports.$$Error = $$Error;
exports.makeRepo = makeRepo;
exports.getReleaseManifest = getReleaseManifest;
exports.download = download;
exports.downloadFromURL = downloadFromURL;
/* url Not a pure module */
