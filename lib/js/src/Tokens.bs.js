// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Vscode = require("vscode");
var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Core__List = require("@rescript/core/lib/js/src/Core__List.bs.js");
var FastCheck = require("fast-check");
var Core__Array = require("@rescript/core/lib/js/src/Core__Array.bs.js");
var PervasivesU = require("rescript/lib/js/pervasivesU.js");
var Core__Option = require("@rescript/core/lib/js/src/Core__Option.bs.js");
var Agda$AgdaModeVscode = require("./Agda.bs.js");
var Util$AgdaModeVscode = require("./Util/Util.bs.js");
var Json$JsonCombinators = require("@glennsl/rescript-json-combinators/lib/js/src/Json.bs.js");
var Editor$AgdaModeVscode = require("./Editor.bs.js");
var Parser$AgdaModeVscode = require("./Parser/Parser.bs.js");
var AVLTree$AgdaModeVscode = require("./Util/AVLTree.bs.js");
var Node__Fs$AgdaModeVscode = require("./Node/Node__Fs.bs.js");
var Json_Decode$JsonCombinators = require("@glennsl/rescript-json-combinators/lib/js/src/Json_Decode.bs.js");
var BinarySearchTree = require("@datastructures-js/binary-search-tree");
var Highlighting__AgdaAspect$AgdaModeVscode = require("./Highlighting/Highlighting__AgdaAspect.bs.js");
var Highlighting__Decoration$AgdaModeVscode = require("./Highlighting/Highlighting__Decoration.bs.js");
var Highlighting__SemanticToken$AgdaModeVscode = require("./Highlighting/Highlighting__SemanticToken.bs.js");

function toString(self) {
  var match = self.source;
  return "(" + String(self.start) + ", " + String(self.end_) + ") " + Util$AgdaModeVscode.Pretty.list(Core__List.fromArray(self.aspects.map(Highlighting__AgdaAspect$AgdaModeVscode.toString))) + (
          match !== undefined ? " [src: " + String(match[1]) + "]" : ""
        );
}

function parse(x) {
  if (x.TAG === "A") {
    return ;
  }
  var xs = x._0;
  var len = xs.length;
  if (len >= 7) {
    return ;
  }
  switch (len) {
    case 3 :
        var start$p = xs[0];
        if (start$p.TAG !== "A") {
          return ;
        }
        var end_$p = xs[1];
        if (end_$p.TAG !== "A") {
          return ;
        }
        var end_$p$1 = end_$p._0;
        var aspects = xs[2];
        return Core__Option.flatMap(PervasivesU.int_of_string_opt(start$p._0), (function (start) {
                      return Core__Option.map(PervasivesU.int_of_string_opt(end_$p$1), (function (end_) {
                                    return {
                                            start: start - 1 | 0,
                                            end_: end_ - 1 | 0,
                                            aspects: Parser$AgdaModeVscode.SExpression.flatten(aspects).map(Highlighting__AgdaAspect$AgdaModeVscode.parse),
                                            isTokenBased: false,
                                            note: undefined,
                                            source: undefined
                                          };
                                  }));
                    }));
    case 4 :
        var start$p$1 = xs[0];
        if (start$p$1.TAG !== "A") {
          return ;
        }
        var end_$p$2 = xs[1];
        if (end_$p$2.TAG !== "A") {
          return ;
        }
        var end_$p$3 = end_$p$2._0;
        var aspects$1 = xs[2];
        return Core__Option.flatMap(PervasivesU.int_of_string_opt(start$p$1._0), (function (start) {
                      return Core__Option.map(PervasivesU.int_of_string_opt(end_$p$3), (function (end_) {
                                    return {
                                            start: start - 1 | 0,
                                            end_: end_ - 1 | 0,
                                            aspects: Parser$AgdaModeVscode.SExpression.flatten(aspects$1).map(Highlighting__AgdaAspect$AgdaModeVscode.parse),
                                            isTokenBased: false,
                                            note: undefined,
                                            source: undefined
                                          };
                                  }));
                    }));
    case 0 :
    case 1 :
    case 2 :
    case 5 :
        return ;
    case 6 :
        var start$p$2 = xs[0];
        if (start$p$2.TAG !== "A") {
          return ;
        }
        var end_$p$4 = xs[1];
        if (end_$p$4.TAG !== "A") {
          return ;
        }
        var end_$p$5 = end_$p$4._0;
        var aspects$2 = xs[2];
        var match = xs[5];
        if (match.TAG === "A") {
          return ;
        }
        var match$1 = match._0;
        if (match$1.length !== 3) {
          return ;
        }
        var filepath = match$1[0];
        if (filepath.TAG !== "A") {
          return ;
        }
        var filepath$1 = filepath._0;
        var index$p = match$1[2];
        if (index$p.TAG !== "A") {
          return ;
        }
        var index$p$1 = index$p._0;
        return Core__Option.flatMap(PervasivesU.int_of_string_opt(start$p$2._0), (function (start) {
                      return Core__Option.flatMap(PervasivesU.int_of_string_opt(end_$p$5), (function (end_) {
                                    return Core__Option.map(PervasivesU.int_of_string_opt(index$p$1), (function (index) {
                                                  return {
                                                          start: start - 1 | 0,
                                                          end_: end_ - 1 | 0,
                                                          aspects: Parser$AgdaModeVscode.SExpression.flatten(aspects$2).map(Highlighting__AgdaAspect$AgdaModeVscode.parse),
                                                          isTokenBased: false,
                                                          note: undefined,
                                                          source: [
                                                            filepath$1,
                                                            index
                                                          ]
                                                        };
                                                }));
                                  }));
                    }));
    
  }
}

function parseDirectHighlightings(tokens) {
  return Core__Array.filterMap(tokens.slice(2).map(parse), (function (x) {
                return x;
              }));
}

var decodeToken = Json_Decode$JsonCombinators.map(Util$AgdaModeVscode.Decode.tuple6(Json_Decode$JsonCombinators.$$int, Json_Decode$JsonCombinators.$$int, Json_Decode$JsonCombinators.array(Json_Decode$JsonCombinators.string), Json_Decode$JsonCombinators.bool, Json_Decode$JsonCombinators.option(Json_Decode$JsonCombinators.string), Json_Decode$JsonCombinators.option(Json_Decode$JsonCombinators.pair(Json_Decode$JsonCombinators.string, Json_Decode$JsonCombinators.$$int))), (function (param) {
        return {
                start: param[0] - 1 | 0,
                end_: param[1] - 1 | 0,
                aspects: param[2].map(Highlighting__AgdaAspect$AgdaModeVscode.parse),
                isTokenBased: param[3],
                note: param[4],
                source: param[5]
              };
      }));

var decodeResponseHighlightingInfoDirect = Json_Decode$JsonCombinators.map(Json_Decode$JsonCombinators.pair(Json_Decode$JsonCombinators.bool, Json_Decode$JsonCombinators.array(decodeToken)), (function (param) {
        return [
                param[0],
                param[1]
              ];
      }));

var Token = {
  toString: toString,
  parse: parse,
  parseDirectHighlightings: parseDirectHighlightings,
  decodeToken: decodeToken,
  decodeResponseHighlightingInfoDirect: decodeResponseHighlightingInfoDirect
};

function fromTextDocumentContentChangeEvent($$event) {
  return {
          offset: $$event.rangeOffset,
          removed: $$event.rangeLength,
          inserted: $$event.text.length
        };
}

function delta(x) {
  return x.inserted - x.removed | 0;
}

function totalDelta(xs) {
  return Core__Array.reduce(xs, 0, (function (acc, x) {
                return acc + delta(x) | 0;
              }));
}

function arbitrary(after) {
  return FastCheck.tuple(FastCheck.integer(after, after + 10 | 0), FastCheck.integer(0, 10), FastCheck.integer(0, 10)).map(function (param) {
              return {
                      offset: param[0],
                      removed: param[1],
                      inserted: param[2]
                    };
            });
}

function arbitraryBatch() {
  var aux = function (after, size) {
    if (size === 0) {
      return FastCheck.constant([]);
    } else {
      return arbitrary(after).chain(function (change) {
                  return aux((change.offset + change.inserted | 0) - change.removed | 0, size - 1 | 0).map(function (changes) {
                              return Belt_Array.concatMany([
                                          [change],
                                          changes
                                        ]);
                            });
                });
    }
  };
  return FastCheck.integer(0, 10).chain(function (size) {
              return aux(0, size);
            });
}

var Change = {
  fromTextDocumentContentChangeEvent: fromTextDocumentContentChangeEvent,
  delta: delta,
  totalDelta: totalDelta,
  arbitrary: arbitrary,
  arbitraryBatch: arbitraryBatch
};

function deltaToString(delta) {
  if (delta > 0) {
    return "━ +" + String(delta) + " ━";
  } else if (delta < 0) {
    return "━ -" + String(delta) + " ━";
  } else {
    return "━━━━━";
  }
}

function toString$1(xs) {
  if (typeof xs !== "object") {
    return "━━┫";
  }
  var tail = xs._3;
  var delta = xs._2;
  var end = xs._1;
  var start = xs._0;
  if (start === end) {
    return "━━┫" + String(end) + " ━" + deltaToString(delta) + toString$1(tail);
  } else {
    return "━━┫" + String(start) + "     ┃" + String(end) + " ━━" + deltaToString(delta) + toString$1(tail);
  }
}

function totalDelta$1(xs) {
  if (typeof xs !== "object") {
    return 0;
  } else {
    return ((xs._0 - xs._1 | 0) + xs._2 | 0) + totalDelta$1(xs._3) | 0;
  }
}

var Tail = {
  toString: toString$1,
  totalDelta: totalDelta$1
};

function toString$2(xs) {
  var end = xs._0;
  if (end !== 0) {
    return "┣━━━━━┫" + String(end) + " ━━" + deltaToString(xs._1) + toString$1(xs._2);
  } else {
    return "┣━" + deltaToString(xs._1) + toString$1(xs._2);
  }
}

function totalDelta$2(xs) {
  return ((-xs._0 | 0) + xs._1 | 0) + totalDelta$1(xs._2) | 0;
}

var Intervals = {
  deltaToString: deltaToString,
  Tail: Tail,
  toString: toString$2,
  totalDelta: totalDelta$2
};

function toFilepath(format) {
  return format._0;
}

async function readAndParse(format) {
  try {
    var content = await Node__Fs$AgdaModeVscode.readFile(format._0);
    if (format.TAG === "Emacs") {
      var match = Parser$AgdaModeVscode.SExpression.parse(content)[0];
      var tokens;
      if (match !== undefined) {
        if (match.TAG === "Ok") {
          var xs = match._0;
          tokens = xs.TAG === "A" ? [] : xs._0;
        } else {
          tokens = [];
        }
      } else {
        tokens = [];
      }
      var match$1 = tokens[0];
      var removeTokenBasedHighlighting = match$1 !== undefined && match$1.TAG === "A" && match$1._0 === "remove" ? true : false;
      var tokens$1 = Core__Array.filterMap(tokens.slice(1), parse);
      return [
              removeTokenBasedHighlighting,
              tokens$1
            ];
    }
    var exit = 0;
    var json;
    try {
      json = JSON.parse(content);
      exit = 1;
    }
    catch (_e){
      return [
              false,
              []
            ];
    }
    if (exit === 1) {
      var _err = Json$JsonCombinators.decode(json, decodeResponseHighlightingInfoDirect);
      if (_err.TAG === "Ok") {
        var match$2 = _err._0;
        return [
                match$2[0],
                match$2[1]
              ];
      }
      console.log("Error in decoding JSON: " + _err._0);
      return [
              false,
              []
            ];
    }
    
  }
  catch (exn){
    return [
            false,
            []
          ];
  }
}

function toString$3(self) {
  var tempFiles = self.tempFiles.length === 0 ? "" : "\n    " + self.tempFiles.map(toFilepath).join("\n    ");
  var tokens = AVLTree$AgdaModeVscode.toArray(self.tokens).map(function (param) {
          return toString(param[0]) + " " + Editor$AgdaModeVscode.$$Range.toString(param[1]);
        }).join("\n    ");
  return "Tokens:\n  tempFiles (" + String(self.tempFiles.length) + ") " + tempFiles + "\n  tokens:\n    " + tokens;
}

function make() {
  return {
          tempFiles: [],
          tokens: new BinarySearchTree.BinarySearchTree()
        };
}

function insert(self, editor, tokens) {
  tokens.forEach(function (info) {
        var $$document = editor.document;
        var text = Editor$AgdaModeVscode.$$Text.getAll($$document);
        var offsetConverter = Agda$AgdaModeVscode.OffsetConverter.make(text);
        var startOffset = Agda$AgdaModeVscode.OffsetConverter.convert(offsetConverter, info.start);
        var existing = AVLTree$AgdaModeVscode.find(self.tokens, startOffset);
        if (existing !== undefined) {
          var old = existing[0];
          self.tokens.remove(startOffset);
          var newAspects = Caml_obj.equal(old.aspects, info.aspects) ? old.aspects : old.aspects.concat(info.aspects);
          var new_start = old.start;
          var new_end_ = old.end_;
          var new_isTokenBased = old.isTokenBased;
          var new_note = old.note;
          var new_source = old.source;
          var $$new = {
            start: new_start,
            end_: new_end_,
            aspects: newAspects,
            isTokenBased: new_isTokenBased,
            note: new_note,
            source: new_source
          };
          self.tokens.insert(startOffset, [
                $$new,
                existing[1]
              ]);
          return ;
        }
        var start = $$document.positionAt(startOffset);
        var end_ = $$document.positionAt(Agda$AgdaModeVscode.OffsetConverter.convert(offsetConverter, info.end_));
        var range = new Vscode.Range(start, end_);
        self.tokens.insert(startOffset, [
              info,
              range
            ]);
      });
}

function addEmacsFilePath(self, filepath) {
  self.tempFiles.push({
        TAG: "Emacs",
        _0: filepath,
        [Symbol.for("name")]: "Emacs"
      });
}

function addJSONFilePath(self, filepath) {
  self.tempFiles.push({
        TAG: "JSON",
        _0: filepath,
        [Symbol.for("name")]: "JSON"
      });
}

async function readTempFiles(self, editor) {
  var xs = await Promise.all(self.tempFiles.map(readAndParse));
  var tokens = xs.map(function (prim) {
          return prim[1];
        }).flat();
  insert(self, editor, tokens);
  self.tempFiles = [];
}

function clear(self) {
  self.tempFiles.forEach(function (format) {
        Fs.unlink(format._0, (function (param) {
                
              }));
      });
  self.tokens = new BinarySearchTree.BinarySearchTree();
}

function toArray(self) {
  return AVLTree$AgdaModeVscode.toArray(self.tokens);
}

function lookupSrcLoc(self, offset) {
  return Core__Option.map(Core__Option.flatMap(AVLTree$AgdaModeVscode.lowerBound(self.tokens, offset), (function (param) {
                    var range = param[1];
                    return Core__Option.map(param[0].source, (function (param) {
                                  return [
                                          range,
                                          param[0],
                                          param[1]
                                        ];
                                }));
                  })), (function (param) {
                var offset = param[2];
                var filepath = param[1];
                var range = param[0];
                return Vscode.workspace.openTextDocument(filepath).then(function ($$document) {
                            var text = Editor$AgdaModeVscode.$$Text.getAll($$document);
                            var offsetConverter = Agda$AgdaModeVscode.OffsetConverter.make(text);
                            var offset$1 = Agda$AgdaModeVscode.OffsetConverter.convert(offsetConverter, offset - 1 | 0);
                            var position = $$document.positionAt(offset$1);
                            return [[
                                      range,
                                      filepath,
                                      position
                                    ]];
                          });
              }));
}

function toDecorationsAndSemanticTokens(tokens, editor) {
  var match = Belt_Array.unzip(Core__Array.filterMap(AVLTree$AgdaModeVscode.toArray(tokens.tokens).map(function (param) {
                  var info = param[0];
                  var ranges = Highlighting__SemanticToken$AgdaModeVscode.Module.SingleLineRange.splitRange(editor.document, param[1]);
                  return ranges.map(function (range) {
                              return [
                                      info.aspects,
                                      range
                                    ];
                            });
                }).flat(), (function (param) {
              var range = param[1];
              var match = Belt_Array.unzip(param[0].map(Highlighting__AgdaAspect$AgdaModeVscode.toTokenTypeAndModifiersAndDecoration));
              var match$1 = Belt_Array.unzip(match[0]);
              var tokenTypes = Core__Array.filterMap(match$1[0], (function (x) {
                      return x;
                    }));
              var tokenModifiers = match$1[1].flat();
              var decorations = Core__Array.filterMap(match[1], (function (x) {
                      return Core__Option.map(x, (function (x) {
                                    return [
                                            x,
                                            Highlighting__SemanticToken$AgdaModeVscode.Module.SingleLineRange.toVsCodeRange(range)
                                          ];
                                  }));
                    }));
              var semanticToken = Core__Option.map(tokenTypes[0], (function (tokenType) {
                      return {
                              range: range,
                              type_: tokenType,
                              modifiers: tokenModifiers
                            };
                    }));
              return [
                      semanticToken,
                      decorations
                    ];
            })));
  var semanticTokens = Core__Array.filterMap(match[0], (function (x) {
          return x;
        }));
  var decorations = Highlighting__Decoration$AgdaModeVscode.toVSCodeDecorations(match[1].flat(), editor);
  return [
          decorations,
          semanticTokens
        ];
}

function toDecorations(self, editor) {
  var aspects = AVLTree$AgdaModeVscode.toArray(self.tokens).map(function (param) {
          var range = param[1];
          return param[0].aspects.map(function (aspect) {
                      return [
                              aspect,
                              range
                            ];
                    });
        }).flat();
  return Highlighting__Decoration$AgdaModeVscode.toVSCodeDecorations(Core__Array.filterMap(aspects, (function (param) {
                    var range = param[1];
                    return Core__Option.map(Highlighting__AgdaAspect$AgdaModeVscode.toDecoration(param[0]), (function (x) {
                                  return [
                                          x,
                                          range
                                        ];
                                }));
                  })), editor);
}

var Module = {
  toString: toString$3,
  make: make,
  addEmacsFilePath: addEmacsFilePath,
  addJSONFilePath: addJSONFilePath,
  readTempFiles: readTempFiles,
  insert: insert,
  clear: clear,
  toArray: toArray,
  lookupSrcLoc: lookupSrcLoc,
  toDecorations: toDecorations,
  toDecorationsAndSemanticTokens: toDecorationsAndSemanticTokens
};

var Aspect;

exports.Aspect = Aspect;
exports.Token = Token;
exports.Change = Change;
exports.Intervals = Intervals;
exports.Module = Module;
exports.toString = toString$3;
exports.make = make;
exports.addEmacsFilePath = addEmacsFilePath;
exports.addJSONFilePath = addJSONFilePath;
exports.readTempFiles = readTempFiles;
exports.insert = insert;
exports.clear = clear;
exports.toArray = toArray;
exports.lookupSrcLoc = lookupSrcLoc;
exports.toDecorations = toDecorations;
exports.toDecorationsAndSemanticTokens = toDecorationsAndSemanticTokens;
/* decodeToken Not a pure module */
