// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Caml = require("rescript/lib/js/caml.js");
var Js_exn = require("rescript/lib/js/js_exn.js");
var Vscode = require("vscode");
var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Core__List = require("@rescript/core/lib/js/src/Core__List.bs.js");
var FastCheck = require("fast-check");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Core__Array = require("@rescript/core/lib/js/src/Core__Array.bs.js");
var PervasivesU = require("rescript/lib/js/pervasivesU.js");
var Core__Option = require("@rescript/core/lib/js/src/Core__Option.bs.js");
var Agda$AgdaModeVscode = require("./Agda.bs.js");
var Util$AgdaModeVscode = require("./Util/Util.bs.js");
var Json$JsonCombinators = require("@glennsl/rescript-json-combinators/lib/js/src/Json.bs.js");
var Editor$AgdaModeVscode = require("./Editor.bs.js");
var Parser$AgdaModeVscode = require("./Parser/Parser.bs.js");
var AVLTree$AgdaModeVscode = require("./Util/AVLTree.bs.js");
var Node__Fs$AgdaModeVscode = require("./Node/Node__Fs.bs.js");
var Resource$AgdaModeVscode = require("./Resource.bs.js");
var Json_Decode$JsonCombinators = require("@glennsl/rescript-json-combinators/lib/js/src/Json_Decode.bs.js");
var BinarySearchTree = require("@datastructures-js/binary-search-tree");
var Highlighting__AgdaAspect$AgdaModeVscode = require("./Highlighting/Highlighting__AgdaAspect.bs.js");
var Highlighting__Decoration$AgdaModeVscode = require("./Highlighting/Highlighting__Decoration.bs.js");
var Highlighting__SemanticToken$AgdaModeVscode = require("./Highlighting/Highlighting__SemanticToken.bs.js");

function toString(self) {
  var match = self.source;
  return "(" + String(self.start) + ", " + String(self.end) + ") " + Util$AgdaModeVscode.Pretty.list(Core__List.fromArray(self.aspects.map(Highlighting__AgdaAspect$AgdaModeVscode.toString))) + (
          match !== undefined ? " [src: " + String(match[1]) + "]" : ""
        );
}

function parse(x) {
  if (x.TAG === "A") {
    return ;
  }
  var xs = x._0;
  var len = xs.length;
  if (len >= 7) {
    return ;
  }
  switch (len) {
    case 3 :
        var start$p = xs[0];
        if (start$p.TAG !== "A") {
          return ;
        }
        var end$p = xs[1];
        if (end$p.TAG !== "A") {
          return ;
        }
        var end$p$1 = end$p._0;
        var aspects = xs[2];
        return Core__Option.flatMap(PervasivesU.int_of_string_opt(start$p._0), (function (start) {
                      return Core__Option.map(PervasivesU.int_of_string_opt(end$p$1), (function (end) {
                                    return {
                                            start: start - 1 | 0,
                                            end: end - 1 | 0,
                                            aspects: Parser$AgdaModeVscode.SExpression.flatten(aspects).map(Highlighting__AgdaAspect$AgdaModeVscode.parse),
                                            isTokenBased: false,
                                            note: undefined,
                                            source: undefined
                                          };
                                  }));
                    }));
    case 4 :
        var start$p$1 = xs[0];
        if (start$p$1.TAG !== "A") {
          return ;
        }
        var end$p$2 = xs[1];
        if (end$p$2.TAG !== "A") {
          return ;
        }
        var end$p$3 = end$p$2._0;
        var aspects$1 = xs[2];
        return Core__Option.flatMap(PervasivesU.int_of_string_opt(start$p$1._0), (function (start) {
                      return Core__Option.map(PervasivesU.int_of_string_opt(end$p$3), (function (end) {
                                    return {
                                            start: start - 1 | 0,
                                            end: end - 1 | 0,
                                            aspects: Parser$AgdaModeVscode.SExpression.flatten(aspects$1).map(Highlighting__AgdaAspect$AgdaModeVscode.parse),
                                            isTokenBased: false,
                                            note: undefined,
                                            source: undefined
                                          };
                                  }));
                    }));
    case 0 :
    case 1 :
    case 2 :
    case 5 :
        return ;
    case 6 :
        var start$p$2 = xs[0];
        if (start$p$2.TAG !== "A") {
          return ;
        }
        var end$p$4 = xs[1];
        if (end$p$4.TAG !== "A") {
          return ;
        }
        var end$p$5 = end$p$4._0;
        var aspects$2 = xs[2];
        var match = xs[5];
        if (match.TAG === "A") {
          return ;
        }
        var match$1 = match._0;
        if (match$1.length !== 3) {
          return ;
        }
        var filepath = match$1[0];
        if (filepath.TAG !== "A") {
          return ;
        }
        var filepath$1 = filepath._0;
        var index$p = match$1[2];
        if (index$p.TAG !== "A") {
          return ;
        }
        var index$p$1 = index$p._0;
        return Core__Option.flatMap(PervasivesU.int_of_string_opt(start$p$2._0), (function (start) {
                      return Core__Option.flatMap(PervasivesU.int_of_string_opt(end$p$5), (function (end) {
                                    return Core__Option.map(PervasivesU.int_of_string_opt(index$p$1), (function (index) {
                                                  return {
                                                          start: start - 1 | 0,
                                                          end: end - 1 | 0,
                                                          aspects: Parser$AgdaModeVscode.SExpression.flatten(aspects$2).map(Highlighting__AgdaAspect$AgdaModeVscode.parse),
                                                          isTokenBased: false,
                                                          note: undefined,
                                                          source: [
                                                            filepath$1,
                                                            index
                                                          ]
                                                        };
                                                }));
                                  }));
                    }));
    
  }
}

function parseDirectHighlightings(tokens) {
  return Core__Array.filterMap(tokens.slice(2).map(parse), (function (x) {
                return x;
              }));
}

var decodeToken = Json_Decode$JsonCombinators.map(Util$AgdaModeVscode.Decode.tuple6(Json_Decode$JsonCombinators.$$int, Json_Decode$JsonCombinators.$$int, Json_Decode$JsonCombinators.array(Json_Decode$JsonCombinators.string), Json_Decode$JsonCombinators.bool, Json_Decode$JsonCombinators.option(Json_Decode$JsonCombinators.string), Json_Decode$JsonCombinators.option(Json_Decode$JsonCombinators.pair(Json_Decode$JsonCombinators.string, Json_Decode$JsonCombinators.$$int))), (function (param) {
        return {
                start: param[0] - 1 | 0,
                end: param[1] - 1 | 0,
                aspects: param[2].map(Highlighting__AgdaAspect$AgdaModeVscode.parse),
                isTokenBased: param[3],
                note: param[4],
                source: param[5]
              };
      }));

var decodeResponseHighlightingInfoDirect = Json_Decode$JsonCombinators.map(Json_Decode$JsonCombinators.pair(Json_Decode$JsonCombinators.bool, Json_Decode$JsonCombinators.array(decodeToken)), (function (param) {
        return [
                param[0],
                param[1]
              ];
      }));

var Token = {
  toString: toString,
  parse: parse,
  parseDirectHighlightings: parseDirectHighlightings,
  decodeToken: decodeToken,
  decodeResponseHighlightingInfoDirect: decodeResponseHighlightingInfoDirect
};

function toString$1(self) {
  return "-" + String(self.removed) + " +" + String(self.inserted) + " @ " + String(self.offset);
}

function fromTextDocumentContentChangeEvent($$event) {
  return {
          offset: $$event.rangeOffset,
          removed: $$event.rangeLength,
          inserted: $$event.text.length
        };
}

function delta(x) {
  return x.inserted - x.removed | 0;
}

function totalDelta(xs) {
  return Core__Array.reduce(xs, 0, (function (acc, x) {
                return acc + delta(x) | 0;
              }));
}

function isUseless(x) {
  if (x.removed === 0) {
    return x.inserted === 0;
  } else {
    return false;
  }
}

function removedInterval(x) {
  if (x.removed === 0) {
    return ;
  } else {
    return [
            x.offset,
            x.offset + x.removed | 0
          ];
  }
}

function areValid(xs) {
  return Core__Array.reduce(xs, [
                true,
                undefined
              ], (function (param, x) {
                  var prevEnd = param[1];
                  var end = x.offset + x.removed | 0;
                  if (prevEnd !== undefined) {
                    if (prevEnd > x.offset) {
                      return [
                              false,
                              end
                            ];
                    } else {
                      return [
                              param[0],
                              end
                            ];
                    }
                  } else {
                    return [
                            true,
                            end
                          ];
                  }
                }))[0];
}

function translate(x, delta) {
  return {
          offset: x.offset + delta | 0,
          removed: x.removed,
          inserted: x.inserted
        };
}

function arbitrary(after, kindOpt) {
  var kind = kindOpt !== undefined ? kindOpt : "Mixed";
  return FastCheck.integer(after, after + 10 | 0).chain(function (offset) {
              return FastCheck.tuple(FastCheck.integer(0, offset), FastCheck.integer(0, 10)).map(function (param) {
                          var inserted = param[1];
                          var removed = param[0];
                          switch (kind) {
                            case "RemovalOnly" :
                                return {
                                        offset: offset,
                                        removed: removed,
                                        inserted: 0
                                      };
                            case "InsertionOnly" :
                                return {
                                        offset: offset,
                                        removed: 0,
                                        inserted: inserted
                                      };
                            case "Mixed" :
                                return {
                                        offset: offset,
                                        removed: removed,
                                        inserted: inserted
                                      };
                            
                          }
                        });
            });
}

function arbitraryBatch(batchSize, kindOpt) {
  var kind = kindOpt !== undefined ? kindOpt : "Mixed";
  var aux = function (after, size) {
    if (size === 0) {
      return FastCheck.constant([]);
    } else {
      return arbitrary(after, kind).chain(function (change) {
                  return aux((change.offset + change.removed | 0) + 1 | 0, size - 1 | 0).map(function (changes) {
                              return Belt_Array.concatMany([
                                          [change],
                                          changes
                                        ]);
                            });
                });
    }
  };
  if (batchSize !== undefined) {
    return aux(0, batchSize);
  } else {
    return FastCheck.integer(0, 10).chain(function (size) {
                return aux(0, size);
              });
  }
}

var Change = {
  toString: toString$1,
  fromTextDocumentContentChangeEvent: fromTextDocumentContentChangeEvent,
  delta: delta,
  totalDelta: totalDelta,
  isUseless: isUseless,
  removedInterval: removedInterval,
  areValid: areValid,
  translate: translate,
  arbitrary: arbitrary,
  arbitraryBatch: arbitraryBatch
};

function deltaToString(delta) {
  if (delta > 0) {
    return " +" + String(delta) + " ";
  } else if (delta < 0) {
    return " " + String(delta) + " ";
  } else {
    return " +0 ";
  }
}

function toString$2(xs) {
  if (typeof xs !== "object") {
    return "EOF";
  }
  var tail = xs._3;
  var delta = xs._2;
  var end = xs._1;
  var start = xs._0;
  if (start === end) {
    return String(start) + "┃" + String(end) + deltaToString(delta) + (
            tail === "EOF" ? "" : toString$2(tail)
          );
  } else {
    return String(start) + "┣━━┫" + String(end) + deltaToString(delta) + (
            tail === "EOF" ? "" : toString$2(tail)
          );
  }
}

function hasError(xs) {
  var _prevEnd = 0;
  var _before = 0;
  var _xs = xs;
  while(true) {
    var xs$1 = _xs;
    var before = _before;
    var prevEnd = _prevEnd;
    if (typeof xs$1 !== "object") {
      return ;
    }
    var after = xs$1._2;
    var end = xs$1._1;
    var start = xs$1._0;
    var removed = end - start | 0;
    var inserted = (after - before | 0) + removed | 0;
    if (start < prevEnd) {
      return "Overlapping";
    }
    if (start > end) {
      return "ReversedOrder";
    }
    if (inserted < 0) {
      return "NegativeInsertion";
    }
    if (start === end && inserted === 0) {
      return "Empty";
    }
    _xs = xs$1._3;
    _before = after;
    _prevEnd = end;
    continue ;
  };
}

function debugIsValid(xs) {
  var match = hasError(xs);
  var aux;
  if (match !== undefined) {
    switch (match) {
      case "Overlapping" :
          aux = "Has overlapping intervals";
          break;
      case "ReversedOrder" :
          aux = "Has reversed order intervals";
          break;
      case "NegativeInsertion" :
          aux = "Has negative insertion";
          break;
      case "Empty" :
          aux = "Has empty intervals";
          break;
      
    }
  } else {
    aux = undefined;
  }
  if (aux !== undefined) {
    console.log("Intervals: " + toString$2(xs));
    console.log("Error: " + aux);
    return ;
  }
  
}

function totalDelta$1(_xs) {
  while(true) {
    var xs = _xs;
    if (typeof xs !== "object") {
      return 0;
    }
    var tail = xs._3;
    if (typeof tail !== "object") {
      return xs._2;
    }
    _xs = tail;
    continue ;
  };
}

function removedIntervals(_xs) {
  while(true) {
    var xs = _xs;
    if (typeof xs !== "object") {
      return [];
    }
    var tail = xs._3;
    var end = xs._1;
    var start = xs._0;
    if (start !== end) {
      return Belt_Array.concatMany([
                  [[
                      start,
                      end
                    ]],
                  removedIntervals(tail)
                ]);
    }
    _xs = tail;
    continue ;
  };
}

function isValidWRTChanges(xs, changes) {
  var sameTotalDelta = totalDelta$1(xs) === totalDelta(changes);
  var sameRemovedIntervals = Caml_obj.equal(removedIntervals(xs), Core__Array.filterMap(changes.map(removedInterval), (function (x) {
              return x;
            })));
  if (hasError(xs) === undefined && sameTotalDelta) {
    return sameRemovedIntervals;
  } else {
    return false;
  }
}

function isValidWRTChangeBatches(xs, batches) {
  var sameTotalDelta = totalDelta$1(xs) === Core__Array.reduce(batches, 0, (function (acc, changes) {
          return acc + totalDelta(changes) | 0;
        }));
  if (hasError(xs) === undefined) {
    return sameTotalDelta;
  } else {
    return false;
  }
}

function toString$3(x) {
  switch (x.TAG) {
    case "Before" :
        return "Before " + String(x._0);
    case "InInsertion" :
        return "InInsertion " + String(x._0);
    case "After" :
        return "After " + String(x._0);
    
  }
}

function calculateOriginalOffset(deltaBefore, start, end, deltaAfter, x) {
  if (x >= (end + deltaAfter | 0)) {
    return {
            TAG: "After",
            _0: x - deltaAfter | 0,
            [Symbol.for("name")]: "After"
          };
  } else if (x <= (deltaBefore + start | 0)) {
    return {
            TAG: "Before",
            _0: x - deltaBefore | 0,
            [Symbol.for("name")]: "Before"
          };
  } else {
    return {
            TAG: "InInsertion",
            _0: x - deltaBefore | 0,
            [Symbol.for("name")]: "InInsertion"
          };
  }
}

var Source = {
  toString: toString$3,
  calculateOriginalOffset: calculateOriginalOffset
};

function printInterval(deltaBefore, start, end, deltaAfter) {
  console.log("interval delta before: " + String(deltaBefore));
  console.log("         delta after: " + String(deltaAfter));
  console.log("         start: " + String(start));
  console.log("         end: " + String(end));
  console.log("         removed: " + String(end - start | 0));
  console.log("         inserted: " + String(((deltaAfter - deltaBefore | 0) + end | 0) - start | 0));
}

function addInterval(deltaBefore, start, end, deltaAfter, xs) {
  if (start === end && deltaBefore === deltaAfter) {
    return xs;
  } else {
    return {
            TAG: "Replace",
            _0: start,
            _1: end,
            _2: deltaAfter,
            _3: xs,
            [Symbol.for("name")]: "Replace"
          };
  }
}

function applyChangeAux(_xs, deltaBefore, translation, _changes) {
  while(true) {
    var changes = _changes;
    var xs = _xs;
    if (changes) {
      var changes$1 = changes.tl;
      var change = changes.hd;
      if (typeof xs !== "object") {
        var deltaAfter = deltaBefore + delta(change) | 0;
        return addInterval(deltaBefore, change.offset - deltaBefore | 0, (change.offset + change.removed | 0) - deltaBefore | 0, deltaAfter, applyChangeAux("EOF", deltaAfter, translation, changes$1));
      }
      var tail = xs._3;
      var end = xs._1;
      var start = xs._0;
      var deltaAfter$1 = xs._2 + translation | 0;
      var changeRemovalStart = calculateOriginalOffset(deltaBefore, start, end, deltaAfter$1, change.offset);
      var changeRemovalEnd = calculateOriginalOffset(deltaBefore, start, end, deltaAfter$1, change.offset + change.removed | 0);
      var exit = 0;
      switch (changeRemovalEnd.TAG) {
        case "InInsertion" :
            var changeEnd = changeRemovalEnd._0;
            if (end >= changeEnd) {
              _changes = {
                hd: change,
                tl: changes$1
              };
              _xs = {
                TAG: "Replace",
                _0: start,
                _1: changeEnd,
                _2: deltaBefore - translation | 0,
                _3: {
                  TAG: "Replace",
                  _0: changeEnd,
                  _1: end,
                  _2: deltaAfter$1 - translation | 0,
                  _3: tail,
                  [Symbol.for("name")]: "Replace"
                },
                [Symbol.for("name")]: "Replace"
              };
              continue ;
            }
            var part1Delta = changeEnd - end | 0;
            _changes = {
              hd: change,
              tl: changes$1
            };
            _xs = {
              TAG: "Replace",
              _0: start,
              _1: end,
              _2: (deltaBefore + part1Delta | 0) - translation | 0,
              _3: {
                TAG: "Replace",
                _0: end,
                _1: end,
                _2: deltaAfter$1 - translation | 0,
                _3: tail,
                [Symbol.for("name")]: "Replace"
              },
              [Symbol.for("name")]: "Replace"
            };
            continue ;
        case "Before" :
        case "After" :
            exit = 2;
            break;
        
      }
      if (exit === 2) {
        switch (changeRemovalStart.TAG) {
          case "Before" :
              var changeStart = changeRemovalStart._0;
              if (changeRemovalEnd.TAG === "Before") {
                var delta$1 = delta(change);
                return addInterval(deltaBefore, changeStart, changeRemovalEnd._0, deltaBefore + delta$1 | 0, applyChangeAux(xs, deltaBefore + delta$1 | 0, translation + delta$1 | 0, changes$1));
              }
              var delta$2 = ((changeStart - end | 0) + deltaBefore | 0) - deltaAfter$1 | 0;
              var change$p_offset = (end + deltaAfter$1 | 0) + delta$2 | 0;
              var change$p_removed = change.removed + delta$2 | 0;
              var change$p_inserted = change.inserted;
              var change$p = {
                offset: change$p_offset,
                removed: change$p_removed,
                inserted: change$p_inserted
              };
              return addInterval(deltaBefore, changeStart, end, deltaAfter$1 + delta$2 | 0, applyChangeAux(tail, deltaAfter$1 + delta$2 | 0, translation + delta$2 | 0, {
                              hd: change$p,
                              tl: changes$1
                            }));
          case "InInsertion" :
              if (changeRemovalEnd.TAG !== "Before") {
                var delta$3 = (changeRemovalEnd._0 - end | 0) - change.removed | 0;
                var change$p_offset$1 = (end + deltaAfter$1 | 0) + delta$3 | 0;
                var change$p_removed$1 = change.removed + delta$3 | 0;
                var change$p_inserted$1 = change.inserted;
                var change$p$1 = {
                  offset: change$p_offset$1,
                  removed: change$p_removed$1,
                  inserted: change$p_inserted$1
                };
                return addInterval(deltaBefore, start, end, deltaAfter$1 + delta$3 | 0, applyChangeAux(tail, deltaAfter$1 + delta$3 | 0, translation + delta$3 | 0, {
                                hd: change$p$1,
                                tl: changes$1
                              }));
              }
              break;
          case "After" :
              if (changeRemovalEnd.TAG !== "Before") {
                return addInterval(deltaBefore, start, end, deltaAfter$1, applyChangeAux(tail, deltaAfter$1, translation, {
                                hd: change,
                                tl: changes$1
                              }));
              }
              break;
          
        }
      }
      return Js_exn.raiseError("Not a possible case: " + toString$3(changeRemovalStart) + " " + toString$3(changeRemovalEnd));
    }
    if (typeof xs !== "object") {
      return "EOF";
    }
    var deltaAfter$2 = xs._2 + translation | 0;
    return addInterval(deltaBefore, xs._0, xs._1, deltaAfter$2, applyChangeAux(xs._3, deltaAfter$2, translation, /* [] */0));
  };
}

function preprocessChangeBatch(changes) {
  return Core__Array.reduce(changes, [
                0,
                []
              ], (function (param, x) {
                  var delta$1 = param[0];
                  var acc = Belt_Array.concatMany([
                        param[1],
                        [translate(x, delta$1)]
                      ]);
                  return [
                          delta$1 + delta(x) | 0,
                          acc
                        ];
                }))[1];
}

function applyChanges(xs, changes) {
  return applyChangeAux(xs, 0, 0, Core__List.fromArray(preprocessChangeBatch(changes)));
}

var Intervals = {
  deltaToString: deltaToString,
  toString: toString$2,
  empty: "EOF",
  hasError: hasError,
  debugIsValid: debugIsValid,
  totalDelta: totalDelta$1,
  removedIntervals: removedIntervals,
  isValidWRTChanges: isValidWRTChanges,
  isValidWRTChangeBatches: isValidWRTChangeBatches,
  Source: Source,
  printInterval: printInterval,
  addInterval: addInterval,
  applyChangeAux: applyChangeAux,
  preprocessChangeBatch: preprocessChangeBatch,
  applyChanges: applyChanges
};

function toFilepath(format) {
  return format._0;
}

async function readAndParse(format) {
  try {
    var content = await Node__Fs$AgdaModeVscode.readFile(format._0);
    if (format.TAG === "Emacs") {
      var match = Parser$AgdaModeVscode.SExpression.parse(content)[0];
      var tokens;
      if (match !== undefined) {
        if (match.TAG === "Ok") {
          var xs = match._0;
          tokens = xs.TAG === "A" ? [] : xs._0;
        } else {
          tokens = [];
        }
      } else {
        tokens = [];
      }
      var match$1 = tokens[0];
      var removeTokenBasedHighlighting = match$1 !== undefined && match$1.TAG === "A" && match$1._0 === "remove" ? true : false;
      var tokens$1 = Core__Array.filterMap(tokens.slice(1), parse);
      return [
              removeTokenBasedHighlighting,
              tokens$1
            ];
    }
    var exit = 0;
    var json;
    try {
      json = JSON.parse(content);
      exit = 1;
    }
    catch (_e){
      return [
              false,
              []
            ];
    }
    if (exit === 1) {
      var _err = Json$JsonCombinators.decode(json, decodeResponseHighlightingInfoDirect);
      if (_err.TAG === "Ok") {
        var match$2 = _err._0;
        return [
                match$2[0],
                match$2[1]
              ];
      }
      console.log("Error in decoding JSON: " + _err._0);
      return [
              false,
              []
            ];
    }
    
  }
  catch (exn){
    return [
            false,
            []
          ];
  }
}

function toString$4(self) {
  var tempFiles = self.tempFiles.length === 0 ? "" : "\n    " + self.tempFiles.map(toFilepath).join("\n    ");
  var tokens = AVLTree$AgdaModeVscode.toArray(self.agdaTokens).map(function (token) {
          return toString(token) + " " + token.start.toString() + "-" + token.end.toString();
        }).join("\n    ");
  return "Tokens:\n  tempFiles (" + String(self.tempFiles.length) + ") " + tempFiles + "\n  tokens:\n    " + tokens;
}

function make(vscodeTokensResource) {
  return {
          tempFiles: [],
          agdaTokens: new BinarySearchTree.BinarySearchTree(),
          deltas: "EOF",
          vscodeTokens: vscodeTokensResource !== undefined ? Caml_option.valFromOption(vscodeTokensResource) : Resource$AgdaModeVscode.make(),
          holes: new Map(),
          holePositions: Resource$AgdaModeVscode.make()
        };
}

function insertWithVSCodeOffsets(self, token) {
  var existing = AVLTree$AgdaModeVscode.find(self.agdaTokens, token.start);
  if (existing !== undefined) {
    self.agdaTokens.remove(token.start);
    var newAspects = Caml_obj.equal(existing.aspects, token.aspects) ? existing.aspects : existing.aspects.concat(token.aspects);
    var new_start = existing.start;
    var new_end = existing.end;
    var new_isTokenBased = existing.isTokenBased;
    var new_note = existing.note;
    var new_source = existing.source;
    var $$new = {
      start: new_start,
      end: new_end,
      aspects: newAspects,
      isTokenBased: new_isTokenBased,
      note: new_note,
      source: new_source
    };
    self.agdaTokens.insert(token.start, $$new);
    if (token.aspects.some(function (x) {
            return x === "Hole";
          })) {
      self.holes.set(token.start, token);
      return ;
    } else {
      return ;
    }
  }
  self.agdaTokens.insert(token.start, token);
  if (token.aspects.some(function (x) {
          return x === "Hole";
        })) {
    self.holes.set(token.start, token);
    return ;
  }
  
}

function insertTokens(self, editor, tokens) {
  var $$document = editor.document;
  var text = Editor$AgdaModeVscode.$$Text.getAll($$document);
  var offsetConverter = Agda$AgdaModeVscode.OffsetConverter.make(text);
  tokens.forEach(function (token) {
        var start = Agda$AgdaModeVscode.OffsetConverter.convert(offsetConverter, token.start);
        var end = Agda$AgdaModeVscode.OffsetConverter.convert(offsetConverter, token.end);
        insertWithVSCodeOffsets(self, {
              start: start,
              end: end,
              aspects: token.aspects,
              isTokenBased: token.isTokenBased,
              note: token.note,
              source: token.source
            });
      });
}

function addEmacsFilePath(self, filepath) {
  self.tempFiles.push({
        TAG: "Emacs",
        _0: filepath,
        [Symbol.for("name")]: "Emacs"
      });
}

function addJSONFilePath(self, filepath) {
  self.tempFiles.push({
        TAG: "JSON",
        _0: filepath,
        [Symbol.for("name")]: "JSON"
      });
}

async function readTempFiles(self, editor) {
  var xs = await Promise.all(self.tempFiles.map(readAndParse));
  var tokens = xs.map(function (prim) {
          return prim[1];
        }).flat();
  insertTokens(self, editor, tokens);
  self.tempFiles = [];
}

function reset(self) {
  self.tempFiles.forEach(function (format) {
        Fs.unlink(format._0, (function (param) {
                
              }));
      });
  self.agdaTokens = new BinarySearchTree.BinarySearchTree();
  self.deltas = "EOF";
  if (Resource$AgdaModeVscode.isPending(self.vscodeTokens)) {
    return ;
  } else {
    return Resource$AgdaModeVscode.set(self.vscodeTokens, []);
  }
}

function toArray(self) {
  return AVLTree$AgdaModeVscode.toArray(self.agdaTokens);
}

function fromAspects(editor, xs) {
  var match = Belt_Array.unzip(Core__Array.filterMap(xs, (function (param) {
              var range = param[1];
              var match = Belt_Array.unzip(param[0].map(Highlighting__AgdaAspect$AgdaModeVscode.toTokenTypeAndModifiersAndDecoration));
              var match$1 = Belt_Array.unzip(match[0]);
              var tokenTypes = Core__Array.filterMap(match$1[0], (function (x) {
                      return x;
                    }));
              var tokenModifiers = match$1[1].flat();
              var decorations = Core__Array.filterMap(match[1], (function (x) {
                      return Core__Option.map(x, (function (x) {
                                    return [
                                            x,
                                            Highlighting__SemanticToken$AgdaModeVscode.Module.SingleLineRange.toVsCodeRange(range)
                                          ];
                                  }));
                    }));
              var semanticToken = Core__Option.map(tokenTypes[0], (function (tokenType) {
                      return {
                              range: range,
                              type_: tokenType,
                              modifiers: tokenModifiers
                            };
                    }));
              return [
                      semanticToken,
                      decorations
                    ];
            })));
  var semanticTokens = Core__Array.filterMap(match[0], (function (x) {
          return x;
        }));
  var decorations = Highlighting__Decoration$AgdaModeVscode.toVSCodeDecorations(match[1].flat(), editor);
  return [
          decorations,
          semanticTokens
        ];
}

function traverseIntervals(tokens, deltas, f, init) {
  var _acc = init;
  var _i = 0;
  var _intervals = deltas;
  var _deltaBefore = 0;
  while(true) {
    var deltaBefore = _deltaBefore;
    var intervals = _intervals;
    var i = _i;
    var acc = _acc;
    var token = tokens[i];
    if (token === undefined) {
      return acc;
    }
    if (typeof intervals !== "object") {
      _i = i + 1 | 0;
      _acc = f(acc, token, {
            TAG: "Translate",
            _0: deltaBefore,
            [Symbol.for("name")]: "Translate"
          });
      continue ;
    }
    if (token.end < intervals._0) {
      _i = i + 1 | 0;
      _acc = f(acc, token, {
            TAG: "Translate",
            _0: deltaBefore,
            [Symbol.for("name")]: "Translate"
          });
      continue ;
    }
    if (token.start < intervals._1) {
      _i = i + 1 | 0;
      _acc = f(acc, token, "Remove");
      continue ;
    }
    _deltaBefore = intervals._2;
    _intervals = intervals._3;
    continue ;
  };
}

function generateHighlighting(self, editor) {
  var $$document = editor.document;
  var match = traverseIntervals(AVLTree$AgdaModeVscode.toArray(self.agdaTokens), self.deltas, (function (param, token, action) {
          var holePositions = param[1];
          var acc = param[0];
          if (typeof action !== "object") {
            return [
                    acc,
                    holePositions
                  ];
          }
          var delta = action._0;
          var offsetStart = token.start + delta | 0;
          var offsetEnd = token.end + delta | 0;
          var range = new Vscode.Range($$document.positionAt(offsetStart), $$document.positionAt(offsetEnd));
          if (token.aspects.some(function (x) {
                  return x === "Hole";
                })) {
            holePositions.set(offsetStart, offsetEnd);
          }
          var singleLineRanges = Highlighting__SemanticToken$AgdaModeVscode.Module.SingleLineRange.splitRange($$document, range);
          var result = singleLineRanges.map(function (range) {
                return [
                        token.aspects,
                        range
                      ];
              });
          return [
                  Belt_Array.concatMany([
                        acc,
                        result
                      ]),
                  holePositions
                ];
        }), [
        [],
        new Map()
      ]);
  var holePositions = match[1];
  var match$1 = fromAspects(editor, match[0]);
  Resource$AgdaModeVscode.set(self.vscodeTokens, match$1[1]);
  console.log("setting hole positions: " + String(holePositions.size));
  Resource$AgdaModeVscode.set(self.holePositions, holePositions);
}

function applyEdit(self, editor, $$event) {
  var changes = $$event.contentChanges.map(fromTextDocumentContentChangeEvent);
  self.deltas = applyChanges(self.deltas, changes.toReversed());
  generateHighlighting(self, editor);
}

function toOriginalOffset(self, offset) {
  return traverseIntervals(AVLTree$AgdaModeVscode.toArray(self.agdaTokens), self.deltas, (function (acc, token, action) {
                if (typeof action !== "object") {
                  return acc;
                }
                var delta = action._0;
                if (offset >= (token.start + delta | 0) && offset < (token.end + delta | 0)) {
                  return offset - delta | 0;
                } else {
                  return acc;
                }
              }), undefined);
}

function getVSCodeTokens(self) {
  return self.vscodeTokens;
}

function getHolePositionsFromLoad(self) {
  return self.holePositions;
}

function getHoles(self) {
  return self.holes;
}

function getHolesSorted(self) {
  return Array.from(self.holes.values()).toSorted(function (x, y) {
              return Caml.int_compare(x.start, y.start);
            });
}

var Module = {
  toString: toString$4,
  make: make,
  addEmacsFilePath: addEmacsFilePath,
  addJSONFilePath: addJSONFilePath,
  readTempFiles: readTempFiles,
  insertWithVSCodeOffsets: insertWithVSCodeOffsets,
  insertTokens: insertTokens,
  reset: reset,
  toArray: toArray,
  generateHighlighting: generateHighlighting,
  applyEdit: applyEdit,
  toOriginalOffset: toOriginalOffset,
  getVSCodeTokens: getVSCodeTokens,
  getHolePositionsFromLoad: getHolePositionsFromLoad,
  getHoles: getHoles,
  getHolesSorted: getHolesSorted
};

var Aspect;

exports.Aspect = Aspect;
exports.Token = Token;
exports.Change = Change;
exports.Intervals = Intervals;
exports.Module = Module;
exports.toString = toString$4;
exports.make = make;
exports.addEmacsFilePath = addEmacsFilePath;
exports.addJSONFilePath = addJSONFilePath;
exports.readTempFiles = readTempFiles;
exports.insertWithVSCodeOffsets = insertWithVSCodeOffsets;
exports.insertTokens = insertTokens;
exports.reset = reset;
exports.toArray = toArray;
exports.generateHighlighting = generateHighlighting;
exports.applyEdit = applyEdit;
exports.toOriginalOffset = toOriginalOffset;
exports.getVSCodeTokens = getVSCodeTokens;
exports.getHolePositionsFromLoad = getHolePositionsFromLoad;
exports.getHoles = getHoles;
exports.getHolesSorted = getHolesSorted;
/* decodeToken Not a pure module */
