// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Caml = require("rescript/lib/js/caml.js");
var Js_exn = require("rescript/lib/js/js_exn.js");
var Vscode = require("vscode");
var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Core__Array = require("@rescript/core/lib/js/src/Core__Array.bs.js");
var Core__Option = require("@rescript/core/lib/js/src/Core__Option.bs.js");
var FS$AgdaModeVscode = require("./FS.bs.js");
var Agda$AgdaModeVscode = require("./Agda.bs.js");
var Json$JsonCombinators = require("@glennsl/rescript-json-combinators/lib/js/src/Json.bs.js");
var Token$AgdaModeVscode = require("./Tokens/Token.bs.js");
var Editor$AgdaModeVscode = require("./Editor.bs.js");
var Parser$AgdaModeVscode = require("./Parser/Parser.bs.js");
var AVLTree$AgdaModeVscode = require("./Util/AVLTree.bs.js");
var Resource$AgdaModeVscode = require("./Resource.bs.js");
var TokenChange$AgdaModeVscode = require("./Tokens/TokenChange.bs.js");
var TokenIntervals$AgdaModeVscode = require("./Tokens/TokenIntervals.bs.js");
var Highlighting__AgdaAspect$AgdaModeVscode = require("./Highlighting/Highlighting__AgdaAspect.bs.js");
var Highlighting__Decoration$AgdaModeVscode = require("./Highlighting/Highlighting__Decoration.bs.js");
var Highlighting__SemanticToken$AgdaModeVscode = require("./Highlighting/Highlighting__SemanticToken.bs.js");

function toFilepath(format) {
  return format._0;
}

async function readAndParse(format) {
  try {
    var filepath = format._0;
    var uri = Vscode.Uri.file(filepath);
    var readResult = await FS$AgdaModeVscode.readFile(uri);
    var content;
    if (readResult.TAG === "Ok") {
      var decoder = (new TextDecoder());
      content = (function(decoder, arr) { return decoder.decode(arr) })(decoder, readResult._0);
    } else {
      content = Js_exn.raiseError("Failed to read file: " + readResult._0);
    }
    if (format.TAG === "Emacs") {
      var match = Parser$AgdaModeVscode.SExpression.parse(content)[0];
      var tokens;
      if (match !== undefined) {
        if (match.TAG === "Ok") {
          var xs = match._0;
          tokens = xs.TAG === "A" ? [] : xs._0;
        } else {
          tokens = [];
        }
      } else {
        tokens = [];
      }
      var match$1 = tokens[0];
      var removeTokenBasedHighlighting = match$1 !== undefined && match$1.TAG === "A" && match$1._0 === "remove" ? true : false;
      var tokens$1 = Core__Array.filterMap(tokens.slice(1), Token$AgdaModeVscode.parse);
      return [
              removeTokenBasedHighlighting,
              tokens$1
            ];
    }
    var exit = 0;
    var json;
    try {
      json = JSON.parse(content);
      exit = 1;
    }
    catch (_e){
      return [
              false,
              []
            ];
    }
    if (exit === 1) {
      var _err = Json$JsonCombinators.decode(json, Token$AgdaModeVscode.decodeResponseHighlightingInfoDirect);
      if (_err.TAG === "Ok") {
        var match$2 = _err._0;
        return [
                match$2[0],
                match$2[1]
              ];
      }
      console.log("Error in decoding JSON: " + _err._0);
      return [
              false,
              []
            ];
    }
    
  }
  catch (exn){
    return [
            false,
            []
          ];
  }
}

function toString(self) {
  var tempFiles = self.tempFiles.length === 0 ? "" : "\n    " + self.tempFiles.map(toFilepath).join("\n    ");
  var tokens = AVLTree$AgdaModeVscode.toArray(self.agdaTokens).map(function (param) {
          var token = param[1];
          return Token$AgdaModeVscode.toString(token) + " " + token.start.toString() + "-" + token.end.toString();
        }).join("\n    ");
  return "Tokens:\n  tempFiles (" + String(self.tempFiles.length) + ") " + tempFiles + "\n  tokens:\n    " + tokens;
}

function make(vscodeTokensResource) {
  return {
          tempFiles: [],
          agdaTokens: AVLTree$AgdaModeVscode.make(),
          deltas: TokenIntervals$AgdaModeVscode.empty,
          vscodeTokens: vscodeTokensResource !== undefined ? Caml_option.valFromOption(vscodeTokensResource) : Resource$AgdaModeVscode.make(),
          decorations: new Map(),
          holes: new Map(),
          holePositions: Resource$AgdaModeVscode.make()
        };
}

function insertWithVSCodeOffsets(self, token) {
  var existing = AVLTree$AgdaModeVscode.find(self.agdaTokens, token.start);
  if (existing !== undefined) {
    var areTheSameTokens = Caml_obj.equal(existing.aspects, token.aspects) && existing.start === token.start && existing.end === token.end;
    if (areTheSameTokens) {
      return ;
    }
    var newAspects = Caml_obj.equal(existing.aspects, token.aspects) ? existing.aspects : existing.aspects.concat(token.aspects);
    var new_start = existing.start;
    var new_end = existing.end;
    var new_isTokenBased = existing.isTokenBased;
    var new_note = existing.note;
    var new_source = existing.source;
    var $$new = {
      start: new_start,
      end: new_end,
      aspects: newAspects,
      isTokenBased: new_isTokenBased,
      note: new_note,
      source: new_source
    };
    AVLTree$AgdaModeVscode.remove(self.agdaTokens, token.start);
    AVLTree$AgdaModeVscode.insert(self.agdaTokens, token.start, $$new);
    if (token.aspects.some(function (x) {
            return x === "Hole";
          })) {
      self.holes.set(token.start, token);
      return ;
    } else {
      return ;
    }
  }
  AVLTree$AgdaModeVscode.insert(self.agdaTokens, token.start, token);
  if (token.aspects.some(function (x) {
          return x === "Hole";
        })) {
    self.holes.set(token.start, token);
    return ;
  }
  
}

function insertTokens(self, editor, tokens) {
  var $$document = editor.document;
  var text = Editor$AgdaModeVscode.$$Text.getAll($$document);
  var offsetConverter = Agda$AgdaModeVscode.OffsetConverter.make(text);
  tokens.forEach(function (token) {
        var start = Agda$AgdaModeVscode.OffsetConverter.convert(offsetConverter, token.start);
        var end = Agda$AgdaModeVscode.OffsetConverter.convert(offsetConverter, token.end);
        insertWithVSCodeOffsets(self, {
              start: start,
              end: end,
              aspects: token.aspects,
              isTokenBased: token.isTokenBased,
              note: token.note,
              source: token.source
            });
      });
}

function addEmacsFilePath(self, filepath) {
  self.tempFiles.push({
        TAG: "Emacs",
        _0: filepath
      });
}

function addJSONFilePath(self, filepath) {
  self.tempFiles.push({
        TAG: "JSON",
        _0: filepath
      });
}

async function readTempFiles(self, editor) {
  var xs = await Promise.all(self.tempFiles.map(readAndParse));
  var tokens = xs.map(function (prim) {
          return prim[1];
        }).flat();
  insertTokens(self, editor, tokens);
  self.tempFiles = [];
}

function reset(self) {
  self.tempFiles.forEach(function (format) {
        var filepath = format._0;
        var uri = Vscode.Uri.file(filepath);
        FS$AgdaModeVscode.$$delete(uri);
      });
  self.agdaTokens = AVLTree$AgdaModeVscode.make();
  self.deltas = TokenIntervals$AgdaModeVscode.empty;
  if (Resource$AgdaModeVscode.isPending(self.vscodeTokens)) {
    return ;
  } else {
    return Resource$AgdaModeVscode.set(self.vscodeTokens, []);
  }
}

function toTokenArray(self) {
  return AVLTree$AgdaModeVscode.toArray(self.agdaTokens).map(function (prim) {
              return prim[1];
            });
}

function toDecorations(self) {
  return self.decorations;
}

function goToDefinition(self, $$document) {
  return function (fileName, position) {
    var currentFileName = Parser$AgdaModeVscode.Filepath.make($$document.fileName);
    var offset = $$document.offsetAt(position);
    if (Caml_obj.equal(fileName, currentFileName)) {
      return Core__Option.map(Core__Option.flatMap(AVLTree$AgdaModeVscode.lowerBound(self.agdaTokens, offset), (function (token) {
                        var srcRange = new Vscode.Range($$document.positionAt(token.start), $$document.positionAt(token.end));
                        return Core__Option.map(token.source, (function (param) {
                                      return [
                                              srcRange,
                                              Parser$AgdaModeVscode.Filepath.toString(param[0]),
                                              param[1]
                                            ];
                                    }));
                      })), (function (param) {
                    var offset = param[2];
                    var filepath = param[1];
                    var srcRange = param[0];
                    return Vscode.workspace.openTextDocument(filepath).then(function ($$document) {
                                var text = Editor$AgdaModeVscode.$$Text.getAll($$document);
                                var offsetConverter = Agda$AgdaModeVscode.OffsetConverter.make(text);
                                var offset$1 = Agda$AgdaModeVscode.OffsetConverter.convert(offsetConverter, offset - 1 | 0);
                                var position = $$document.positionAt(offset$1);
                                return [[
                                          srcRange,
                                          filepath,
                                          position
                                        ]];
                              });
                  }));
    }
    
  };
}

function removeDecorations(self, editor) {
  Array.from(self.decorations.keys()).forEach(function (decoration) {
        Editor$AgdaModeVscode.Decoration.apply(editor, decoration, []);
      });
}

function applyDecorations(self, editor) {
  Array.from(self.decorations.entries()).forEach(function (param) {
        Editor$AgdaModeVscode.Decoration.apply(editor, param[0], param[1]);
      });
}

function convertFromAgdaAspects(xs) {
  var decorations = new Map();
  var semanticTokens = Core__Array.filterMap(xs, (function (param) {
          var range = param[1];
          var match = Belt_Array.unzip(param[0].map(Highlighting__AgdaAspect$AgdaModeVscode.toTokenTypeAndModifiersAndDecoration));
          var match$1 = Belt_Array.unzip(match[0]);
          var tokenTypes = Core__Array.filterMap(match$1[0], (function (x) {
                  return x;
                }));
          var tokenModifiers = match$1[1].flat();
          match[1].forEach(function (emacsDeco) {
                if (emacsDeco === undefined) {
                  return ;
                }
                var decoration = Highlighting__Decoration$AgdaModeVscode.toDecoration(emacsDeco);
                var ranges = decorations.get(decoration);
                var existingRanges = ranges !== undefined ? ranges : [];
                decorations.set(decoration, Belt_Array.concatMany([
                          existingRanges,
                          [Highlighting__SemanticToken$AgdaModeVscode.Module.SingleLineRange.toVsCodeRange(range)]
                        ]));
              });
          return Caml_option.some(Core__Option.map(tokenTypes[0], (function (tokenType) {
                            return {
                                    range: range,
                                    type_: tokenType,
                                    modifiers: tokenModifiers
                                  };
                          })));
        }));
  var semanticTokens$1 = Core__Array.filterMap(semanticTokens, (function (x) {
          return x;
        }));
  return [
          decorations,
          semanticTokens$1
        ];
}

function traverseIntervals(tokens, deltas, f, init) {
  var _acc = init;
  var _i = 0;
  var _intervals = deltas;
  var _deltaBefore = 0;
  while(true) {
    var deltaBefore = _deltaBefore;
    var intervals = _intervals;
    var i = _i;
    var acc = _acc;
    var token = tokens[i];
    if (token === undefined) {
      return acc;
    }
    if (typeof intervals !== "object") {
      _i = i + 1 | 0;
      _acc = f(acc, token, {
            TAG: "Translate",
            _0: deltaBefore
          });
      continue ;
    }
    if (token.end < intervals._0) {
      _i = i + 1 | 0;
      _acc = f(acc, token, {
            TAG: "Translate",
            _0: deltaBefore
          });
      continue ;
    }
    if (token.start < intervals._1) {
      _i = i + 1 | 0;
      _acc = f(acc, token, "Remove");
      continue ;
    }
    _deltaBefore = intervals._2;
    _intervals = intervals._3;
    continue ;
  };
}

function generateHighlighting(self, editor) {
  var $$document = editor.document;
  var match = traverseIntervals(toTokenArray(self), self.deltas, (function (param, token, action) {
          var holePositions = param[1];
          var acc = param[0];
          if (typeof action !== "object") {
            return [
                    acc,
                    holePositions
                  ];
          }
          var delta = action._0;
          var offsetStart = token.start + delta | 0;
          var offsetEnd = token.end + delta | 0;
          var range = new Vscode.Range($$document.positionAt(offsetStart), $$document.positionAt(offsetEnd));
          if (token.aspects.some(function (x) {
                  return x === "Hole";
                })) {
            holePositions.set(offsetStart, offsetEnd);
          }
          var singleLineRanges = Highlighting__SemanticToken$AgdaModeVscode.Module.SingleLineRange.splitRange($$document, range);
          var result = singleLineRanges.map(function (range) {
                return [
                        token.aspects,
                        range
                      ];
              });
          return [
                  Belt_Array.concatMany([
                        acc,
                        result
                      ]),
                  holePositions
                ];
        }), [
        [],
        new Map()
      ]);
  var match$1 = convertFromAgdaAspects(match[0]);
  Resource$AgdaModeVscode.set(self.vscodeTokens, match$1[1]);
  removeDecorations(self, editor);
  self.decorations = match$1[0];
  applyDecorations(self, editor);
  Resource$AgdaModeVscode.set(self.holePositions, match[1]);
}

function applyEdit(self, editor, $$event) {
  var changes = $$event.contentChanges.map(TokenChange$AgdaModeVscode.fromTextDocumentContentChangeEvent);
  self.deltas = TokenIntervals$AgdaModeVscode.applyChanges(self.deltas, changes.toReversed());
  generateHighlighting(self, editor);
}

function toOriginalOffset(self, offset) {
  return traverseIntervals(toTokenArray(self), self.deltas, (function (acc, token, action) {
                if (typeof action !== "object") {
                  return acc;
                }
                var delta = action._0;
                if (offset >= (token.start + delta | 0) && offset < (token.end + delta | 0)) {
                  return offset - delta | 0;
                } else {
                  return acc;
                }
              }), undefined);
}

function getVSCodeTokens(self) {
  return self.vscodeTokens;
}

function getHolePositionsFromLoad(self) {
  return self.holePositions;
}

function getHoles(self) {
  return self.holes;
}

function getHolesSorted(self) {
  return Array.from(self.holes.values()).toSorted(function (x, y) {
              return Caml.int_compare(x.start, y.start);
            });
}

var Module = {
  toString: toString,
  make: make,
  toTokenArray: toTokenArray,
  toDecorations: toDecorations,
  addEmacsFilePath: addEmacsFilePath,
  addJSONFilePath: addJSONFilePath,
  readTempFiles: readTempFiles,
  insertWithVSCodeOffsets: insertWithVSCodeOffsets,
  insertTokens: insertTokens,
  reset: reset,
  goToDefinition: goToDefinition,
  generateHighlighting: generateHighlighting,
  applyEdit: applyEdit,
  removeDecorations: removeDecorations,
  applyDecorations: applyDecorations,
  toOriginalOffset: toOriginalOffset,
  getVSCodeTokens: getVSCodeTokens,
  getHolePositionsFromLoad: getHolePositionsFromLoad,
  getHoles: getHoles,
  getHolesSorted: getHolesSorted
};

var Aspect;

exports.Aspect = Aspect;
exports.Module = Module;
exports.toString = toString;
exports.make = make;
exports.toTokenArray = toTokenArray;
exports.toDecorations = toDecorations;
exports.addEmacsFilePath = addEmacsFilePath;
exports.addJSONFilePath = addJSONFilePath;
exports.readTempFiles = readTempFiles;
exports.insertWithVSCodeOffsets = insertWithVSCodeOffsets;
exports.insertTokens = insertTokens;
exports.reset = reset;
exports.goToDefinition = goToDefinition;
exports.generateHighlighting = generateHighlighting;
exports.applyEdit = applyEdit;
exports.removeDecorations = removeDecorations;
exports.applyDecorations = applyDecorations;
exports.toOriginalOffset = toOriginalOffset;
exports.getVSCodeTokens = getVSCodeTokens;
exports.getHolePositionsFromLoad = getHolePositionsFromLoad;
exports.getHoles = getHoles;
exports.getHolesSorted = getHolesSorted;
/* vscode Not a pure module */
