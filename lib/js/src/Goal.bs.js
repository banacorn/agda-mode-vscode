// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Vscode = require("vscode");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Core__Array = require("@rescript/core/lib/js/src/Core__Array.bs.js");
var Util$AgdaModeVscode = require("./Util/Util.bs.js");
var Common$AgdaModeVscode = require("./View/Common.bs.js");
var Editor$AgdaModeVscode = require("./Editor.bs.js");
var Parser$AgdaModeVscode = require("./Parser/Parser.bs.js");
var SourceFile$AgdaModeVscode = require("./Parser/SourceFile.bs.js");
var Highlighting$AgdaModeVscode = require("./Highlighting.bs.js");

function generateDiffs($$document, indices) {
  var fileName = Parser$AgdaModeVscode.filepath($$document.fileName);
  var source = Editor$AgdaModeVscode.$$Text.getAll($$document);
  return SourceFile$AgdaModeVscode.parse(indices, fileName, source);
}

async function makeMany(editor, holes) {
  var $$document = editor.document;
  var indices = holes.map(function (prim) {
        return prim[0];
      });
  var replacements = Core__Array.filterMap(holes, (function (param) {
          var range = param[1][1];
          var index = param[0];
          var content = $$document.getText(Caml_option.some(range));
          if (content === "?") {
            console.log("found a hole at " + String(index) + " " + Editor$AgdaModeVscode.$$Range.toString(range));
            return [
                    range,
                    "{!   !}"
                  ];
          } else {
            console.log("found a non-hole at " + String(index) + " " + Editor$AgdaModeVscode.$$Range.toString(range));
            return ;
          }
        }));
  var diffs = generateDiffs($$document, indices);
  await Editor$AgdaModeVscode.$$Text.batchReplace($$document, replacements);
  return diffs.map(function (diff) {
              var match = Highlighting$AgdaModeVscode.decorateHole(editor, diff.modifiedInterval, diff.index);
              return {
                      index: diff.index,
                      interval: diff.modifiedInterval,
                      decorationBackground: match[0],
                      decorationIndex: match[1]
                    };
            });
}

function getInnerRange(self, $$document) {
  var interval_0 = self.interval[0] + 2 | 0;
  var interval_1 = self.interval[1] - 2 | 0;
  var interval = [
    interval_0,
    interval_1
  ];
  return Common$AgdaModeVscode.Interval.toVSCodeRange($$document, interval);
}

function getOuterRange(self, $$document) {
  return Common$AgdaModeVscode.Interval.toVSCodeRange($$document, self.interval);
}

function getContent(self, $$document) {
  var innerRange = getInnerRange(self, $$document);
  return Editor$AgdaModeVscode.$$Text.get($$document, innerRange).trim();
}

function setContent(self, $$document, text) {
  var innerRange = getInnerRange(self, $$document);
  return Editor$AgdaModeVscode.$$Text.replace($$document, innerRange, " " + text + " ");
}

function setCursor(self, editor) {
  var $$document = editor.document;
  var match = self.interval;
  var position = $$document.positionAt(match[0] + 3 | 0);
  Editor$AgdaModeVscode.Cursor.set(editor, position);
  var range = Common$AgdaModeVscode.Interval.toVSCodeRange($$document, self.interval);
  editor.revealRange(range, undefined);
}

function buildHaskellRange(self, $$document, version, filepath) {
  var match = self.interval;
  var end_ = match[1];
  var start = match[0];
  var startPoint = $$document.positionAt(start);
  var endPoint = $$document.positionAt(end_);
  var startIndex = String(start + 3 | 0);
  var startRow = String(startPoint.line + 1 | 0);
  var startColumn = String(startPoint.character + 3 | 0);
  var startPart = startIndex + " " + startRow + " " + startColumn;
  var endIndex$p = String(end_ - 3 | 0);
  var endRow = String(endPoint.line + 1 | 0);
  var endColumn = String(endPoint.character - 1 | 0);
  var endPart = endIndex$p + " " + endRow + " " + endColumn;
  if (Util$AgdaModeVscode.Version.gte(version, "2.8.0")) {
    return "(intervalsToRange (Just (mkAbsolute \"" + filepath + "\")) [Interval () (Pn () " + startPart + ") (Pn () " + endPart + ")])";
  } else if (Util$AgdaModeVscode.Version.gte(version, "2.5.1")) {
    return "(intervalsToRange (Just (mkAbsolute \"" + filepath + "\")) [Interval (Pn () " + startPart + ") (Pn () " + endPart + ")])";
  } else {
    return "(Range [Interval (Pn (Just (mkAbsolute \"" + filepath + "\")) " + startPart + ") (Pn (Just (mkAbsolute \"" + filepath + "\")) " + endPart + ")])";
  }
}

function refreshDecoration(self, editor) {
  var range = getOuterRange(self, editor.document);
  Editor$AgdaModeVscode.Decoration.decorate(editor, self.decorationBackground, [range]);
  var range$1 = new Vscode.Range(range.start, range.end.translate(0, -2));
  Editor$AgdaModeVscode.Decoration.decorate(editor, self.decorationIndex, [range$1]);
}

function destroyDecoration(self) {
  Editor$AgdaModeVscode.Decoration.destroy(self.decorationBackground);
  Editor$AgdaModeVscode.Decoration.destroy(self.decorationIndex);
}

var Module = {
  buildHaskellRange: buildHaskellRange,
  generateDiffs: generateDiffs,
  makeMany: makeMany,
  getContent: getContent,
  setContent: setContent,
  setCursor: setCursor,
  getInnerRange: getInnerRange,
  refreshDecoration: refreshDecoration,
  destroyDecoration: destroyDecoration
};

exports.Module = Module;
exports.buildHaskellRange = buildHaskellRange;
exports.generateDiffs = generateDiffs;
exports.makeMany = makeMany;
exports.getContent = getContent;
exports.setContent = setContent;
exports.setCursor = setCursor;
exports.getInnerRange = getInnerRange;
exports.refreshDecoration = refreshDecoration;
exports.destroyDecoration = destroyDecoration;
/* vscode Not a pure module */
