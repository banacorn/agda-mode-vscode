// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Caml = require("rescript/lib/js/caml.js");
var Vscode = require("vscode");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var FastCheck = require("fast-check");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Core__Option = require("@rescript/core/lib/js/src/Core__Option.bs.js");
var Util$AgdaModeVscode = require("./Util/Util.bs.js");
var Editor$AgdaModeVscode = require("./Editor.bs.js");
var Parser$AgdaModeVscode = require("./Parser/Parser.bs.js");

function toString(goal) {
  var editor = Vscode.window.activeTextEditor;
  if (editor === undefined) {
    return "#" + String(goal.index) + " offset [" + String(goal.start) + "-" + String(goal.end) + ")";
  }
  var $$document = Caml_option.valFromOption(editor).document;
  var startPoint = $$document.positionAt(goal.start);
  var endPoint = $$document.positionAt(goal.end);
  var startLine = startPoint.line + 1 | 0;
  var startColumn = startPoint.character + 1 | 0;
  var endLine = endPoint.line + 1 | 0;
  var endColumn = endPoint.character + 1 | 0;
  if (startLine === endLine) {
    return "#" + String(goal.index) + " [" + String(startLine) + ":" + String(startColumn) + "-" + String(endColumn) + ")";
  } else {
    return "#" + String(goal.index) + " [" + String(startLine) + ":" + String(startColumn) + "-" + String(endLine) + ":" + String(endColumn) + ")";
  }
}

function makeHaskellRange(goalInfo, $$document, version, filepath) {
  var startPoint = $$document.positionAt(goalInfo.start);
  var endPoint = $$document.positionAt(goalInfo.end);
  var startIndex = String(goalInfo.start + 3 | 0);
  var startRow = String(startPoint.line + 1 | 0);
  var startColumn = String(startPoint.character + 3 | 0);
  var startPart = startIndex + " " + startRow + " " + startColumn;
  var endIndex$p = String(goalInfo.end - 3 | 0);
  var endRow = String(endPoint.line + 1 | 0);
  var endColumn = String(endPoint.character - 1 | 0);
  var endPart = endIndex$p + " " + endRow + " " + endColumn;
  if (Util$AgdaModeVscode.Version.gte(version, "2.8.0")) {
    return "(intervalsToRange (Just (mkAbsolute \"" + filepath + "\")) [Interval () (Pn () " + startPart + ") (Pn () " + endPart + ")])";
  } else if (Util$AgdaModeVscode.Version.gte(version, "2.5.1")) {
    return "(intervalsToRange (Just (mkAbsolute \"" + filepath + "\")) [Interval (Pn () " + startPart + ") (Pn () " + endPart + ")])";
  } else {
    return "(Range [Interval (Pn (Just (mkAbsolute \"" + filepath + "\")) " + startPart + ") (Pn (Just (mkAbsolute \"" + filepath + "\")) " + endPart + ")])";
  }
}

function getContent(goal, $$document) {
  var innerRange = new Vscode.Range($$document.positionAt(goal.start + 2 | 0), $$document.positionAt(goal.end - 2 | 0));
  return Editor$AgdaModeVscode.$$Text.get($$document, innerRange).trim();
}

function indentationWidth(goal, $$document) {
  var goalStart = $$document.positionAt(goal.start);
  var lineNo = goalStart.line;
  var range = new Vscode.Range(new Vscode.Position(lineNo, 0), goalStart);
  var textBeforeGoal = Editor$AgdaModeVscode.$$Text.get($$document, range);
  var indentedBy = function (s) {
    var n = 0;
    for(var i = 0 ,i_finish = s.length; i < i_finish; ++i){
      var match = s.charAt(i);
      var exit = 0;
      switch (match) {
        case "	" :
        case "" :
        case " " :
        case "\n" :
            exit = 1;
            break;
        default:
          
      }
      if (exit === 1 && i === n) {
        n = n + 1 | 0;
      }
      
    }
    return n;
  };
  return [
          indentedBy(textBeforeGoal),
          textBeforeGoal,
          range
        ];
}

function caseSplitAux(goal, editor) {
  var $$document = editor.document;
  var range = new Vscode.Range($$document.positionAt(0), $$document.positionAt(goal.start));
  var textBeforeGoal = Editor$AgdaModeVscode.$$Text.get($$document, range);
  var nextWordBoundary = function (start, string) {
    var $$break = false;
    var n = 0;
    var i = start;
    while(i < string.length && !$$break) {
      var $$char = string.charAt(i);
      switch ($$char) {
        case "	" :
        case "" :
        case " " :
            n = n + 1 | 0;
            break;
        default:
          $$break = true;
      }
      i = i + 1 | 0;
    };
    return start + n | 0;
  };
  var bracketCount = 0;
  var i = goal.start - 1 | 0;
  while(i >= 0 && bracketCount >= 0) {
    var i$p = i;
    if (i$p !== 0) {
      var match = textBeforeGoal.charAt(i$p - 1 | 0);
      switch (match) {
        case "{" :
            bracketCount = bracketCount - 1 | 0;
            break;
        case "}" :
            bracketCount = bracketCount + 1 | 0;
            break;
        default:
          
      }
    }
    i = i - 1 | 0;
  };
  var lastOpenCurlyBracketOffset = i + 1 | 0;
  var n = textBeforeGoal.lastIndexOf(";");
  var lastSemicolonOffset = (
    n !== -1 ? n : 0
  ) + 1 | 0;
  var n$1 = textBeforeGoal.lastIndexOf("where");
  var lastWhereTokenOffset = (
    n$1 !== -1 ? n$1 : 0
  ) + 5 | 0;
  var lastLineBreakOffset = Caml.int_max(0, Caml.int_max(textBeforeGoal.lastIndexOf("\r"), textBeforeGoal.lastIndexOf("\n"))) + 1 | 0;
  var inWhereClause = lastWhereTokenOffset > lastOpenCurlyBracketOffset;
  var offset = Caml.int_max(lastLineBreakOffset > lastSemicolonOffset ? lastLineBreakOffset : lastSemicolonOffset, lastWhereTokenOffset > lastOpenCurlyBracketOffset ? lastWhereTokenOffset : lastOpenCurlyBracketOffset);
  var caseStart = nextWordBoundary(offset, textBeforeGoal);
  var caseEnd = goal.end;
  var range$1 = new Vscode.Range($$document.positionAt(caseStart), $$document.positionAt(caseEnd));
  return [
          inWhereClause,
          caseStart - lastLineBreakOffset | 0,
          range$1
        ];
}

async function replaceWithLines(goal, editor, lines) {
  var $$document = editor.document;
  var match = indentationWidth(goal, $$document);
  var indentation = " ".repeat(match[0]);
  var indentedLines = indentation + lines.join("\n" + indentation);
  var start = $$document.positionAt(goal.start);
  var startLineNo = start.line;
  var startLineRange = $$document.lineAt(startLineNo).range;
  var start$1 = startLineRange.start;
  var end_ = $$document.positionAt(goal.end);
  var rangeToBeReplaced = new Vscode.Range(start$1, end_);
  if (await Editor$AgdaModeVscode.$$Text.replace(editor, rangeToBeReplaced, indentedLines, undefined)) {
    return [
            rangeToBeReplaced,
            indentedLines
          ];
  }
  
}

async function replaceWithLambda(goal, editor, lines) {
  var match = caseSplitAux(goal, editor);
  var rewriteRange = match[2];
  var indentWidth = match[1];
  var rewriteText = match[0] ? lines.join("\n" + " ".repeat(indentWidth)) : lines.join("\n" + (" ".repeat(indentWidth - 2 | 0) + "; "));
  if (await Editor$AgdaModeVscode.$$Text.replace(editor, rewriteRange, rewriteText, undefined)) {
    return [
            rewriteRange,
            rewriteText
          ];
  }
  
}

function placeCursorAtFirstNewGoal(editor, rewriteRange, rewriteText) {
  var splittedLines = Parser$AgdaModeVscode.splitToLines(rewriteText);
  Core__Option.forEach(splittedLines[0], (function (line) {
          var col = line.length - 1 | 0;
          var lastChar = line.charAt(col);
          if (lastChar !== "?") {
            return ;
          }
          var position = rewriteRange.start.translate(0, col);
          Editor$AgdaModeVscode.Cursor.set(editor, position);
        }));
}

function arbitraryInterval(after) {
  return FastCheck.integer(after, after + 10 | 0).chain(function (start) {
              return FastCheck.integer(start + 4 | 0, start + 10 | 0).map(function (end) {
                          return [
                                  start,
                                  end
                                ];
                        });
            });
}

function arbitraryBatch(sizeOpt, afterOpt) {
  var size = sizeOpt !== undefined ? sizeOpt : 10;
  var after = afterOpt !== undefined ? afterOpt : 0;
  var aux = function (param, index) {
    var after = param[1];
    var acc = param[0];
    if (index >= size) {
      return FastCheck.constant([
                  acc,
                  after
                ]);
    } else {
      return arbitraryInterval(after).chain(function (param) {
                  var end = param[1];
                  var goal_indexString = String(index);
                  var goal_start = param[0];
                  var goal = {
                    index: index,
                    indexString: goal_indexString,
                    start: goal_start,
                    end: end
                  };
                  return aux([
                              Belt_Array.concatMany([
                                    acc,
                                    [goal]
                                  ]),
                              end
                            ], index + 1 | 0);
                });
    }
  };
  return aux([
                [],
                after
              ], 0).map(function (prim) {
              return prim[0];
            });
}

var Module = {
  toString: toString,
  getContent: getContent,
  indentationWidth: indentationWidth,
  makeHaskellRange: makeHaskellRange,
  replaceWithLines: replaceWithLines,
  replaceWithLambda: replaceWithLambda,
  placeCursorAtFirstNewGoal: placeCursorAtFirstNewGoal,
  arbitraryBatch: arbitraryBatch
};

exports.Module = Module;
exports.toString = toString;
exports.getContent = getContent;
exports.indentationWidth = indentationWidth;
exports.makeHaskellRange = makeHaskellRange;
exports.replaceWithLines = replaceWithLines;
exports.replaceWithLambda = replaceWithLambda;
exports.placeCursorAtFirstNewGoal = placeCursorAtFirstNewGoal;
exports.arbitraryBatch = arbitraryBatch;
/* vscode Not a pure module */
