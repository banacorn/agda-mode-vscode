// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Caml_option = require("rescript/lib/js/caml_option.js");
var Core__Option = require("@rescript/core/lib/js/src/Core__Option.bs.js");
var BinarySearchTree = require("@datastructures-js/binary-search-tree");

function getValue(self) {
  return self.getValue()[1];
}

var $$Node = {
  getValue: getValue
};

function make() {
  return new BinarySearchTree.BinarySearchTree((function (param, param$1) {
                return param[0] - param$1[0] | 0;
              }), {
              key: "0"
            });
}

function insert(self, key, value) {
  self.insert([
        key,
        value
      ]);
}

function find(self, key) {
  return Core__Option.map(Caml_option.nullable_to_opt(self.findKey(key)), getValue);
}

function max(self) {
  return Core__Option.map(Caml_option.nullable_to_opt(self.max()), getValue);
}

function min(self) {
  return Core__Option.map(Caml_option.nullable_to_opt(self.min()), getValue);
}

function upperBound(self, key) {
  return Core__Option.map(Caml_option.nullable_to_opt(self.upperBoundKey(key)), getValue);
}

function lowerBound(self, key) {
  return Core__Option.map(Caml_option.nullable_to_opt(self.lowerBoundKey(key)), getValue);
}

function floor(self, key) {
  return Core__Option.map(Caml_option.nullable_to_opt(self.floorKey(key)), getValue);
}

function ceil(self, key) {
  return Core__Option.map(Caml_option.nullable_to_opt(self.ceilKey(key)), getValue);
}

function remove(self, key) {
  return Core__Option.mapOr(Caml_option.nullable_to_opt(self.findKey(key)), false, (function (node) {
                return self.removeNode(node);
              }));
}

function toArray(self) {
  var accum = [];
  self.traverseInOrder(function (node) {
        var key = node.getValue()[0];
        var value = getValue(node);
        accum.push([
              key,
              value
            ]);
      });
  return accum;
}

function forEach(self, f) {
  self.traverseInOrder(function (node) {
        f(getValue(node));
      });
}

function forEachWithIndex(self, f) {
  var index = {
    contents: 0
  };
  self.traverseInOrder(function (node) {
        var value = getValue(node);
        f(index.contents, value);
        index.contents = index.contents + 1 | 0;
      });
}

exports.$$Node = $$Node;
exports.make = make;
exports.insert = insert;
exports.find = find;
exports.max = max;
exports.min = min;
exports.upperBound = upperBound;
exports.lowerBound = lowerBound;
exports.floor = floor;
exports.ceil = ceil;
exports.remove = remove;
exports.toArray = toArray;
exports.forEach = forEach;
exports.forEachWithIndex = forEachWithIndex;
/* @datastructures-js/binary-search-tree Not a pure module */
