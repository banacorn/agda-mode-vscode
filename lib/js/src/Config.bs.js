// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Vscode = require("vscode");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Core__Array = require("@rescript/core/lib/js/src/Core__Array.bs.js");
var Core__Option = require("@rescript/core/lib/js/src/Core__Option.bs.js");
var Parser$AgdaModeVscode = require("./Parser/Parser.bs.js");
var Connection__URI$AgdaModeVscode = require("./Connection/Connection__URI.bs.js");

var inTestingMode = {
  contents: false
};

var agdaVersionInTestingMode = {
  contents: "agda"
};

var agdaPathsInTestingMode = {
  contents: []
};

var useAgdaLanguageServerInTestingMode = {
  contents: false
};

function setAgdaVersion(path) {
  if (inTestingMode.contents) {
    agdaVersionInTestingMode.contents = path;
    return Promise.resolve();
  } else {
    return Vscode.workspace.getConfiguration("agdaMode", undefined).update("connection.agdaVersion", path, 1, undefined);
  }
}

function getAgdaVersion() {
  if (inTestingMode.contents) {
    return agdaVersionInTestingMode.contents;
  } else {
    return Core__Option.getOr(Core__Option.flatMap(Core__Option.map(Vscode.workspace.getConfiguration("agdaMode", undefined).get("connection.agdaVersion"), (function (prim) {
                          return prim.trim();
                        })), (function (s) {
                      if (s === "") {
                        return ;
                      } else {
                        return s;
                      }
                    })), "agda");
  }
}

function setAgdaPaths(paths) {
  if (inTestingMode.contents) {
    agdaPathsInTestingMode.contents = paths;
    return Promise.resolve();
  }
  var paths$1 = paths.map(Connection__URI$AgdaModeVscode.toString);
  return Vscode.workspace.getConfiguration("agdaMode", undefined).update("connection.paths", paths$1, 1, undefined);
}

function getAgdaPaths() {
  if (inTestingMode.contents) {
    return agdaPathsInTestingMode.contents;
  }
  var rawPaths = Vscode.workspace.getConfiguration("agdaMode", undefined).get("connection.paths");
  var paths = Core__Option.getOr(rawPaths, []).filter(function (s) {
        return Parser$AgdaModeVscode.filepath(s) !== "";
      });
  paths.reverse();
  return paths.map(Connection__URI$AgdaModeVscode.parse);
}

function addAgdaPath(path) {
  var paths = getAgdaPaths();
  var alreadyExists = Core__Array.reduce(paths, false, (function (acc, p) {
          if (acc) {
            return true;
          } else {
            return Connection__URI$AgdaModeVscode.equal(p, path);
          }
        }));
  if (alreadyExists) {
    return Promise.resolve();
  }
  var newPaths = paths.concat([path]);
  if (inTestingMode.contents) {
    agdaPathsInTestingMode.contents = newPaths;
    return Promise.resolve();
  }
  var newPaths$1 = newPaths.map(Connection__URI$AgdaModeVscode.toString);
  return Vscode.workspace.getConfiguration("agdaMode", undefined).update("connection.paths", newPaths$1, 1, undefined);
}

function getCommandLineOptions() {
  return Core__Option.mapOr(Vscode.workspace.getConfiguration("agdaMode", undefined).get("connection.commandLineOptions"), [], (function (s) {
                  return s.trim().split(" ");
                })).filter(function (s) {
              return s.trim() !== "";
            });
}

function getUseAgdaLanguageServer() {
  if (inTestingMode.contents) {
    return useAgdaLanguageServerInTestingMode.contents;
  }
  var raw = Vscode.workspace.getConfiguration("agdaMode", undefined).get("connection.agdaLanguageServer");
  if (raw !== undefined && raw) {
    return true;
  } else {
    return false;
  }
}

function setUseAgdaLanguageServer(mode) {
  if (inTestingMode.contents) {
    useAgdaLanguageServerInTestingMode.contents = mode;
    return Promise.resolve();
  } else {
    return Vscode.workspace.getConfiguration("agdaMode", undefined).update("connection.agdaLanguageServer", mode, 1, undefined);
  }
}

function getAgdaLanguageServerPort() {
  var raw = Vscode.workspace.getConfiguration("agdaMode", undefined).get("connection.agdaLanguageServerPort");
  if (raw !== undefined) {
    return Caml_option.valFromOption(raw);
  } else {
    return 4096;
  }
}

function getAgdaLanguageServerCommandLineOptions() {
  return Core__Option.mapOr(Vscode.workspace.getConfiguration("agdaMode", undefined).get("connection.agdaLanguageServerOptions"), [], (function (s) {
                  return s.trim().split(" ");
                })).filter(function (s) {
              return s.trim() !== "";
            });
}

var policyTestingMode = {
  contents: "Undecided"
};

function toString(policy) {
  switch (policy) {
    case "YesKeepUpToDate" :
        return "Yes, and keep it up-to-date";
    case "YesButDontUpdate" :
        return "Yes, but don't update afterwards";
    case "NoDontAskAgain" :
        return "No, and don't ask again";
    case "Undecided" :
        return "Undecided";
    
  }
}

function getDownloadPolicy() {
  if (inTestingMode.contents) {
    return policyTestingMode.contents;
  } else {
    return Core__Option.mapOr(Vscode.workspace.getConfiguration("agdaMode", undefined).get("connection.downloadPolicy"), "Undecided", (function (s) {
                  switch (s) {
                    case "No, and don't ask again" :
                        return "NoDontAskAgain";
                    case "Yes, and keep it up-to-date" :
                        return "YesKeepUpToDate";
                    case "Yes, but don't update afterwards" :
                        return "YesButDontUpdate";
                    default:
                      return "Undecided";
                  }
                }));
  }
}

function setDownloadPolicy(policy) {
  if (inTestingMode.contents) {
    policyTestingMode.contents = policy;
    return Promise.resolve();
  }
  var tmp;
  switch (policy) {
    case "YesKeepUpToDate" :
        tmp = "Yes, and keep it up-to-date";
        break;
    case "YesButDontUpdate" :
        tmp = "Yes, but don't update afterwards";
        break;
    case "NoDontAskAgain" :
        tmp = "No, and don't ask again";
        break;
    case "Undecided" :
        tmp = "Undecided";
        break;
    
  }
  return Vscode.workspace.getConfiguration("agdaMode", undefined).update("connection.downloadPolicy", tmp, 1, undefined);
}

var Download = {
  policyTestingMode: policyTestingMode,
  toString: toString,
  getDownloadPolicy: getDownloadPolicy,
  setDownloadPolicy: setDownloadPolicy
};

var Connection = {
  agdaVersionInTestingMode: agdaVersionInTestingMode,
  agdaPathsInTestingMode: agdaPathsInTestingMode,
  useAgdaLanguageServerInTestingMode: useAgdaLanguageServerInTestingMode,
  setAgdaVersion: setAgdaVersion,
  getAgdaVersion: getAgdaVersion,
  setAgdaPaths: setAgdaPaths,
  getAgdaPaths: getAgdaPaths,
  addAgdaPath: addAgdaPath,
  getCommandLineOptions: getCommandLineOptions,
  getUseAgdaLanguageServer: getUseAgdaLanguageServer,
  setUseAgdaLanguageServer: setUseAgdaLanguageServer,
  getAgdaLanguageServerPort: getAgdaLanguageServerPort,
  getAgdaLanguageServerCommandLineOptions: getAgdaLanguageServerCommandLineOptions,
  Download: Download
};

function setPanelMountingPosition(mountAt) {
  var tmp;
  tmp = mountAt === "Bottom" ? "bottom" : "right";
  return Vscode.workspace.getConfiguration("agdaMode", undefined).update("view.panelMountPosition", tmp, 1, undefined);
}

function getPanelMountingPosition() {
  var result = Vscode.workspace.getConfiguration("agdaMode", undefined).get("view.panelMountPosition");
  if (result === "right") {
    return "Right";
  } else {
    return "Bottom";
  }
}

var View = {
  setPanelMountingPosition: setPanelMountingPosition,
  getPanelMountingPosition: getPanelMountingPosition
};

function getLibraryPath() {
  var raw = Core__Option.getOr(Vscode.workspace.getConfiguration("agdaMode", undefined).get("libraryPath"), "");
  return raw.split(",").filter(function (x) {
                return x !== "";
              }).map(Parser$AgdaModeVscode.filepath);
}

function getHighlightingMethod() {
  var raw = Vscode.workspace.getConfiguration("agdaMode", undefined).get("highlighting.IPC");
  if (raw === "Standard input/output") {
    return true;
  } else {
    return false;
  }
}

function getHighlightWithThemeColors() {
  var raw = Vscode.workspace.getConfiguration("agdaMode", undefined).get("highlighting.getHighlightWithThemeColors");
  if (raw !== undefined && !raw) {
    return false;
  } else {
    return true;
  }
}

var Highlighting = {
  getHighlightingMethod: getHighlightingMethod,
  getHighlightWithThemeColors: getHighlightWithThemeColors
};

function getBackend() {
  var raw = Vscode.workspace.getConfiguration("agdaMode", undefined).get("backend");
  if (raw === undefined) {
    return "GHCNoMain";
  }
  switch (raw) {
    case "LaTeX" :
        return "LaTeX";
    case "QuickLaTeX" :
        return "QuickLaTeX";
    default:
      return "GHCNoMain";
  }
}

function getEnable() {
  var raw = Vscode.workspace.getConfiguration("agdaMode", undefined).get("inputMethod.enable");
  if (raw !== undefined && !raw) {
    return false;
  } else {
    return true;
  }
}

function getActivationKey() {
  var raw = Vscode.workspace.getConfiguration("agdaMode", undefined).get("inputMethod.activationKey");
  if (raw === undefined) {
    return "\\";
  }
  var key = Caml_option.valFromOption(raw).substring(0, 1);
  if (key === "") {
    return "\\";
  } else {
    return key;
  }
}

var InputMethod = {
  getEnable: getEnable,
  getActivationKey: getActivationKey
};

function getFontSize() {
  var config = Vscode.workspace.getConfiguration("agdaMode", undefined);
  var n = Vscode.workspace.getConfiguration("editor", undefined).get("fontSize");
  var editorFontSize = n !== undefined ? Caml_option.valFromOption(n) : 14;
  var m = config.get("buffer.fontSize");
  var size;
  if (m !== undefined) {
    var m$1 = Caml_option.valFromOption(m);
    size = m$1 === null ? editorFontSize : m$1;
  } else {
    size = editorFontSize;
  }
  return size.toString();
}

var $$Buffer = {
  getFontSize: getFontSize
};

var VSRange;

exports.VSRange = VSRange;
exports.inTestingMode = inTestingMode;
exports.Connection = Connection;
exports.View = View;
exports.getLibraryPath = getLibraryPath;
exports.Highlighting = Highlighting;
exports.getBackend = getBackend;
exports.InputMethod = InputMethod;
exports.$$Buffer = $$Buffer;
/* vscode Not a pure module */
