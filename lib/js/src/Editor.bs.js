// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var VSCode = require("rescript-vscode/lib/js/src/VSCode.bs.js");
var Vscode = require("vscode");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Agda$AgdaModeVscode = require("./Agda.bs.js");

function toString(position) {
  return String(position.line + 1 | 0) + ":" + String(position.character + 1 | 0);
}

var Position = {
  toString: toString
};

function toString$1(range) {
  var start = range.start;
  var end = range.end;
  if (start.line === end.line) {
    return String(start.line + 1 | 0) + ":" + String(start.character + 1 | 0) + "-" + String(end.character + 1 | 0);
  } else {
    return toString(start) + "-" + toString(end);
  }
}

var $$Range = {
  toString: toString$1
};

function decorate(editor, decoration, ranges) {
  editor.setDecorations(decoration, ranges);
}

function highlightBackgroundPrim(editor, backgroundColor, ranges) {
  var options = {
    backgroundColor: backgroundColor,
    rangeBehavior: 1
  };
  var decoration = Vscode.window.createTextEditorDecorationType(options);
  decorate(editor, decoration, ranges);
  return decoration;
}

function highlightBackground(editor, style, ranges) {
  return highlightBackgroundPrim(editor, VSCode.StringOr.make({
                  TAG: "Others",
                  _0: new Vscode.ThemeColor(style),
                  [Symbol.for("name")]: "Others"
                }), ranges);
}

function highlightBackgroundWithColor(editor, color, ranges) {
  return highlightBackgroundPrim(editor, VSCode.StringOr.make({
                  TAG: "String",
                  _0: color,
                  [Symbol.for("name")]: "String"
                }), ranges);
}

function decorateTextPrim(editor, color, ranges) {
  var options = {
    color: color,
    rangeBehavior: 1
  };
  var decoration = Vscode.window.createTextEditorDecorationType(options);
  decorate(editor, decoration, ranges);
  return decoration;
}

function decorateText(editor, style, ranges) {
  return decorateTextPrim(editor, VSCode.StringOr.make({
                  TAG: "Others",
                  _0: new Vscode.ThemeColor(style),
                  [Symbol.for("name")]: "Others"
                }), ranges);
}

function decorateTextWithColor(editor, color, ranges) {
  return decorateTextPrim(editor, VSCode.StringOr.make({
                  TAG: "String",
                  _0: color,
                  [Symbol.for("name")]: "String"
                }), ranges);
}

function overlayTextPrim(editor, color, text, range) {
  var after = {
    color: color,
    contentText: text
  };
  var options = {
    after: after
  };
  var decoration = Vscode.window.createTextEditorDecorationType(options);
  decorate(editor, decoration, [range]);
  return decoration;
}

function overlayText(editor, style, text, range) {
  return overlayTextPrim(editor, VSCode.StringOr.make({
                  TAG: "Others",
                  _0: new Vscode.ThemeColor(style),
                  [Symbol.for("name")]: "Others"
                }), text, range);
}

function overlayTextWithColor(editor, color, text, range) {
  return overlayTextPrim(editor, VSCode.StringOr.make({
                  TAG: "String",
                  _0: color,
                  [Symbol.for("name")]: "String"
                }), text, range);
}

function underlineText(editor, range) {
  var options = {
    rangeBehavior: 3,
    textDecoration: "underline dotted"
  };
  var decoration = Vscode.window.createTextEditorDecorationType(options);
  decorate(editor, decoration, [range]);
  return decoration;
}

function destroy(prim) {
  prim.dispose();
}

var Decoration = {
  decorate: decorate,
  highlightBackgroundPrim: highlightBackgroundPrim,
  highlightBackground: highlightBackground,
  highlightBackgroundWithColor: highlightBackgroundWithColor,
  decorateTextPrim: decorateTextPrim,
  decorateText: decorateText,
  decorateTextWithColor: decorateTextWithColor,
  overlayTextPrim: overlayTextPrim,
  overlayText: overlayText,
  overlayTextWithColor: overlayTextWithColor,
  underlineText: underlineText,
  destroy: destroy
};

function set(editor, point) {
  var selection = new Vscode.Selection(point, point);
  editor.selection = selection;
}

function setMany(editor, points) {
  var selections = points.map(function (point) {
        return new Vscode.Selection(point, point);
      });
  editor.selections = selections;
}

function get(editor) {
  return editor.selection.active;
}

function getMany(editor) {
  return editor.selections.map(function (prim) {
              return prim.active;
            });
}

var Cursor = {
  set: set,
  setMany: setMany,
  get: get,
  getMany: getMany
};

function set$1(editor, range) {
  var selection = new Vscode.Selection(range.start, range.end);
  editor.selection = selection;
}

function setMany$1(editor, ranges) {
  var selections = ranges.map(function (range) {
        return new Vscode.Selection(range.start, range.end);
      });
  editor.selections = selections;
}

function get$1(editor) {
  var selection = editor.selection;
  return new Vscode.Range(selection.start, selection.end);
}

function getMany$1(editor) {
  return editor.selections.map(function (selection) {
              return new Vscode.Range(selection.start, selection.end);
            });
}

var $$Selection = {
  set: set$1,
  setMany: setMany$1,
  get: get$1,
  getMany: getMany$1
};

function get$2($$document, range) {
  return $$document.getText(Caml_option.some(range));
}

function getAll($$document) {
  return $$document.getText(undefined);
}

function replace($$document, range, text) {
  var workspaceEdit = new Vscode.WorkspaceEdit();
  workspaceEdit.replace($$document.uri, range, text, undefined);
  return Vscode.workspace.applyEdit(workspaceEdit);
}

function batchReplace($$document, replacements) {
  var workspaceEdit = new Vscode.WorkspaceEdit();
  replacements.forEach(function (param) {
        workspaceEdit.replace($$document.uri, param[0], param[1], undefined);
      });
  return Vscode.workspace.applyEdit(workspaceEdit);
}

function insert($$document, point, text) {
  var workspaceEdit = new Vscode.WorkspaceEdit();
  workspaceEdit.insert($$document.uri, point, text, undefined);
  return Vscode.workspace.applyEdit(workspaceEdit);
}

function batchInsert($$document, points, text) {
  var workspaceEdit = new Vscode.WorkspaceEdit();
  var textEdits = points.map(function (point) {
        return Vscode.TextEdit.insert(point, text);
      });
  workspaceEdit.set($$document.uri, textEdits);
  return Vscode.workspace.applyEdit(workspaceEdit);
}

function $$delete($$document, range) {
  var workspaceEdit = new Vscode.WorkspaceEdit();
  workspaceEdit.delete($$document.uri, range, undefined);
  return Vscode.workspace.applyEdit(workspaceEdit);
}

var $$Text = {
  get: get$2,
  getAll: getAll,
  replace: replace,
  batchReplace: batchReplace,
  insert: insert,
  batchInsert: batchInsert,
  $$delete: $$delete
};

function focus($$document) {
  Vscode.window.showTextDocument($$document, 1, undefined);
}

function reveal(editor, range) {
  editor.revealRange(range, 2);
}

var documentSelector = [
  VSCode.StringOr.make({
        TAG: "String",
        _0: "agda",
        [Symbol.for("name")]: "String"
      }),
  VSCode.StringOr.make({
        TAG: "String",
        _0: "lagda-markdown",
        [Symbol.for("name")]: "String"
      }),
  VSCode.StringOr.make({
        TAG: "String",
        _0: "lagda-rst",
        [Symbol.for("name")]: "String"
      }),
  VSCode.StringOr.make({
        TAG: "String",
        _0: "lagda-typst",
        [Symbol.for("name")]: "String"
      }),
  VSCode.StringOr.make({
        TAG: "String",
        _0: "lagda-tex",
        [Symbol.for("name")]: "String"
      })
];

function registerDefinitionProvider(definitionProvider) {
  return Vscode.languages.registerDefinitionProvider(documentSelector, {
              provideDefinition: (function (textDocument, point, param) {
                  return VSCode.ProviderResult.map(definitionProvider(textDocument.fileName, point), (function (pairs) {
                                return VSCode.LocationLinkOrLocation.locationLinks(pairs.map(function (param) {
                                                var targetPos = param[2];
                                                return {
                                                        originSelectionRange: Caml_option.some(param[0]),
                                                        targetRange: new Vscode.Range(targetPos, targetPos),
                                                        targetSelectionRange: undefined,
                                                        targetUri: Vscode.Uri.file(param[1])
                                                      };
                                              }));
                              }));
                })
            });
}

function registerHoverProvider(hoverProvider) {
  return Vscode.languages.registerHoverProvider(documentSelector, {
              provideHover: (function (textDocument, point, param) {
                  return VSCode.ProviderResult.map(hoverProvider(textDocument.fileName, point), (function (param) {
                                var markdownStrings = param[0].map(function (string) {
                                      return new Vscode.MarkdownString(string, true);
                                    });
                                return new Vscode.Hover(markdownStrings, param[1]);
                              }));
                })
            });
}

var SemanticsTokens = {};

var SemanticTokensEdit = {};

var SemanticTokensEdits = {};

var SemanticTokensLegend = {};

var SemanticTokensBuilder = {};

function make(provideDocumentSemanticTokens, provideDocumentSemanticTokensEdits, param) {
  return {
          provideDocumentSemanticTokens: provideDocumentSemanticTokens,
          provideDocumentSemanticTokensEdits: provideDocumentSemanticTokensEdits
        };
}

var DocumentSemanticTokensProvider = {
  make: make
};

var Languages = {};

var Mock = {
  SemanticsTokens: SemanticsTokens,
  SemanticTokensEdit: SemanticTokensEdit,
  SemanticTokensEdits: SemanticTokensEdits,
  SemanticTokensLegend: SemanticTokensLegend,
  SemanticTokensBuilder: SemanticTokensBuilder,
  DocumentSemanticTokensProvider: DocumentSemanticTokensProvider,
  Languages: Languages
};

function registerDocumentSemanticTokensProvider(provideDocumentSemanticTokens, param) {
  var documentSemanticTokensProvider_provideDocumentSemanticTokens = provideDocumentSemanticTokens;
  var documentSemanticTokensProvider = {
    provideDocumentSemanticTokens: documentSemanticTokensProvider_provideDocumentSemanticTokens,
    provideDocumentSemanticTokensEdits: undefined
  };
  var semanticTokensLegend = new Vscode.SemanticTokensLegend(param[0], param[1]);
  return Vscode.languages.registerDocumentSemanticTokensProvider(documentSelector, documentSemanticTokensProvider, semanticTokensLegend);
}

var Provider = {
  documentSelector: documentSelector,
  registerDefinitionProvider: registerDefinitionProvider,
  registerHoverProvider: registerHoverProvider,
  Mock: Mock,
  registerDocumentSemanticTokensProvider: registerDocumentSemanticTokensProvider
};

function toCodepointOffset($$document, offset) {
  var range = new Vscode.Range(new Vscode.Position(0, 0), $$document.positionAt(offset));
  var text = $$document.getText(Caml_option.some(range));
  return Agda$AgdaModeVscode.OffsetConverter.characterWidth(text);
}

var VSRange;

exports.VSRange = VSRange;
exports.Position = Position;
exports.$$Range = $$Range;
exports.Decoration = Decoration;
exports.Cursor = Cursor;
exports.$$Selection = $$Selection;
exports.$$Text = $$Text;
exports.focus = focus;
exports.reveal = reveal;
exports.Provider = Provider;
exports.toCodepointOffset = toCodepointOffset;
/* documentSelector Not a pure module */
