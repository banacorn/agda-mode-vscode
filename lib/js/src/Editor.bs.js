// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var VSCode = require("rescript-vscode/lib/js/src/VSCode.bs.js");
var Vscode = require("vscode");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Agda$AgdaModeVscode = require("./Agda.bs.js");
var Highlighting$AgdaModeVscode = require("./Highlighting.bs.js");

function fromOffset($$document, offset) {
  return $$document.positionAt(offset);
}

function toOffset($$document, position) {
  return $$document.offsetAt(position);
}

function fromAgdaPosition(position) {
  return new Vscode.Position(position.line - 1 | 0, position.col - 1 | 0);
}

var Position = {
  fromOffset: fromOffset,
  toOffset: toOffset,
  fromAgdaPosition: fromAgdaPosition
};

function fromInterval($$document, interval) {
  return new Vscode.Range($$document.positionAt(interval[0]), $$document.positionAt(interval[1]));
}

function toInterval($$document, range) {
  return [
          $$document.offsetAt(range.start),
          $$document.offsetAt(range.end)
        ];
}

function fromAgdaInterval(range) {
  return new Vscode.Range(fromAgdaPosition(range.start), fromAgdaPosition(range.end_));
}

var $$Range = {
  fromInterval: fromInterval,
  toInterval: toInterval,
  fromAgdaInterval: fromAgdaInterval
};

function decorate(editor, decoration, ranges) {
  editor.setDecorations(decoration, ranges);
  
}

function highlightBackgroundPrim(editor, backgroundColor, ranges) {
  var rangeBehavior = VSCode.DecorationRangeBehavior.toEnum(/* ClosedClosed */1);
  var options = {
    backgroundColor: backgroundColor,
    rangeBehavior: rangeBehavior
  };
  var decoration = Vscode.window.createTextEditorDecorationType(options);
  decorate(editor, decoration, ranges);
  return decoration;
}

function highlightBackground(editor, style, ranges) {
  return highlightBackgroundPrim(editor, VSCode.StringOr.others(new Vscode.ThemeColor(style)), ranges);
}

function highlightBackgroundWithColor(editor, color, ranges) {
  return highlightBackgroundPrim(editor, VSCode.StringOr.string(color), ranges);
}

function decorateTextPrim(editor, color, ranges) {
  var rangeBehavior = VSCode.DecorationRangeBehavior.toEnum(/* ClosedClosed */1);
  var options = {
    color: color,
    rangeBehavior: rangeBehavior
  };
  var decoration = Vscode.window.createTextEditorDecorationType(options);
  decorate(editor, decoration, ranges);
  return decoration;
}

function decorateText(editor, style, ranges) {
  return decorateTextPrim(editor, VSCode.StringOr.others(new Vscode.ThemeColor(style)), ranges);
}

function decorateTextWithColor(editor, color, ranges) {
  return decorateTextPrim(editor, VSCode.StringOr.string(color), ranges);
}

function overlayTextPrim(editor, color, text, range) {
  var after = {
    color: color,
    contentText: text
  };
  var options = {
    after: after
  };
  var decoration = Vscode.window.createTextEditorDecorationType(options);
  decorate(editor, decoration, [range]);
  return decoration;
}

function overlayText(editor, style, text, range) {
  return overlayTextPrim(editor, VSCode.StringOr.others(new Vscode.ThemeColor(style)), text, range);
}

function overlayTextWithColor(editor, color, text, range) {
  return overlayTextPrim(editor, VSCode.StringOr.string(color), text, range);
}

function underlineText(editor, range) {
  var rangeBehavior = VSCode.DecorationRangeBehavior.toEnum(/* ClosedOpen */3);
  var options = {
    rangeBehavior: rangeBehavior,
    textDecoration: "underline dotted"
  };
  var decoration = Vscode.window.createTextEditorDecorationType(options);
  decorate(editor, decoration, [range]);
  return decoration;
}

function destroy(prim) {
  prim.dispose();
  
}

var Decoration = {
  decorate: decorate,
  highlightBackgroundPrim: highlightBackgroundPrim,
  highlightBackground: highlightBackground,
  highlightBackgroundWithColor: highlightBackgroundWithColor,
  decorateTextPrim: decorateTextPrim,
  decorateText: decorateText,
  decorateTextWithColor: decorateTextWithColor,
  overlayTextPrim: overlayTextPrim,
  overlayText: overlayText,
  overlayTextWithColor: overlayTextWithColor,
  underlineText: underlineText,
  destroy: destroy
};

function set(editor, point) {
  var selection = new Vscode.Selection(point, point);
  editor.selection = selection;
  
}

function setMany(editor, points) {
  var selections = Belt_Array.map(points, (function (point) {
          return new Vscode.Selection(point, point);
        }));
  editor.selections = selections;
  
}

function get(editor) {
  return editor.selection.active;
}

function getMany(editor) {
  return Belt_Array.map(editor.selections, (function (prim) {
                return prim.active;
              }));
}

var Cursor = {
  set: set,
  setMany: setMany,
  get: get,
  getMany: getMany
};

function set$1(editor, range) {
  var selection = new Vscode.Selection(range.start, range.end);
  editor.selection = selection;
  
}

function setMany$1(editor, ranges) {
  var selections = Belt_Array.map(ranges, (function (range) {
          return new Vscode.Selection(range.start, range.end);
        }));
  editor.selections = selections;
  
}

function get$1(editor) {
  var selection = editor.selection;
  return new Vscode.Range(selection.start, selection.end);
}

function getMany$1(editor) {
  return Belt_Array.map(editor.selections, (function (selection) {
                return new Vscode.Range(selection.start, selection.end);
              }));
}

var $$Selection = {
  set: set$1,
  setMany: setMany$1,
  get: get$1,
  getMany: getMany$1
};

function get$2($$document, range) {
  return $$document.getText(Caml_option.some(range));
}

function getAll($$document) {
  return $$document.getText(undefined);
}

function replace($$document, range, text) {
  var workspaceEdit = new Vscode.WorkspaceEdit();
  workspaceEdit.replace($$document.uri, range, text, undefined);
  return Vscode.workspace.applyEdit(workspaceEdit);
}

function batchReplace($$document, replacements) {
  var workspaceEdit = new Vscode.WorkspaceEdit();
  Belt_Array.forEach(replacements, (function (param) {
          workspaceEdit.replace($$document.uri, param[0], param[1], undefined);
          
        }));
  return Vscode.workspace.applyEdit(workspaceEdit);
}

function batchReplace$p(editor, replacements) {
  return editor.edit((function (editBuilder) {
                return Belt_Array.forEach(replacements, (function (param) {
                              editBuilder.replace(param[0], param[1]);
                              
                            }));
              }), undefined);
}

function insert($$document, point, text) {
  var workspaceEdit = new Vscode.WorkspaceEdit();
  workspaceEdit.insert($$document.uri, point, text, undefined);
  return Vscode.workspace.applyEdit(workspaceEdit);
}

function batchInsert($$document, points, text) {
  var workspaceEdit = new Vscode.WorkspaceEdit();
  var textEdits = Belt_Array.map(points, (function (point) {
          return Vscode.TextEdit.insert(point, text);
        }));
  workspaceEdit.set($$document.uri, textEdits);
  return Vscode.workspace.applyEdit(workspaceEdit);
}

function batchInsert$p(editor, points, text) {
  return editor.edit((function (editBuilder) {
                return Belt_Array.forEach(points, (function (point) {
                              editBuilder.insert(point, text);
                              
                            }));
              }), undefined);
}

function $$delete($$document, range) {
  var workspaceEdit = new Vscode.WorkspaceEdit();
  workspaceEdit.delete($$document.uri, range, undefined);
  return Vscode.workspace.applyEdit(workspaceEdit);
}

var $$Text = {
  get: get$2,
  getAll: getAll,
  replace: replace,
  batchReplace: batchReplace,
  batchReplace$p: batchReplace$p,
  insert: insert,
  batchInsert: batchInsert,
  batchInsert$p: batchInsert$p,
  $$delete: $$delete
};

function focus($$document) {
  Vscode.window.showTextDocument($$document, /* Beside */1, undefined);
  
}

function reveal(editor, range) {
  return VSCode.TextEditor.revealRange(editor, range, /* InCenterIfOutsideViewport */3);
}

var documentSelector = [VSCode.StringOr.string("agda")];

function registerDefinitionProvider(definitionProvider) {
  return Vscode.languages.registerDefinitionProvider(documentSelector, {
              provideDefinition: (function (textDocument, point, param) {
                  return VSCode.ProviderResult.map(Curry._2(definitionProvider, textDocument.fileName, point), (function (pairs) {
                                return VSCode.LocationLinkOrLocation.locationLinks(Belt_Array.map(pairs, (function (param) {
                                                  var targetPos = param[2];
                                                  return {
                                                          originSelectionRange: Caml_option.some(param[0]),
                                                          targetRange: new Vscode.Range(targetPos, targetPos),
                                                          targetSelectionRange: undefined,
                                                          targetUri: Vscode.Uri.file(param[1])
                                                        };
                                                })));
                              }));
                })
            });
}

function registerHoverProvider(hoverProvider) {
  return Vscode.languages.registerHoverProvider(documentSelector, {
              provideHover: (function (textDocument, point, param) {
                  return VSCode.ProviderResult.map(Curry._2(hoverProvider, textDocument.fileName, point), (function (param) {
                                var markdownStrings = Belt_Array.map(param[0], (function (string) {
                                        return new Vscode.MarkdownString(string, true);
                                      }));
                                return new Vscode.Hover(markdownStrings, param[1]);
                              }));
                })
            });
}

var SemanticsTokens = {};

var SemanticTokensEdit = {};

var SemanticTokensEdits = {};

var SemanticTokensLegend = {};

var SemanticTokensBuilder = {};

function make(provideDocumentSemanticTokens, provideDocumentSemanticTokensEdits, param) {
  return {
          provideDocumentSemanticTokens: provideDocumentSemanticTokens,
          provideDocumentSemanticTokensEdits: provideDocumentSemanticTokensEdits
        };
}

var DocumentSemanticTokensProvider = {
  make: make
};

var Languages = {};

var Mock = {
  SemanticsTokens: SemanticsTokens,
  SemanticTokensEdit: SemanticTokensEdit,
  SemanticTokensEdits: SemanticTokensEdits,
  SemanticTokensLegend: SemanticTokensLegend,
  SemanticTokensBuilder: SemanticTokensBuilder,
  DocumentSemanticTokensProvider: DocumentSemanticTokensProvider,
  Languages: Languages
};

function registerDocumentSemanticTokensProvider(provider, param) {
  var semanticTokensLegend = new Vscode.SemanticTokensLegend(param[0], param[1]);
  var documentSemanticTokensProvider_provideDocumentSemanticTokens = (function (textDocument, _cancel) {
      var builder = new Vscode.SemanticTokensBuilder(semanticTokensLegend);
      var pushLegend = function (range, tokenType, tokenModifiers) {
        builder.push(range, Curry._1(Highlighting$AgdaModeVscode.Aspect.TokenType.toString, tokenType), Belt_Option.map(tokenModifiers, (function (xs) {
                    return Belt_Array.map(xs, Highlighting$AgdaModeVscode.Aspect.TokenModifier.toString);
                  })));
        
      };
      return VSCode.ProviderResult.map(Curry._2(provider, textDocument.fileName, pushLegend), (function (param) {
                    return builder.build();
                  }));
    });
  var documentSemanticTokensProvider_provideDocumentSemanticTokensEdits = (function (textDocument, _previousResultID, _cancel) {
      var builder = new Vscode.SemanticTokensBuilder(semanticTokensLegend);
      var pushLegend = function (range, tokenType, tokenModifiers) {
        builder.push(range, Curry._1(Highlighting$AgdaModeVscode.Aspect.TokenType.toString, tokenType), Belt_Option.map(tokenModifiers, (function (xs) {
                    return Belt_Array.map(xs, Highlighting$AgdaModeVscode.Aspect.TokenModifier.toString);
                  })));
        
      };
      return VSCode.ProviderResult.map(Curry._2(provider, textDocument.fileName, pushLegend), (function (param) {
                    return {
                            NAME: "SemanticsTokens",
                            VAL: builder.build()
                          };
                  }));
    });
  var documentSemanticTokensProvider = {
    provideDocumentSemanticTokens: documentSemanticTokensProvider_provideDocumentSemanticTokens,
    provideDocumentSemanticTokensEdits: documentSemanticTokensProvider_provideDocumentSemanticTokensEdits
  };
  return Vscode.languages.registerDocumentSemanticTokensProvider(documentSelector, documentSemanticTokensProvider, semanticTokensLegend);
}

var Provider = {
  documentSelector: documentSelector,
  registerDefinitionProvider: registerDefinitionProvider,
  registerHoverProvider: registerHoverProvider,
  Mock: Mock,
  registerDocumentSemanticTokensProvider: registerDocumentSemanticTokensProvider
};

function toUTF8Offset($$document, offset) {
  var range = new Vscode.Range(new Vscode.Position(0, 0), $$document.positionAt(offset));
  return Agda$AgdaModeVscode.OffsetConverter.characterWidth($$document.getText(Caml_option.some(range)));
}

var VSRange;

exports.VSRange = VSRange;
exports.Position = Position;
exports.$$Range = $$Range;
exports.Decoration = Decoration;
exports.Cursor = Cursor;
exports.$$Selection = $$Selection;
exports.$$Text = $$Text;
exports.focus = focus;
exports.reveal = reveal;
exports.Provider = Provider;
exports.toUTF8Offset = toUTF8Offset;
/* documentSelector Not a pure module */
