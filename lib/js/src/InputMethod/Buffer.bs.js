// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Caml = require("rescript/lib/js/caml.js");
var Js_string = require("rescript/lib/js/js_string.js");
var Translator$AgdaModeVscode = require("./Translator.bs.js");

function make(param) {
  return {
          symbol: undefined,
          tail: "",
          translation: Translator$AgdaModeVscode.translate("", undefined),
          candidateIndex: 0
        };
}

function isEmpty(self) {
  if (self.symbol === undefined) {
    return self.tail === "";
  } else {
    return false;
  }
}

function toSequence(self) {
  var match = self.symbol;
  if (match !== undefined) {
    return match[1] + self.tail;
  } else {
    return self.tail;
  }
}

function toSurface(self) {
  var match = self.symbol;
  if (match !== undefined) {
    return match[0] + self.tail;
  } else {
    return self.tail;
  }
}

function toString(self) {
  return "\"" + (toSurface(self) + ("\"[" + (toSequence(self) + "]")));
}

function moveUp(self) {
  return {
          symbol: self.symbol,
          tail: self.tail,
          translation: self.translation,
          candidateIndex: Caml.int_max(0, self.candidateIndex - 10 | 0)
        };
}

function moveRight(self) {
  return {
          symbol: self.symbol,
          tail: self.tail,
          translation: self.translation,
          candidateIndex: Caml.int_min(self.translation.candidateSymbols.length - 1 | 0, self.candidateIndex + 1 | 0)
        };
}

function moveDown(self) {
  return {
          symbol: self.symbol,
          tail: self.tail,
          translation: self.translation,
          candidateIndex: Caml.int_min(self.translation.candidateSymbols.length - 1 | 0, self.candidateIndex + 10 | 0)
        };
}

function moveLeft(self) {
  return {
          symbol: self.symbol,
          tail: self.tail,
          translation: self.translation,
          candidateIndex: Caml.int_max(0, self.candidateIndex - 1 | 0)
        };
}

function update(self, start, change) {
  var sequence = toSequence(self);
  var insertStartInTextEditor = change.offset - start | 0;
  var match = self.symbol;
  var insertStart = match !== undefined ? (insertStartInTextEditor + match[1].length | 0) - match[0].length | 0 : insertStartInTextEditor;
  var insertEnd = insertStart + change.replacedTextLength | 0;
  var beforeInsertedText = Js_string.substring(0, insertStart, sequence);
  var afterInsertedText = Js_string.substringToEnd(insertEnd, sequence);
  var newSequence = beforeInsertedText + (change.insertedText + afterInsertedText);
  var translation = Translator$AgdaModeVscode.translate(newSequence, {
        lastTranslation: self.translation,
        candidateIndex: self.candidateIndex
      });
  var symbol = translation.symbol;
  if (symbol !== undefined) {
    var buffer_symbol = [
      symbol,
      newSequence
    ];
    var buffer_candidateIndex = self.candidateIndex;
    var buffer = {
      symbol: buffer_symbol,
      tail: "",
      translation: translation,
      candidateIndex: buffer_candidateIndex
    };
    return [
            buffer,
            toSurface(buffer)
          ];
  }
  if (translation.further) {
    if (Js_string.includes(sequence, newSequence)) {
      var diff = Js_string.substringToEnd(sequence.length, newSequence);
      var buffer_symbol$1 = self.symbol;
      var buffer_tail = self.tail + diff;
      var buffer_candidateIndex$1 = self.candidateIndex;
      var buffer$1 = {
        symbol: buffer_symbol$1,
        tail: buffer_tail,
        translation: translation,
        candidateIndex: buffer_candidateIndex$1
      };
      return [
              buffer$1,
              undefined
            ];
    }
    var buffer_candidateIndex$2 = self.candidateIndex;
    var buffer$2 = {
      symbol: undefined,
      tail: newSequence,
      translation: translation,
      candidateIndex: buffer_candidateIndex$2
    };
    return [
            buffer$2,
            toSurface(buffer$2)
          ];
  }
  var buffer_symbol$2 = self.symbol;
  var buffer_tail$1 = self.tail;
  var buffer_candidateIndex$3 = self.candidateIndex;
  var buffer$3 = {
    symbol: buffer_symbol$2,
    tail: buffer_tail$1,
    translation: translation,
    candidateIndex: buffer_candidateIndex$3
  };
  return [
          buffer$3,
          undefined
        ];
}

exports.make = make;
exports.isEmpty = isEmpty;
exports.toSequence = toSequence;
exports.toSurface = toSurface;
exports.toString = toString;
exports.moveUp = moveUp;
exports.moveRight = moveRight;
exports.moveDown = moveDown;
exports.moveLeft = moveLeft;
exports.update = update;
/* Translator-AgdaModeVscode Not a pure module */
