// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Caml = require("rescript/lib/js/caml.js");
var Js_dict = require("rescript/lib/js/js_dict.js");
var Belt_Int = require("rescript/lib/js/belt_Int.js");
var Js_string = require("rescript/lib/js/js_string.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Json_decode = require("@glennsl/bs-json/lib/js/src/Json_decode.bs.js");
var Json_encode = require("@glennsl/bs-json/lib/js/src/Json_encode.bs.js");
var QueryJs = require("./../../../../asset/query.js").default;
var KeymapJs = require("./../../../../asset/keymap.js").default;

var rawTable = QueryJs;

var rawKeymapObject = KeymapJs;

function fromObject(obj) {
  var symbols = (obj[">>"] || []);
  var subTrie = Js_dict.fromArray(Belt_Array.map(Belt_Array.keep(Object.keys(obj), (function (key) {
                  return key !== ">>";
                })), (function (key) {
              return [
                      key,
                      fromObject((obj[key]))
                    ];
            })));
  return {
          symbols: symbols,
          subTrie: subTrie
        };
}

var keymap = fromObject(rawKeymapObject);

function toKeySuggestions(trie) {
  return Object.keys(trie.subTrie);
}

function toCandidateSymbols(trie) {
  return trie.symbols;
}

function isInKeymap(input) {
  var _input = input;
  var _trie = keymap;
  while(true) {
    var trie = _trie;
    var input$1 = _input;
    var n = input$1.length;
    if (n === 0) {
      return trie;
    }
    var key = Js_string.substrAtMost(0, 1, input$1);
    var rest = Js_string.substrAtMost(1, n - 1 | 0, input$1);
    var trie$p = Js_dict.get(trie.subTrie, key);
    if (trie$p === undefined) {
      return ;
    }
    _trie = trie$p;
    _input = rest;
    continue ;
  };
}

function decode(json) {
  return {
          symbol: Json_decode.field("symbol", (function (param) {
                  return Json_decode.optional(Json_decode.string, param);
                }), json),
          further: Json_decode.field("further", Json_decode.bool, json),
          keySuggestions: Json_decode.field("keySuggestions", (function (param) {
                  return Json_decode.array(Json_decode.string, param);
                }), json),
          candidateSymbols: Json_decode.field("candidateSymbols", (function (param) {
                  return Json_decode.array(Json_decode.string, param);
                }), json)
        };
}

function encode(translation) {
  return Json_encode.object_({
              hd: [
                "symbol",
                Json_encode.nullable((function (prim) {
                        return prim;
                      }), translation.symbol)
              ],
              tl: {
                hd: [
                  "further",
                  translation.further
                ],
                tl: {
                  hd: [
                    "keySuggestions",
                    Json_encode.array((function (prim) {
                            return prim;
                          }), translation.keySuggestions)
                  ],
                  tl: {
                    hd: [
                      "candidateSymbols",
                      Json_encode.array((function (prim) {
                              return prim;
                            }), translation.candidateSymbols)
                    ],
                    tl: /* [] */0
                  }
                }
              }
            });
}

function translate(input, state) {
  var trie = isInKeymap(input);
  var keySuggestions = Belt_Option.mapWithDefault(trie, [], toKeySuggestions);
  var further = keySuggestions.length !== 0;
  var candidateSymbols = Belt_Option.mapWithDefault(trie, [], toCandidateSymbols);
  var symbol = Belt_Array.get(candidateSymbols, 0);
  var last = Belt_Int.fromString(Js_string.sliceToEnd(-1, input));
  if (!(Belt_Option.isSome(last) && symbol === undefined && Belt_Option.isSome(state) && Belt_Option.getExn(state).lastTranslation.candidateSymbols.length !== 0)) {
    return {
            symbol: symbol,
            further: further,
            keySuggestions: keySuggestions,
            candidateSymbols: candidateSymbols
          };
  }
  var state$1 = Belt_Option.getExn(state);
  var cycle_Zplus = function (n) {
    if (n === 0) {
      return 9;
    } else {
      return n - 1 | 0;
    }
  };
  var index = cycle_Zplus(Belt_Option.getExn(last)) + Math.imul(state$1.candidateIndex / 10 | 0, 10) | 0;
  return {
          symbol: Belt_Array.get(state$1.lastTranslation.candidateSymbols, Caml.int_min(index, state$1.lastTranslation.candidateSymbols.length - 1 | 0)),
          further: further,
          keySuggestions: keySuggestions,
          candidateSymbols: candidateSymbols
        };
}

function initialTranslation(param) {
  return translate("", param);
}

function lookup(symbol) {
  return Belt_Option.flatMap(Belt_Option.map(Js_string.codePointAt(0, symbol), (function (prim) {
                    return String(prim);
                  })), (function (param) {
                return Js_dict.get(rawTable, param);
              }));
}

exports.rawTable = rawTable;
exports.rawKeymapObject = rawKeymapObject;
exports.fromObject = fromObject;
exports.keymap = keymap;
exports.toKeySuggestions = toKeySuggestions;
exports.toCandidateSymbols = toCandidateSymbols;
exports.isInKeymap = isInKeymap;
exports.decode = decode;
exports.encode = encode;
exports.translate = translate;
exports.initialTranslation = initialTranslation;
exports.lookup = lookup;
/* rawTable Not a pure module */
