// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Caml = require("rescript/lib/js/caml.js");
var Vscode = require("vscode");
var Core__List = require("@rescript/core/lib/js/src/Core__List.bs.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Core__Array = require("@rescript/core/lib/js/src/Core__Array.bs.js");
var Core__Option = require("@rescript/core/lib/js/src/Core__Option.bs.js");
var Chan$AgdaModeVscode = require("../Util/Chan.bs.js");
var Util$AgdaModeVscode = require("../Util/Util.bs.js");
var Buffer$AgdaModeVscode = require("./Buffer.bs.js");
var Common$AgdaModeVscode = require("../View/Common.bs.js");
var Editor$AgdaModeVscode = require("../Editor.bs.js");

function fromTextDocumentChangeEvent(editor, $$event) {
  var fileName = editor.document.fileName;
  var eventFileName = $$event.document.fileName;
  if (fileName === eventFileName) {
    return $$event.contentChanges.map(function (change) {
                return {
                        offset: change.rangeOffset,
                        insertedText: change.text,
                        replacedTextLength: change.rangeLength
                      };
              });
  } else {
    return [];
  }
}

var Input = {
  fromTextDocumentChangeEvent: fromTextDocumentChangeEvent
};

var Output = {};

function fromOutput(xs) {
  return xs.map(function (x) {
              if (typeof x !== "object") {
                if (x === "Activate") {
                  return "Activate";
                } else {
                  return "Deactivate";
                }
              } else if (x.TAG === "UpdateView") {
                return "UpdateView";
              } else {
                return {
                        TAG: "RewriteIssued",
                        _0: x._0.map(function (param) {
                              var range = param[0];
                              return [
                                      [
                                        [
                                          range.start.line,
                                          range.start.character
                                        ],
                                        [
                                          range.start.line,
                                          range.end.character
                                        ]
                                      ],
                                      param[1]
                                    ];
                            })
                      };
              }
            });
}

var Log = {
  fromOutput: fromOutput
};

function withIn(instance, offset) {
  return Common$AgdaModeVscode.Interval.contains(instance.interval, offset);
}

function destroy(instance) {
  Core__Option.forEach(instance.decoration, Editor$AgdaModeVscode.Decoration.destroy);
}

function logOutput(self, output) {
  if (output.length > 0) {
    return Chan$AgdaModeVscode.emit(self.chanLog, fromOutput(output));
  }
  
}

function make(chanLog) {
  return {
          instances: [],
          activated: false,
          semaphore: false,
          chanLog: chanLog
        };
}

function validateCursorPositions(instances, intervals) {
  return instances.filter(function (instance) {
              var survived = intervals.some(function (param) {
                    if (withIn(instance, param[0])) {
                      return withIn(instance, param[1]);
                    } else {
                      return false;
                    }
                  });
              if (!survived) {
                destroy(instance);
              }
              return survived;
            });
}

function toRewrites(instances, modify) {
  var accum = {
    contents: 0
  };
  return Core__Array.filterMap(instances, (function (instance) {
                var match = instance.interval;
                var end_ = match[1];
                var start = match[0];
                instance.interval = [
                  start + accum.contents | 0,
                  end_ + accum.contents | 0
                ];
                return Core__Option.map(modify(instance), (function (replacement) {
                              var delta = replacement.length - (end_ - start | 0) | 0;
                              accum.contents = accum.contents + delta | 0;
                              instance.interval = [
                                instance.interval[0],
                                instance.interval[1] + delta | 0
                              ];
                              return {
                                      interval: instance.interval,
                                      text: replacement,
                                      instance: instance
                                    };
                            }));
              }));
}

function groupChangeWithInstances(instances, changes) {
  changes.sort(function (x, y) {
        return Caml.int_compare(x.offset, y.offset);
      });
  var go = function (_accum, _x) {
    while(true) {
      var x = _x;
      var accum = _accum;
      var match = x[0];
      if (match) {
        var match$1 = x[1];
        if (!match$1) {
          return /* [] */0;
        }
        var is = match$1.tl;
        var instance = match$1.hd;
        var cs = match.tl;
        var change = match.hd;
        var match$2 = instance.interval;
        var end_ = match$2[1];
        var start = match$2[0];
        var delta = change.insertedText.length - change.replacedTextLength | 0;
        if (withIn(instance, change.offset)) {
          instance.interval = [
            accum + start | 0,
            (accum + end_ | 0) + delta | 0
          ];
          return {
                  hd: [
                    instance,
                    {
                      offset: change.offset + accum | 0,
                      insertedText: change.insertedText,
                      replacedTextLength: change.replacedTextLength
                    }
                  ],
                  tl: go(accum + delta | 0, [
                        cs,
                        is
                      ])
                };
        }
        if (change.offset < instance.interval[0]) {
          _x = [
            cs,
            {
              hd: instance,
              tl: is
            }
          ];
          _accum = accum + delta | 0;
          continue ;
        }
        instance.interval = [
          accum + start | 0,
          accum + end_ | 0
        ];
        return {
                hd: [
                  instance,
                  undefined
                ],
                tl: go(accum, [
                      {
                        hd: change,
                        tl: cs
                      },
                      is
                    ])
              };
      }
      var match$3 = x[1];
      if (match$3) {
        return Core__List.map({
                    hd: match$3.hd,
                    tl: match$3.tl
                  }, (function (i) {
                      return [
                              i,
                              undefined
                            ];
                    }));
      } else {
        return /* [] */0;
      }
    };
  };
  return Core__List.toArray(go(0, [
                  Core__List.fromArray(changes),
                  Core__List.fromArray(instances)
                ]));
}

function updateInstances(instances, changes) {
  var instancesWithChanges = groupChangeWithInstances(instances, changes);
  var rewrites = [];
  var accum = {
    contents: 0
  };
  var instances$1 = Core__Array.filterMap(instancesWithChanges, (function (param) {
          var change = param[1];
          var instance = param[0];
          if (change === undefined) {
            return instance;
          }
          var match = Buffer$AgdaModeVscode.update(instance.buffer, instance.interval[0], change);
          var buffer = match[0];
          Core__Option.forEach(match[1], (function (text) {
                  var match = instance.interval;
                  var end_ = match[1];
                  var start = match[0];
                  var delta = text.length - (end_ - start | 0) | 0;
                  instance.interval = [
                    start + accum.contents | 0,
                    (end_ + accum.contents | 0) + delta | 0
                  ];
                  rewrites.push({
                        interval: [
                          start,
                          end_
                        ],
                        text: text,
                        instance: buffer.translation.further ? instance : undefined
                      });
                  accum.contents = accum.contents + delta | 0;
                }));
          var intervalLengthIs0 = instance.interval[0] === instance.interval[1];
          var numberOfCandidateSymbols = buffer.translation.candidateSymbols.length;
          var shouldDestroy = intervalLengthIs0 || !buffer.translation.further && numberOfCandidateSymbols <= 1;
          if (shouldDestroy) {
            destroy(instance);
            return ;
          } else {
            instance.buffer = buffer;
            return instance;
          }
        }));
  return [
          instances$1,
          rewrites
        ];
}

function bufferIsEmpty(im) {
  return im.instances.every(function (instance) {
              return Buffer$AgdaModeVscode.isEmpty(instance.buffer);
            });
}

function isActivated(self) {
  return self.activated;
}

function deactivate(self) {
  self.instances.forEach(destroy);
  self.instances = [];
  self.activated = false;
}

function applyRewrites(self, editor, rewrites) {
  self.semaphore = true;
  var replacementRanges = rewrites.map(function (param) {
        var interval = param.interval;
        return [
                editor !== undefined ? Common$AgdaModeVscode.Interval.toVSCodeRange(Caml_option.valFromOption(editor).document, interval) : new Vscode.Range(new Vscode.Position(0, interval[0]), new Vscode.Position(0, interval[1])),
                param.text
              ];
      });
  var match = Util$AgdaModeVscode.Promise_.pending();
  var resolve = match[1];
  match[0].finally(function () {
        rewrites.forEach(function (rewrite) {
              Core__Option.forEach(rewrite.instance, (function (instance) {
                      Core__Option.forEach(editor, (function (extra) {
                              Core__Option.forEach(instance.decoration, Editor$AgdaModeVscode.Decoration.destroy);
                              var $$document = extra.document;
                              var range = Common$AgdaModeVscode.Interval.toVSCodeRange($$document, instance.interval);
                              var textUnderlineDecoration = Editor$AgdaModeVscode.Decoration.createTextUnderline();
                              Editor$AgdaModeVscode.Decoration.apply(extra, textUnderlineDecoration, [range]);
                              instance.decoration = Caml_option.some(textUnderlineDecoration);
                            }));
                    }));
            });
        self.semaphore = false;
        Chan$AgdaModeVscode.emit(self.chanLog, ["RewriteApplied"]);
      });
  var instance = self.instances[0];
  if (instance !== undefined) {
    return [
            {
              TAG: "Rewrite",
              _0: replacementRanges,
              _1: resolve
            },
            {
              TAG: "UpdateView",
              _0: Buffer$AgdaModeVscode.toSequence(instance.buffer),
              _1: instance.buffer.translation,
              _2: instance.buffer.candidateIndex
            }
          ];
  } else {
    deactivate(self);
    return [
            {
              TAG: "Rewrite",
              _0: replacementRanges,
              _1: resolve
            },
            "Deactivate"
          ];
  }
}

function run(self, editor, input) {
  var output;
  if (typeof input !== "object") {
    deactivate(self);
    output = ["Deactivate"];
  } else {
    switch (input.TAG) {
      case "Activate" :
          var intervals = input._0;
          self.activated = true;
          intervals.sort(function (x, y) {
                return Caml.int_compare(x[0], y[0]);
              });
          self.instances = intervals.map(function (extra) {
                if (editor === undefined) {
                  return {
                          interval: extra,
                          decoration: undefined,
                          buffer: Buffer$AgdaModeVscode.make()
                        };
                }
                var editor$1 = Caml_option.valFromOption(editor);
                var $$document = editor$1.document;
                var range = Common$AgdaModeVscode.Interval.toVSCodeRange($$document, extra);
                var textUnderlineDecoration = Editor$AgdaModeVscode.Decoration.createTextUnderline();
                Editor$AgdaModeVscode.Decoration.apply(editor$1, textUnderlineDecoration, [range]);
                return {
                        interval: extra,
                        decoration: Caml_option.some(textUnderlineDecoration),
                        buffer: Buffer$AgdaModeVscode.make()
                      };
              });
          output = ["Activate"];
          break;
      case "KeyUpdate" :
          var changes = input._0;
          if (changes.length !== 0 && self.activated && !self.semaphore) {
            var match = updateInstances(self.instances, changes);
            self.instances = match[0];
            output = applyRewrites(self, editor, match[1]);
          } else {
            output = [];
          }
          break;
      case "MouseSelect" :
          if (self.activated && !self.semaphore) {
            self.instances = validateCursorPositions(self.instances, input._0);
            output = self.instances.length === 0 ? run(self, editor, "Deactivate") : [];
          } else {
            output = [];
          }
          break;
      case "Candidate" :
          var action = input._0;
          var callback;
          if (typeof action !== "object") {
            switch (action) {
              case "BrowseUp" :
                  callback = (function (instance) {
                      instance.buffer = Buffer$AgdaModeVscode.moveUp(instance.buffer);
                      return instance.buffer.translation.candidateSymbols[instance.buffer.candidateIndex];
                    });
                  break;
              case "BrowseDown" :
                  callback = (function (instance) {
                      instance.buffer = Buffer$AgdaModeVscode.moveDown(instance.buffer);
                      return instance.buffer.translation.candidateSymbols[instance.buffer.candidateIndex];
                    });
                  break;
              case "BrowseLeft" :
                  callback = (function (instance) {
                      instance.buffer = Buffer$AgdaModeVscode.moveLeft(instance.buffer);
                      return instance.buffer.translation.candidateSymbols[instance.buffer.candidateIndex];
                    });
                  break;
              case "BrowseRight" :
                  callback = (function (instance) {
                      instance.buffer = Buffer$AgdaModeVscode.moveRight(instance.buffer);
                      return instance.buffer.translation.candidateSymbols[instance.buffer.candidateIndex];
                    });
                  break;
              
            }
          } else {
            var symbol = action._0;
            callback = (function (param) {
                return symbol;
              });
          }
          var rewrites = toRewrites(self.instances, callback);
          output = applyRewrites(self, editor, rewrites);
          break;
      
    }
  }
  logOutput(self, output);
  return output;
}

var Module = {
  make: make,
  isActivated: isActivated,
  bufferIsEmpty: bufferIsEmpty,
  run: run
};

exports.Input = Input;
exports.Output = Output;
exports.Log = Log;
exports.Module = Module;
exports.make = make;
exports.isActivated = isActivated;
exports.bufferIsEmpty = bufferIsEmpty;
exports.run = run;
/* vscode Not a pure module */
