// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Js_exn = require("rescript/lib/js/js_exn.js");
var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Core__List = require("@rescript/core/lib/js/src/Core__List.bs.js");
var Core__Array = require("@rescript/core/lib/js/src/Core__Array.bs.js");
var TokenChange$AgdaModeVscode = require("./TokenChange.bs.js");

function deltaToString(delta) {
  if (delta > 0) {
    return " +" + String(delta) + " ";
  } else if (delta < 0) {
    return " " + String(delta) + " ";
  } else {
    return " +0 ";
  }
}

function toString(xs) {
  if (typeof xs !== "object") {
    return "EOF";
  }
  var tail = xs._3;
  var delta = xs._2;
  var end = xs._1;
  var start = xs._0;
  if (start === end) {
    return String(start) + "┃" + String(end) + deltaToString(delta) + (
            tail === "EOF" ? "" : toString(tail)
          );
  } else {
    return String(start) + "┣━━┫" + String(end) + deltaToString(delta) + (
            tail === "EOF" ? "" : toString(tail)
          );
  }
}

function hasError(xs) {
  var _prevEnd = 0;
  var _before = 0;
  var _xs = xs;
  while(true) {
    var xs$1 = _xs;
    var before = _before;
    var prevEnd = _prevEnd;
    if (typeof xs$1 !== "object") {
      return ;
    }
    var after = xs$1._2;
    var end = xs$1._1;
    var start = xs$1._0;
    var removed = end - start | 0;
    var inserted = (after - before | 0) + removed | 0;
    if (start < prevEnd) {
      return "Overlapping";
    }
    if (start > end) {
      return "ReversedOrder";
    }
    if (inserted < 0) {
      return "NegativeInsertion";
    }
    if (start === end && inserted === 0) {
      return "Empty";
    }
    _xs = xs$1._3;
    _before = after;
    _prevEnd = end;
    continue ;
  };
}

function debugIsValid(xs) {
  var match = hasError(xs);
  var aux;
  if (match !== undefined) {
    switch (match) {
      case "Overlapping" :
          aux = "Has overlapping intervals";
          break;
      case "ReversedOrder" :
          aux = "Has reversed order intervals";
          break;
      case "NegativeInsertion" :
          aux = "Has negative insertion";
          break;
      case "Empty" :
          aux = "Has empty intervals";
          break;
      
    }
  } else {
    aux = undefined;
  }
  if (aux !== undefined) {
    console.log("Intervals: " + toString(xs));
    console.log("Error: " + aux);
    return ;
  }
  
}

function totalDelta(_xs) {
  while(true) {
    var xs = _xs;
    if (typeof xs !== "object") {
      return 0;
    }
    var tail = xs._3;
    if (typeof tail !== "object") {
      return xs._2;
    }
    _xs = tail;
    continue ;
  };
}

function removedIntervals(_xs) {
  while(true) {
    var xs = _xs;
    if (typeof xs !== "object") {
      return [];
    }
    var tail = xs._3;
    var end = xs._1;
    var start = xs._0;
    if (start !== end) {
      return Belt_Array.concatMany([
                  [[
                      start,
                      end
                    ]],
                  removedIntervals(tail)
                ]);
    }
    _xs = tail;
    continue ;
  };
}

function isValidWRTChanges(xs, changes) {
  var sameTotalDelta = totalDelta(xs) === TokenChange$AgdaModeVscode.totalDelta(changes);
  var sameRemovedIntervals = Caml_obj.equal(removedIntervals(xs), Core__Array.filterMap(changes.map(TokenChange$AgdaModeVscode.removedInterval), (function (x) {
              return x;
            })));
  if (hasError(xs) === undefined && sameTotalDelta) {
    return sameRemovedIntervals;
  } else {
    return false;
  }
}

function isValidWRTChangeBatches(xs, batches) {
  var sameTotalDelta = totalDelta(xs) === Core__Array.reduce(batches, 0, (function (acc, changes) {
          return acc + TokenChange$AgdaModeVscode.totalDelta(changes) | 0;
        }));
  if (hasError(xs) === undefined) {
    return sameTotalDelta;
  } else {
    return false;
  }
}

function toString$1(x) {
  switch (x.TAG) {
    case "Before" :
        return "Before " + String(x._0);
    case "InInsertion" :
        return "InInsertion " + String(x._0);
    case "After" :
        return "After " + String(x._0);
    
  }
}

function calculateOriginalOffset(deltaBefore, start, end, deltaAfter, x) {
  if (x >= (end + deltaAfter | 0)) {
    return {
            TAG: "After",
            _0: x - deltaAfter | 0
          };
  } else if (x <= (deltaBefore + start | 0)) {
    return {
            TAG: "Before",
            _0: x - deltaBefore | 0
          };
  } else {
    return {
            TAG: "InInsertion",
            _0: x - deltaBefore | 0
          };
  }
}

var Source = {
  toString: toString$1,
  calculateOriginalOffset: calculateOriginalOffset
};

function printInterval(deltaBefore, start, end, deltaAfter) {
  console.log("interval delta before: " + String(deltaBefore));
  console.log("         delta after: " + String(deltaAfter));
  console.log("         start: " + String(start));
  console.log("         end: " + String(end));
  console.log("         removed: " + String(end - start | 0));
  console.log("         inserted: " + String(((deltaAfter - deltaBefore | 0) + end | 0) - start | 0));
}

function addInterval(deltaBefore, start, end, deltaAfter, xs) {
  if (start === end && deltaBefore === deltaAfter) {
    return xs;
  } else {
    return {
            TAG: "Replace",
            _0: start,
            _1: end,
            _2: deltaAfter,
            _3: xs
          };
  }
}

function applyChangeAux(_xs, deltaBefore, translation, _changes) {
  while(true) {
    var changes = _changes;
    var xs = _xs;
    if (changes) {
      var changes$1 = changes.tl;
      var change = changes.hd;
      if (typeof xs !== "object") {
        var deltaAfter = deltaBefore + TokenChange$AgdaModeVscode.delta(change) | 0;
        return addInterval(deltaBefore, change.offset - deltaBefore | 0, (change.offset + change.removed | 0) - deltaBefore | 0, deltaAfter, applyChangeAux("EOF", deltaAfter, translation, changes$1));
      }
      var tail = xs._3;
      var end = xs._1;
      var start = xs._0;
      var deltaAfter$1 = xs._2 + translation | 0;
      var changeRemovalStart = calculateOriginalOffset(deltaBefore, start, end, deltaAfter$1, change.offset);
      var changeRemovalEnd = calculateOriginalOffset(deltaBefore, start, end, deltaAfter$1, change.offset + change.removed | 0);
      var exit = 0;
      switch (changeRemovalEnd.TAG) {
        case "InInsertion" :
            var changeEnd = changeRemovalEnd._0;
            if (end >= changeEnd) {
              _changes = {
                hd: change,
                tl: changes$1
              };
              _xs = {
                TAG: "Replace",
                _0: start,
                _1: changeEnd,
                _2: deltaBefore - translation | 0,
                _3: {
                  TAG: "Replace",
                  _0: changeEnd,
                  _1: end,
                  _2: deltaAfter$1 - translation | 0,
                  _3: tail
                }
              };
              continue ;
            }
            var part1Delta = changeEnd - end | 0;
            _changes = {
              hd: change,
              tl: changes$1
            };
            _xs = {
              TAG: "Replace",
              _0: start,
              _1: end,
              _2: (deltaBefore + part1Delta | 0) - translation | 0,
              _3: {
                TAG: "Replace",
                _0: end,
                _1: end,
                _2: deltaAfter$1 - translation | 0,
                _3: tail
              }
            };
            continue ;
        case "Before" :
        case "After" :
            exit = 2;
            break;
        
      }
      if (exit === 2) {
        switch (changeRemovalStart.TAG) {
          case "Before" :
              var changeStart = changeRemovalStart._0;
              if (changeRemovalEnd.TAG === "Before") {
                var delta = TokenChange$AgdaModeVscode.delta(change);
                return addInterval(deltaBefore, changeStart, changeRemovalEnd._0, deltaBefore + delta | 0, applyChangeAux(xs, deltaBefore + delta | 0, translation + delta | 0, changes$1));
              }
              var delta$1 = ((changeStart - end | 0) + deltaBefore | 0) - deltaAfter$1 | 0;
              var change$p_offset = (end + deltaAfter$1 | 0) + delta$1 | 0;
              var change$p_removed = change.removed + delta$1 | 0;
              var change$p_inserted = change.inserted;
              var change$p = {
                offset: change$p_offset,
                removed: change$p_removed,
                inserted: change$p_inserted
              };
              return addInterval(deltaBefore, changeStart, end, deltaAfter$1 + delta$1 | 0, applyChangeAux(tail, deltaAfter$1 + delta$1 | 0, translation + delta$1 | 0, {
                              hd: change$p,
                              tl: changes$1
                            }));
          case "InInsertion" :
              if (changeRemovalEnd.TAG !== "Before") {
                var delta$2 = (changeRemovalEnd._0 - end | 0) - change.removed | 0;
                var change$p_offset$1 = (end + deltaAfter$1 | 0) + delta$2 | 0;
                var change$p_removed$1 = change.removed + delta$2 | 0;
                var change$p_inserted$1 = change.inserted;
                var change$p$1 = {
                  offset: change$p_offset$1,
                  removed: change$p_removed$1,
                  inserted: change$p_inserted$1
                };
                return addInterval(deltaBefore, start, end, deltaAfter$1 + delta$2 | 0, applyChangeAux(tail, deltaAfter$1 + delta$2 | 0, translation + delta$2 | 0, {
                                hd: change$p$1,
                                tl: changes$1
                              }));
              }
              break;
          case "After" :
              if (changeRemovalEnd.TAG !== "Before") {
                return addInterval(deltaBefore, start, end, deltaAfter$1, applyChangeAux(tail, deltaAfter$1, translation, {
                                hd: change,
                                tl: changes$1
                              }));
              }
              break;
          
        }
      }
      return Js_exn.raiseError("Not a possible case: " + toString$1(changeRemovalStart) + " " + toString$1(changeRemovalEnd));
    }
    if (typeof xs !== "object") {
      return "EOF";
    }
    var deltaAfter$2 = xs._2 + translation | 0;
    return addInterval(deltaBefore, xs._0, xs._1, deltaAfter$2, applyChangeAux(xs._3, deltaAfter$2, translation, /* [] */0));
  };
}

function preprocessChangeBatch(changes) {
  return Core__Array.reduce(changes, [
                0,
                []
              ], (function (param, x) {
                  var delta = param[0];
                  var acc = Belt_Array.concatMany([
                        param[1],
                        [TokenChange$AgdaModeVscode.translate(x, delta)]
                      ]);
                  return [
                          delta + TokenChange$AgdaModeVscode.delta(x) | 0,
                          acc
                        ];
                }))[1];
}

function applyChanges(xs, changes) {
  return applyChangeAux(xs, 0, 0, Core__List.fromArray(preprocessChangeBatch(changes)));
}

var empty = "EOF";

exports.deltaToString = deltaToString;
exports.toString = toString;
exports.empty = empty;
exports.hasError = hasError;
exports.debugIsValid = debugIsValid;
exports.totalDelta = totalDelta;
exports.removedIntervals = removedIntervals;
exports.isValidWRTChanges = isValidWRTChanges;
exports.isValidWRTChangeBatches = isValidWRTChangeBatches;
exports.Source = Source;
exports.printInterval = printInterval;
exports.addInterval = addInterval;
exports.applyChangeAux = applyChangeAux;
exports.preprocessChangeBatch = preprocessChangeBatch;
exports.applyChanges = applyChanges;
/* TokenChange-AgdaModeVscode Not a pure module */
