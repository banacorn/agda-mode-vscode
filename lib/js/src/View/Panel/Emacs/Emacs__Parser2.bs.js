// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Core__Array = require("@rescript/core/lib/js/src/Core__Array.bs.js");
var Core__Option = require("@rescript/core/lib/js/src/Core__Option.bs.js");
var Caml_splice_call = require("rescript/lib/js/caml_splice_call.js");
var Agda$AgdaModeVscode = require("../../../Agda.bs.js");
var Item$AgdaModeVscode = require("../../Component/Item.bs.js");
var Util$AgdaModeVscode = require("../../../Util/Util.bs.js");
var Common$AgdaModeVscode = require("../../Common.bs.js");
var Parser$AgdaModeVscode = require("../../../Parser/Parser.bs.js");
var RichText$AgdaModeVscode = require("../../Component/RichText.bs.js");
var Emacs__Parser$AgdaModeVscode = require("./Emacs__Parser.bs.js");

function partiteMetas(xs) {
  return Emacs__Parser$AgdaModeVscode.Dictionary.split(xs, "metas", (function (rawMetas) {
                var metas = Emacs__Parser$AgdaModeVscode.aggregateLines(rawMetas);
                var indexOfHiddenMetas = Belt_Array.getIndexBy(metas, (function (s) {
                        return Core__Option.isSome(Agda$AgdaModeVscode.Output.parseOutputWithLocation(s));
                      }));
                return Emacs__Parser$AgdaModeVscode.Dictionary.partite(metas, (function (param) {
                              var i = param[1];
                              if (indexOfHiddenMetas !== undefined) {
                                if (i === indexOfHiddenMetas) {
                                  return "hiddenMetas";
                                } else if (i === 0) {
                                  return "interactionMetas";
                                } else {
                                  return ;
                                }
                              } else if (i === 0) {
                                return "interactionMetas";
                              } else {
                                return ;
                              }
                            }));
              }));
}

function partiteWarningsOrErrors(xs, key) {
  return Emacs__Parser$AgdaModeVscode.Dictionary.update(xs, key, (function (raw) {
                var hasDelimeter = Core__Option.isSome(Core__Option.flatMap(raw[0], (function (__x) {
                            return Caml_option.nullable_to_opt(__x.match(/^\u2014{4}/));
                          })));
                var lines = hasDelimeter ? raw.slice(1) : raw;
                var markWarningStart = function (line) {
                  return Core__Option.isSome(Common$AgdaModeVscode.AgdaRange.parse(line));
                };
                var glueBack = function (xs) {
                  return Core__Option.isSome(Core__Option.flatMap(xs[xs.length - 1 | 0], (function (__x) {
                                    return Caml_option.nullable_to_opt(__x.match(/at$/));
                                  })));
                };
                return Emacs__Parser$AgdaModeVscode.Array_.mergeWithNext(Emacs__Parser$AgdaModeVscode.Array_.partite(lines, markWarningStart), glueBack).map(Util$AgdaModeVscode.$$String.unlines);
              }));
}

function parseError(raw) {
  var lines = Parser$AgdaModeVscode.splitToLines(raw);
  var hasBothErrorsAndWarnings = Core__Option.isSome(Core__Option.flatMap(lines[0], (function (__x) {
              return Caml_option.nullable_to_opt(__x.match(/^\u2014{4} Error/));
            })));
  var markWarningStart = function (line) {
    return Core__Option.isSome(Common$AgdaModeVscode.AgdaRange.parse(line));
  };
  var glueBack = function (xs) {
    return Core__Option.isSome(Core__Option.flatMap(xs[xs.length - 1 | 0], (function (__x) {
                      return Caml_option.nullable_to_opt(__x.match(/at$/));
                    })));
  };
  if (!hasBothErrorsAndWarnings) {
    return Emacs__Parser$AgdaModeVscode.Dictionary.update(Emacs__Parser$AgdaModeVscode.Dictionary.partite(lines, (function (param) {
                      if (param[1] === 0) {
                        return "errors";
                      }
                      
                    })), "errors", (function (xs) {
                  return [Util$AgdaModeVscode.$$String.unlines(xs)];
                }));
  }
  var isWarning = function (line) {
    return Core__Option.isSome(Caml_option.nullable_to_opt(line.match(/^\u2014{4} Warning\(s\)/)));
  };
  var predicate = function (param) {
    if (param[1] === 0) {
      return "errors";
    } else if (isWarning(param[0])) {
      return "warnings";
    } else {
      return ;
    }
  };
  return Emacs__Parser$AgdaModeVscode.Dictionary.update(Emacs__Parser$AgdaModeVscode.Dictionary.update(Emacs__Parser$AgdaModeVscode.Dictionary.partite(lines, predicate), "errors", (function (xs) {
                    return [Util$AgdaModeVscode.$$String.unlines(xs.slice(1))];
                  })), "warnings", (function (xs) {
                return Emacs__Parser$AgdaModeVscode.Array_.mergeWithNext(Emacs__Parser$AgdaModeVscode.Array_.partite(xs.slice(1), markWarningStart), glueBack).map(Util$AgdaModeVscode.$$String.unlines);
              }));
}

function parseGoalType(raw) {
  var markGoal = function (param) {
    return Core__Option.map(Caml_option.nullable_to_opt(param[0].match(/^Goal:/)), (function (param) {
                  return "goal";
                }));
  };
  var markHave = function (param) {
    return Core__Option.map(Caml_option.nullable_to_opt(param[0].match(/^Have:/)), (function (param) {
                  return "have";
                }));
  };
  var markMetas = function (param) {
    return Core__Option.map(Caml_option.nullable_to_opt(param[0].match(/\u2014{60}/g)), (function (param) {
                  return "metas";
                }));
  };
  var partiteGoalTypeContext = function (xs) {
    return Emacs__Parser$AgdaModeVscode.Dictionary.partite(xs, (function (line) {
                  var v = markGoal(line);
                  if (v !== undefined) {
                    return v;
                  }
                  var v$1 = markHave(line);
                  if (v$1 !== undefined) {
                    return v$1;
                  }
                  var v$2 = markMetas(line);
                  if (v$2 !== undefined) {
                    return v$2;
                  }
                  
                }));
  };
  var removeDelimeter = function (xs) {
    return Emacs__Parser$AgdaModeVscode.Dictionary.update(xs, "metas", (function (__x) {
                  return __x.slice(1);
                }));
  };
  var lines = Parser$AgdaModeVscode.splitToLines(raw);
  return partiteMetas(removeDelimeter(partiteGoalTypeContext(lines)));
}

function render(dictionary) {
  var __x = Object.entries(dictionary).map(function (param) {
        var lines = param[1];
        switch (param[0]) {
          case "errors" :
              return lines.map(function (line) {
                          return Item$AgdaModeVscode.error(RichText$AgdaModeVscode.parse(line), undefined);
                        });
          case "goal" :
              return Core__Option.mapOr(Agda$AgdaModeVscode.Expr.parse(Util$AgdaModeVscode.$$String.unlines(lines).slice(5)), [], (function (expr) {
                            return [{
                                      TAG: "Labeled",
                                      _0: "Goal",
                                      _1: "special",
                                      _2: Agda$AgdaModeVscode.Expr.render(expr),
                                      _3: undefined,
                                      _4: undefined
                                    }];
                          }));
          case "have" :
              return Core__Option.mapOr(Agda$AgdaModeVscode.Expr.parse(Util$AgdaModeVscode.$$String.unlines(lines).slice(5)), [], (function (expr) {
                            return [{
                                      TAG: "Labeled",
                                      _0: "Have",
                                      _1: "special",
                                      _2: Agda$AgdaModeVscode.Expr.render(expr),
                                      _3: undefined,
                                      _4: undefined
                                    }];
                          }));
          case "hiddenMetas" :
              return Core__Array.filterMap(lines.map(Agda$AgdaModeVscode.Output.parseOutputWithLocation), (function (x) {
                              return x;
                            })).map(function (output) {
                          return Agda$AgdaModeVscode.Output.renderItem(output);
                        });
          case "interactionMetas" :
              return Core__Array.filterMap(lines.map(Agda$AgdaModeVscode.Output.parseOutputWithoutLocation), (function (x) {
                              return x;
                            })).map(function (output) {
                          return Agda$AgdaModeVscode.Output.renderItem(output);
                        });
          case "metas" :
              return Core__Array.filterMap(lines.map(Agda$AgdaModeVscode.Output.parse), (function (x) {
                              return x;
                            })).map(function (output) {
                          return Agda$AgdaModeVscode.Output.renderItem(output);
                        });
          case "warnings" :
              return lines.map(function (line) {
                          return Item$AgdaModeVscode.warning(RichText$AgdaModeVscode.parse(line), undefined);
                        });
          default:
            return [];
        }
      });
  return Caml_splice_call.spliceObjApply([], "concat", [__x]);
}

function parseAllGoalsWarnings(title, body) {
  var partiteAllGoalsWarnings = function (title, body) {
    var lines = Parser$AgdaModeVscode.splitToLines(body);
    var hasMetas = Core__Option.isSome(Caml_option.nullable_to_opt(title.match(/Goals/)));
    var hasWarnings = Core__Option.isSome(Caml_option.nullable_to_opt(title.match(/Warnings/)));
    var hasErrors = Core__Option.isSome(Caml_option.nullable_to_opt(title.match(/Errors/)));
    var markMetas = function (param) {
      if (hasMetas && param[1] === 0) {
        return "metas";
      }
      
    };
    var markWarnings = function (param) {
      if (hasWarnings) {
        if (hasMetas) {
          return Core__Option.map(Caml_option.nullable_to_opt(param[0].slice(5, 13).match(/Warnings/)), (function (param) {
                        return "warnings";
                      }));
        } else if (param[1] === 0) {
          return "warnings";
        } else {
          return ;
        }
      }
      
    };
    var markErrors = function (param) {
      if (hasErrors) {
        if (hasMetas || hasWarnings) {
          return Core__Option.map(Caml_option.nullable_to_opt(param[0].slice(5, 11).match(/Errors/)), (function (param) {
                        return "errors";
                      }));
        } else if (param[1] === 0) {
          return "errors";
        } else {
          return ;
        }
      }
      
    };
    return Emacs__Parser$AgdaModeVscode.Dictionary.partite(lines, (function (line) {
                  var value = markMetas(line);
                  if (value !== undefined) {
                    return value;
                  }
                  var value$1 = markWarnings(line);
                  if (value$1 !== undefined) {
                    return value$1;
                  }
                  var value$2 = markErrors(line);
                  if (value$2 !== undefined) {
                    return value$2;
                  }
                  
                }));
  };
  return partiteWarningsOrErrors(partiteWarningsOrErrors(partiteMetas(partiteAllGoalsWarnings(title, body)), "warnings"), "errors");
}

function parseOutputs(raw) {
  var lines = Emacs__Parser$AgdaModeVscode.aggregateLines(Parser$AgdaModeVscode.splitToLines(raw));
  return Core__Array.filterMap(lines.map(Agda$AgdaModeVscode.Output.parse), (function (x) {
                  return x;
                })).map(function (output) {
              return Agda$AgdaModeVscode.Output.renderItem(output);
            });
}

function parseAndRenderTextWithLocation(raw) {
  return [{
            TAG: "Unlabeled",
            _0: RichText$AgdaModeVscode.parse(raw),
            _1: undefined,
            _2: undefined
          }];
}

function parseAndRenderSearchAbout(raw) {
  var lines = Parser$AgdaModeVscode.splitToLines(raw);
  var outputs = Core__Array.filterMap(Emacs__Parser$AgdaModeVscode.aggregateLines(lines.slice(1).map(function (__x) {
                    return __x.slice(2);
                  })).map(Agda$AgdaModeVscode.Output.parse), (function (x) {
            return x;
          })).map(function (output) {
        return Agda$AgdaModeVscode.Output.renderItem(output);
      });
  var target = Core__Option.map(lines[0], (function (__x) {
          return __x.slice(18);
        }));
  if (target !== undefined) {
    if (outputs.length === 0) {
      return [{
                TAG: "Unlabeled",
                _0: RichText$AgdaModeVscode.parse("There are no definitions about " + target),
                _1: undefined,
                _2: undefined
              }];
    } else {
      return [
                [{
                    TAG: "Unlabeled",
                    _0: RichText$AgdaModeVscode.parse("Definitions about " + (target + ":")),
                    _1: undefined,
                    _2: undefined
                  }],
                outputs
              ].flat();
    }
  } else {
    return [{
              TAG: "Unlabeled",
              _0: RichText$AgdaModeVscode.parse("Don't know what to search about"),
              _1: undefined,
              _2: undefined
            }];
  }
}

exports.partiteMetas = partiteMetas;
exports.partiteWarningsOrErrors = partiteWarningsOrErrors;
exports.parseError = parseError;
exports.parseGoalType = parseGoalType;
exports.render = render;
exports.parseAllGoalsWarnings = parseAllGoalsWarnings;
exports.parseOutputs = parseOutputs;
exports.parseAndRenderTextWithLocation = parseAndRenderTextWithLocation;
exports.parseAndRenderSearchAbout = parseAndRenderSearchAbout;
/* Agda-AgdaModeVscode Not a pure module */
