// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Os = require("os");
var Curry = require("bs-platform/lib/js/curry.js");
var $$String = require("bs-platform/lib/js/string.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Child_process = require("child_process");
var Util$AgdaModeVscode = require("./Util/Util.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");
var Event$AgdaModeVscode = require("./Util/Event.bs.js");

function toString(name) {
  switch (name.tag | 0) {
    case /* ProcessHanging */0 :
        return /* tuple */[
                "Process not responding when looking for \"" + (name[0] + "\""),
                "Please restart the process"
              ];
    case /* NotSupported */1 :
        return /* tuple */[
                "Auto search failed",
                "currently auto path searching is not supported on " + (String(name[0]) + "")
              ];
    case /* NotFound */2 :
        return /* tuple */[
                "Auto search failed when looking for \"" + (name[0] + "\""),
                "If you know where the executable of Agda is located, please fill it in \"agdaMode.agdaPath\" in the Settings.\nThe system responded with the following message " + (String(name[1]) + "")
              ];
    
  }
}

var $$Error = {
  toString: toString
};

function run(name) {
  var match = $$Promise.pending(undefined);
  var resolve = match[1];
  var hangTimeout = setTimeout((function (param) {
          return Curry._1(resolve, /* Error */Caml_chrome_debugger.variant("Error", 1, [/* ProcessHanging */Caml_chrome_debugger.variant("ProcessHanging", 0, [name])]));
        }), 1000);
  var os = Os.type();
  var commandName;
  switch (os) {
    case "Darwin" :
    case "Linux" :
        commandName = /* Ok */Caml_chrome_debugger.variant("Ok", 0, ["which"]);
        break;
    case "Windows_NT" :
        commandName = /* Ok */Caml_chrome_debugger.variant("Ok", 0, ["where.exe"]);
        break;
    default:
      commandName = /* Error */Caml_chrome_debugger.variant("Error", 1, [os]);
  }
  if (commandName.tag) {
    Curry._1(resolve, /* Error */Caml_chrome_debugger.variant("Error", 1, [/* NotSupported */Caml_chrome_debugger.variant("NotSupported", 1, [commandName[0]])]));
  } else {
    Child_process.exec(commandName[0] + (" " + name), (function (error, stdout, stderr) {
            clearTimeout(hangTimeout);
            Belt_Option.forEach((error == null) ? undefined : Caml_option.some(error), (function (err) {
                    return Curry._1(resolve, /* Error */Caml_chrome_debugger.variant("Error", 1, [/* NotFound */Caml_chrome_debugger.variant("NotFound", 2, [
                                      name,
                                      Belt_Option.getWithDefault(err.message, "")
                                    ])]));
                  }));
            var stderr$1 = stderr.toString();
            if (stderr$1 !== "") {
              Curry._1(resolve, /* Error */Caml_chrome_debugger.variant("Error", 1, [/* NotFound */Caml_chrome_debugger.variant("NotFound", 2, [
                          name,
                          stderr$1
                        ])]));
            }
            var stdout$1 = $$String.trim(stdout.toString());
            if (stdout$1 === "") {
              return Curry._1(resolve, /* Error */Caml_chrome_debugger.variant("Error", 1, [/* NotFound */Caml_chrome_debugger.variant("NotFound", 2, [
                                name,
                                ""
                              ])]));
            } else {
              return Curry._1(resolve, /* Ok */Caml_chrome_debugger.variant("Ok", 0, [stdout$1]));
            }
          }));
  }
  return match[0];
}

var PathSearch = {
  $$Error: $$Error,
  run: run
};

function toString$1(msg) {
  if (typeof msg === "number") {
    return /* tuple */[
            "Process hanging",
            "The program has not been responding for more than 1 sec"
          ];
  }
  switch (msg.tag | 0) {
    case /* PathMalformed */0 :
        return /* tuple */[
                "Path malformed",
                msg[0]
              ];
    case /* NotFound */1 :
        return /* tuple */[
                "Command not found",
                Util$AgdaModeVscode.JsError.toString(msg[0])
              ];
    case /* ShellError */2 :
        return /* tuple */[
                "Error from the shell",
                Util$AgdaModeVscode.JsError.toString(msg[0])
              ];
    case /* ProcessError */3 :
        return /* tuple */[
                "Error from the stderr",
                msg[0]
              ];
    case /* WrongProcess */4 :
        return /* tuple */[
                "Wrong process",
                msg[0]
              ];
    
  }
}

var $$Error$1 = {
  toString: toString$1
};

function run$1(path, validator) {
  var parseError = function (error) {
    return Belt_Option.map((error == null) ? undefined : Caml_option.some(error), (function (err) {
                  var message = Belt_Option.getWithDefault(err.message, "");
                  if (/No such file or directory/.test(message) || /command not found/.test(message)) {
                    return /* NotFound */Caml_chrome_debugger.variant("NotFound", 1, [err]);
                  } else {
                    return /* ShellError */Caml_chrome_debugger.variant("ShellError", 2, [err]);
                  }
                }));
  };
  var match = $$Promise.pending(undefined);
  var resolve = match[1];
  if (path === "") {
    Curry._1(resolve, /* Error */Caml_chrome_debugger.variant("Error", 1, [/* PathMalformed */Caml_chrome_debugger.variant("PathMalformed", 0, ["the path must not be empty"])]));
  }
  var hangTimeout = setTimeout((function (param) {
          return Curry._1(resolve, /* Error */Caml_chrome_debugger.variant("Error", 1, [/* ProcessHanging */0]));
        }), 20000);
  Child_process.exec(path, (function (error, stdout, stderr) {
          clearTimeout(hangTimeout);
          Belt_Option.forEach(parseError(error), (function (err) {
                  return Curry._1(resolve, /* Error */Caml_chrome_debugger.variant("Error", 1, [err]));
                }));
          var stderr$1 = stderr.toString();
          if (stderr$1 !== "") {
            Curry._1(resolve, /* Error */Caml_chrome_debugger.variant("Error", 1, [/* ProcessError */Caml_chrome_debugger.variant("ProcessError", 3, [stderr$1])]));
          }
          var stdout$1 = stdout.toString();
          var err = Curry._1(validator, stdout$1);
          if (err.tag) {
            return Curry._1(resolve, /* Error */Caml_chrome_debugger.variant("Error", 1, [/* WrongProcess */Caml_chrome_debugger.variant("WrongProcess", 4, [err[0]])]));
          } else {
            return Curry._1(resolve, /* Ok */Caml_chrome_debugger.variant("Ok", 0, [err[0]]));
          }
        }));
  return match[0];
}

var Validation = {
  $$Error: $$Error$1,
  run: run$1
};

function toString$2(error) {
  if (typeof error === "number") {
    if (error === /* DisconnectedByUser */0) {
      return /* tuple */[
              "Disconnected",
              "Connection disconnected by ourselves"
            ];
    } else {
      return /* tuple */[
              "Connection not established yet",
              "Please establish the connection first"
            ];
    }
  }
  switch (error.tag | 0) {
    case /* ClosedByProcess */0 :
        return /* tuple */[
                "Socket closed by process",
                "exited with code: " + (String(error[0]) + ("\nsignal: " + (String(error[1]) + "\n")))
              ];
    case /* ShellError */1 :
        return /* tuple */[
                "Socket error",
                Util$AgdaModeVscode.JsError.toString(error[0])
              ];
    case /* ExitedByProcess */2 :
        return /* tuple */[
                "The process has crashed !",
                "exited with code: " + (String(error[0]) + ("\n  signal: " + (String(error[1]) + ("\n  === message from stderr ===\n  " + (String(error[2]) + "\n  ")))))
              ];
    
  }
}

var $$Error$2 = {
  toString: toString$2
};

function make(path, args) {
  var emitter = Event$AgdaModeVscode.make(undefined);
  var stderr = {
    contents: ""
  };
  var $$process = Child_process.spawn("\"" + (path + "\""), args, {
        shell: true
      });
  $$process.stdout.on("data", (function (chunk) {
          Curry._1(emitter.emit, /* Stdout */Caml_chrome_debugger.variant("Stdout", 0, [chunk.toString()]));
          
        }));
  $$process.stderr.on("data", (function (chunk) {
          Curry._1(emitter.emit, /* Stderr */Caml_chrome_debugger.variant("Stderr", 1, [chunk.toString()]));
          stderr.contents = chunk.toString();
          
        }));
  $$process.stdin.on("close", (function (param) {
          Curry._1(emitter.emit, /* Error */Caml_chrome_debugger.variant("Error", 2, [/* ClosedByProcess */Caml_chrome_debugger.variant("ClosedByProcess", 0, [
                      0,
                      ""
                    ])]));
          
        }));
  $$process.on("close", (function (code, signal) {
                Curry._1(emitter.emit, /* Error */Caml_chrome_debugger.variant("Error", 2, [/* ClosedByProcess */Caml_chrome_debugger.variant("ClosedByProcess", 0, [
                            code,
                            signal
                          ])]));
                
              })).on("disconnect", (function (param) {
              Curry._1(emitter.emit, /* Error */Caml_chrome_debugger.variant("Error", 2, [/* DisconnectedByUser */0]));
              
            })).on("error", (function (exn) {
            Curry._1(emitter.emit, /* Error */Caml_chrome_debugger.variant("Error", 2, [/* ShellError */Caml_chrome_debugger.variant("ShellError", 1, [exn])]));
            
          })).on("exit", (function (code, signal) {
          if (code !== 0) {
            Curry._1(emitter.emit, /* Error */Caml_chrome_debugger.variant("Error", 2, [/* ExitedByProcess */Caml_chrome_debugger.variant("ExitedByProcess", 2, [
                        code,
                        signal,
                        stderr.contents
                      ])]));
            return ;
          }
          
        }));
  var $$process$1 = {
    contents: /* Connected */Caml_chrome_debugger.variant("Connected", 0, [$$process])
  };
  var send = function (request) {
    var $$process$2 = $$process$1.contents;
    if (typeof $$process$2 === "number") {
      return /* Error */Caml_chrome_debugger.variant("Error", 1, [/* NotEstablishedYet */1]);
    }
    if ($$process$2.tag) {
      return /* Error */Caml_chrome_debugger.variant("Error", 1, [/* NotEstablishedYet */1]);
    }
    var payload = Buffer.from(request + "\n");
    $$process$2[0].stdin.write(payload);
    return /* Ok */Caml_chrome_debugger.variant("Ok", 0, [undefined]);
  };
  var disconnect = function (param) {
    var process$prime = $$process$1.contents;
    if (typeof process$prime === "number") {
      return $$Promise.resolved(undefined);
    }
    if (process$prime.tag) {
      return process$prime[0];
    }
    var match = $$Promise.pending(undefined);
    var resolve = match[1];
    var promise = match[0];
    $$process$1.contents = /* Disconnecting */Caml_chrome_debugger.variant("Disconnecting", 1, [promise]);
    Curry._1(emitter.on, (function (param) {
            switch (param.tag | 0) {
              case /* Stdout */0 :
              case /* Stderr */1 :
                  return ;
              case /* Error */2 :
                  var tmp = param[0];
                  if (typeof tmp === "number") {
                    return ;
                  }
                  if (tmp.tag !== /* ExitedByProcess */2) {
                    return ;
                  }
                  Curry._1(emitter.destroy, undefined);
                  $$process$1.contents = /* Disconnected */0;
                  return Curry._1(resolve, undefined);
              
            }
          }));
    process$prime[0].kill("SIGTERM");
    return promise;
  };
  var isConnected = function (param) {
    var match = $$process$1.contents;
    if (typeof match === "number" || match.tag) {
      return false;
    } else {
      return true;
    }
  };
  return {
          send: send,
          emitter: emitter,
          disconnect: disconnect,
          isConnected: isConnected
        };
}

exports.PathSearch = PathSearch;
exports.Validation = Validation;
exports.$$Error = $$Error$2;
exports.make = make;
/* os Not a pure module */
